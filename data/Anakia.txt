Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.StringTokenizer;import org.apache.commons.collections.ExtendedProperties;import org.apache.commons.lang.StringUtils;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.VelocityEngine;import org.apache.velocity.runtime.RuntimeConstants;import org.jdom.Document;import org.jdom.JDOMException;import org.jdom.input.SAXBuilder;import org.jdom.output.Format;import org.xml.sax.SAXParseException;/** * This is the Anakia processor whicih allows you to do XML * transformations using Velocity style sheets. * * @author <a href="mailto:dev@velocity.apache.org">The Velocity developers community</a> * @version $Id: Anakia.java 534901 2007-05-03 15:00:59Z henning $ */public class Anakia{    private static final String [] ILLEGAL_CONTEXTNAMES = new String [] {        "relativePath", "treeWalk", "xpath", "escape", "date", "project"    };    private File baseDir = null;    private File destDir = null;    private String styleTemplate = null;    private File propertiesFile = null;    private File projectFile = null;    private File templatePath = null;    private String extension = null;    private List files = null;    private boolean checkLastModified = false;    private AnakiaLog log = null;    /** the Velocity subcontexts */    private List contexts = Collections.EMPTY_LIST;    private long styleSheetLastModified = 0;    private long projectFileLastModified = 0;    /** the VelocityEngine instance to use */    private final VelocityEngine ve;    /** <code>{@link SAXBuilder}</code> instance to use */    private final SAXBuilder builder;    public Anakia()    {        ve = new VelocityEngine();        builder = new SAXBuilder();        builder.setFactory(new AnakiaJDOMFactory());    }    protected File getBaseDir()    {        return baseDir;    }    public void setBaseDir(final File baseDir)    {        this.baseDir = baseDir;    }    protected File getDestDir()    {        return destDir;    }    public void setDestDir(final File destDir)    {        this.destDir = destDir;    }    protected List getFiles()    {        return files;    }    public void setFiles(final List files)    {        this.files = files;    }    protected File getProjectFile()    {        return projectFile;    }    public void setProjectFile(final File projectFile)    {        this.projectFile = projectFile;    }    protected File getPropertiesFile()    {        return propertiesFile;    }    public void setPropertiesFile(final File propertiesFile)    {        this.propertiesFile = propertiesFile;    }    protected String getStyleTemplate()    {        return styleTemplate;    }    public void setStyleTemplate(final String styleTemplate)    {        this.styleTemplate = styleTemplate;    }    protected File getTemplatePath()    {        return templatePath;    }    public void setTemplatePath(final File templatePath)    {        this.templatePath = templatePath;    }    protected boolean isCheckLastModified()    {        return checkLastModified;    }    public void setCheckLastModified(final boolean checkLastChanged)    {        this.checkLastModified = checkLastChanged;    }    protected String getExtension()    {        return extension;    }    public void setExtension(final String extension)    {        this.extension = extension;    }    protected AnakiaLog getLog()    {        return log;    }    public void setLog(final AnakiaLog log)    {        this.log = log;    }    protected List getContexts()    {        return contexts;    }    public void setContexts(final List contexts)    {        this.contexts = contexts;    }    protected SAXBuilder getBuilder()    {        return builder;    }    public void execute()        throws Exception    {        if (getPropertiesFile() != null && getPropertiesFile().exists())        {            String file = getPropertiesFile().getAbsolutePath();            ExtendedProperties config = new ExtendedProperties(file);            ve.setExtendedProperties(config);        }        // override the templatePath if it exists        if (getTemplatePath() != null)        {            ve.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, getTemplatePath().getCanonicalPath());        }        ve.init();        // get the last modification of the VSL stylesheet        styleSheetLastModified = ve.getTemplate(getStyleTemplate()).getLastModified();        projectFileLastModified = getProjectFile().lastModified();        // Build the Project file document        Document projectDocument = builder.build(getProjectFile());        for (Iterator it = getFiles().iterator(); it.hasNext(); )        {            String xmlFile = (String) it.next();            process(xmlFile, projectDocument);        }    }    /**     * Process an XML file using Velocity     */    private void process(final String xmlFile, final Document projectDocument)        throws AnakiaException    {        File   outFile = null;        File   inFile = null;        Writer writer = null;        try        {            // the current input file relative to the baseDir            inFile = new File(getBaseDir(),xmlFile);            // the output file relative to basedir            outFile = new File(getDestDir(),                            xmlFile.substring(0,                            xmlFile.lastIndexOf('.')) + getExtension());            // only process files that have changed            if (isCheckLastModified() == false ||                    (inFile.lastModified() > outFile.lastModified() ||                    styleSheetLastModified > outFile.lastModified() ||                    projectFileLastModified > outFile.lastModified() ||                    userContextsModifed(outFile.lastModified())))            {                ensureDirectoryFor(outFile);                //-- command line status                getLog().info("Input:  " + xmlFile);                // Build the JDOM Document                Document root = builder.build(inFile);                // Shove things into the Context                VelocityContext context = new VelocityContext();                /*                 *  get the property TEMPLATE_ENCODING                 *  we know it's a string...                 */                String encoding = (String) ve.getProperty(RuntimeConstants.OUTPUT_ENCODING);                if (encoding == null || encoding.length() == 0                    || encoding.equals("8859-1") || encoding.equals("8859_1"))                {                    encoding = "ISO-8859-1";                }                Format f = Format.getRawFormat();                f.setEncoding(encoding);                OutputWrapper ow = new OutputWrapper(f);                context.put ("root", root.getRootElement());                context.put ("xmlout", ow);                context.put ("relativePath", getRelativePath(xmlFile));                context.put ("treeWalk", new TreeWalker());                context.put ("xpath", new XPathTool());                context.put ("escape", new Escape());                context.put ("date", new java.util.Date());                /**                 * only put this into the context if it exists.                 */                if (projectDocument != null)                {                    context.put ("project", projectDocument.getRootElement());                }                /**                 *  Add the user subcontexts to the to context                 */                for (Iterator iter = contexts.iterator(); iter.hasNext(); )                {                    Context subContext = (Anakia.Context) iter.next();                    if (subContext == null)                    {                        throw new AnakiaException("Found an undefined SubContext!");                    }                    if (subContext.getContextDocument() == null)                    {                        throw new AnakiaException("Could not build a subContext for " + subContext.getName());                    }                    context.put(subContext.getName(), subContext                            .getContextDocument().getRootElement());                }                /**                 * Process the VSL template with the context and write out                 * the result as the outFile.                 */                writer = new BufferedWriter(new OutputStreamWriter(                                            new FileOutputStream(outFile),                                                encoding));                /**                 * get the template to process                 */                Template template = ve.getTemplate(getStyleTemplate());                template.merge(context, writer);                getLog().info("Output: " + outFile);            }        }        catch (JDOMException e)        {            outFile.delete();            if (e.getCause() != null)            {                Throwable rootCause = e.getCause();                if (rootCause instanceof SAXParseException)                {                    log.error("Error:  " + rootCause.getMessage());                    log.error("Line:   " + ((SAXParseException) rootCause).getLineNumber());                    log.error("Column: " + ((SAXParseException)rootCause).getColumnNumber());                }                else                {                    throw new AnakiaException(e.getCause());                }            }            else            {                throw new AnakiaException(e);            }        }        catch (Throwable t)        {            if (outFile != null)            {                outFile.delete();            }            throw new AnakiaException(t);        }        finally        {            if (writer != null)            {                try                {                    writer.flush();                }                catch (IOException e)                {                }                try                {                    writer.close();                }                catch (IOException e)                {                }            }        }    }    /**     * Hacky method to figure out the relative path     * that we are currently in. This is good for getting     * the relative path for images and anchor's.     */    private String getRelativePath(final String file)    {        if (StringUtils.isEmpty(file))        {            return "";        }        StringTokenizer st = new StringTokenizer(file, "/\\");        // needs to be -1 cause ST returns 1 even if there are no matches. huh?        int slashCount = st.countTokens() - 1;        StringBuffer sb = new StringBuffer();        for (int i=0;i<slashCount ;i++)        {            sb.append ("../");        }        if (sb.length() > 0)        {            return StringUtils.chomp(sb.toString(), "/");        }        return ".";    }    /**     * create directories as needed     */    private void ensureDirectoryFor(final File targetFile) throws AnakiaException    {        File directory = new File(targetFile.getParent());        if (!directory.exists())        {            if (!directory.mkdirs())            {                throw new AnakiaException("Unable to create directory: "                                         + directory.getAbsolutePath());            }        }    }    /**     * Check to see if user context is modified.     */    private boolean userContextsModifed(final long lastModified)    {        for (Iterator iter = contexts.iterator(); iter.hasNext();)        {            Anakia.Context ctx = (Anakia.Context) iter.next();            if(ctx != null && ctx.getLastModified() > lastModified)            {                return true;            }        }        return false;    }    /**     * A context implementation that loads all values from an XML file.     */    public class Context    {        private String name = null;        private Document contextDoc = null;        private String file = null;        /**         * Public constructor.         */        public Context()        {        }        /**         * Get the name of the context.         * @return The name of the context.         */        public String getName()        {            return name;        }        /**         * Set the name of the context.         * @param name         *         * @throws AnakiaException if a reserved word is used as a         * name, specifically any of "relativePath", "treeWalk", "xpath",         * "escape", "date", or "project"         */        public void setName(final String name)        {            for (int i = 0; i < ILLEGAL_CONTEXTNAMES.length; i++)            {                if (StringUtils.isEmpty(name) || ILLEGAL_CONTEXTNAMES[i].equals(name))                {                    throw new AnakiaException("Context name '" + name + "' is reserved by Anakia");                }            }            this.name = name;        }        /**         * Build the context based on a file path.         * @param file         */        public void setFile(final String file)        {            this.file = file;        }        /**         * Retrieve the time the source file was last modified.         * @return The time the source file was last modified.         */        public long getLastModified()        {            return new File(getBaseDir(), file).lastModified();        }        /**         * Retrieve the context document object.         * @return The context document object.         */        public Document getContextDocument()        {            if (contextDoc == null)            {                File contextFile = new File(getBaseDir(), file);                try                {                    contextDoc = getBuilder().build(contextFile);                }                catch (RuntimeException re)                {                    throw re;                }                catch (Exception e)                {                    throw new AnakiaException(e);                }            }            return contextDoc;        }    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     */import org.jdom.Element;import org.jdom.Namespace;import org.jdom.output.XMLOutputter;import java.util.List;/** * A JDOM {@link Element} that is tailored for Anakia needs. It has * {@link #selectNodes(String)} method as well as a {@link #toString()} that * outputs the XML serialized form of the element. This way it acts in much the * same way as a single-element {@link NodeList} would. * * @author <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a> * @version $Id: AnakiaElement.java 524478 2007-03-31 20:51:49Z wglass $ */public class AnakiaElement extends Element{    /**     * Version Id for serializable     */    private static final long serialVersionUID = 8429597252274491314L;    private static final XMLOutputter DEFAULT_OUTPUTTER = new XMLOutputter();    static    {        DEFAULT_OUTPUTTER.getFormat().setLineSeparator(System.getProperty("line.separator"));    }    /**     * <p>     * This will create a new <code>AnakiaElement</code>     *   with the supplied (local) name, and define     *   the <code>{@link Namespace}</code> to be used.     * If the provided namespace is null, the element will have     * no namespace.     * </p>     *     * @param name <code>String</code> name of element.     * @param namespace <code>Namespace</code> to put element in.     */    public AnakiaElement(String name, Namespace namespace)    {        super(name, namespace);    }    /**     * <p>     *  This will create an <code>AnakiaElement</code> in no     *    <code>{@link Namespace}</code>.     * </p>     *     * @param name <code>String</code> name of element.     */    public AnakiaElement(String name)    {        super(name);    }    /**     * <p>     *  This will create a new <code>AnakiaElement</code> with     *    the supplied (local) name, and specifies the URI     *    of the <code>{@link Namespace}</code> the <code>Element</code>     *    should be in, resulting it being unprefixed (in the default     *    namespace).     * </p>     *     * @param name <code>String</code> name of element.     * @param uri <code>String</code> URI for <code>Namespace</code> element     *        should be in.     */    public AnakiaElement(String name, String uri)    {        super(name, uri);    }    /**     * <p>     *  This will create a new <code>AnakiaElement</code> with     *    the supplied (local) name, and specifies the prefix and URI     *    of the <code>{@link Namespace}</code> the <code>Element</code>     *    should be in.     * </p>     *     * @param name <code>String</code> name of element.     * @param prefix The prefix of the element.     * @param uri <code>String</code> URI for <code>Namespace</code> element     *        should be in.     */    public AnakiaElement(String name, String prefix, String uri)    {        super(name, prefix, uri);    }    /**     * Applies an XPath expression to this element and returns the resulting     * node list. In order for this method to work, your application must have     * access to <a href="http://code.werken.com">werken.xpath</a> library     * classes. The implementation does cache the parsed format of XPath     * expressions in a weak hash map, keyed by the string representation of     * the XPath expression. As the string object passed as the argument is     * usually kept in the parsed template, this ensures that each XPath     * expression is parsed only once during the lifetime of the template that     * first invoked it.     * @param xpathExpression the XPath expression you wish to apply     * @return a NodeList representing the nodes that are the result of     * application of the XPath to the current element. It can be empty.     */    public NodeList selectNodes(String xpathExpression)    {        return new NodeList(XPathCache.getXPath(xpathExpression).applyTo(this), false);    }    /**     * Returns the XML serialized form of this element, as produced by the default     * {@link XMLOutputter}.     * @return The XML serialized form of this element, as produced by the default     * {@link XMLOutputter}.     */    public String toString()    {        return DEFAULT_OUTPUTTER.outputString(this);    }    /**     * <p>     * This returns the full content of the element as a NodeList which     * may contain objects of type <code>String</code>, <code>Element</code>,     * <code>Comment</code>, <code>ProcessingInstruction</code>,     * <code>CDATA</code>, and <code>EntityRef</code>.     * The List returned is "live" in document order and modifications     * to it affect the element's actual contents.  Whitespace content is     * returned in its entirety.     * </p>     *     * @return a <code>List</code> containing the mixed content of the     *         element: may contain <code>String</code>,     *         <code>{@link Element}</code>, <code>{@link org.jdom.Comment}</code>,     *         <code>{@link org.jdom.ProcessingInstruction}</code>,     *         <code>{@link org.jdom.CDATA}</code>, and     *         <code>{@link org.jdom.EntityRef}</code> objects.     */    public List getContent()    {        return new NodeList(super.getContent(), false);    }    /**     * <p>     * This returns a <code>NodeList</code> of all the child elements     * nested directly (one level deep) within this element, as     * <code>Element</code> objects.  If this target element has no nested     * elements, an empty List is returned.  The returned list is "live"     * in document order and changes to it affect the element's actual     * contents.     * </p>     * <p>     * This performs no recursion, so elements nested two levels     *   deep would have to be obtained with:     * <pre>     * <code>     *   Iterator itr = currentElement.getChildren().iterator();     *   while (itr.hasNext()) {     *     Element oneLevelDeep = (Element)nestedElements.next();     *     List twoLevelsDeep = oneLevelDeep.getChildren();     *     // Do something with these children     *   }     * </code>     * </pre>     * </p>     *     * @return list of child <code>Element</code> objects for this element     */    public List getChildren()    {        return new NodeList(super.getChildren(), false);    }    /**     * <p>     * This returns a <code>NodeList</code> of all the child elements     * nested directly (one level deep) within this element with the given     * local name and belonging to no namespace, returned as     * <code>Element</code> objects.  If this target element has no nested     * elements with the given name outside a namespace, an empty List     * is returned.  The returned list is "live" in document order     * and changes to it affect the element's actual contents.     * </p>     * <p>     * Please see the notes for <code>{@link #getChildren()}</code>     * for a code example.     * </p>     *     * @param name local name for the children to match     * @return all matching child elements     */    public List getChildren(String name)    {        return new NodeList(super.getChildren(name));    }    /**     * <p>     * This returns a <code>NodeList</code> of all the child elements     * nested directly (one level deep) within this element with the given     * local name and belonging to the given Namespace, returned as     * <code>Element</code> objects.  If this target element has no nested     * elements with the given name in the given Namespace, an empty List     * is returned.  The returned list is "live" in document order     * and changes to it affect the element's actual contents.     * </p>     * <p>     * Please see the notes for <code>{@link #getChildren()}</code>     * for a code example.     * </p>     *     * @param name local name for the children to match     * @param ns <code>Namespace</code> to search within     * @return all matching child elements     */    public List getChildren(String name, Namespace ns)    {        return new NodeList(super.getChildren(name, ns));    }    /**     * <p>     * This returns the complete set of attributes for this element, as a     * <code>NodeList</code> of <code>Attribute</code> objects in no particular     * order, or an empty list if there are none.     * The returned list is "live" and changes to it affect the     * element's actual attributes.     * </p>     *     * @return attributes for the element     */    public List getAttributes()    {        return new NodeList(super.getAttributes());    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. *//** * Exception thrown by the Anakia transformator. * * @author <a href="mailto:dev@velocity.apache.org">The Velocity developers community</a> * @version $Id: AnakiaException.java 534871 2007-05-03 14:07:00Z henning $ */public class AnakiaException        extends RuntimeException{     private static final long serialVersionUID = 1L;    public AnakiaException()    {        super();    }    public AnakiaException(final String msg)    {        super(msg);    }    public AnakiaException(final Throwable t)    {        super(t);    }    public AnakiaException(final String msg, final Throwable t)    {        super(msg, t);    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     */import org.jdom.Element;import org.jdom.Namespace;import org.jdom.DefaultJDOMFactory;/** * A customized JDOMFactory for Anakia that produces {@link AnakiaElement} * instances instead of ordinary JDOM {@link Element} instances. * * @author <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a> * @version $Id: AnakiaJDOMFactory.java 524478 2007-03-31 20:51:49Z wglass $ */public class AnakiaJDOMFactory extends DefaultJDOMFactory{    /**     *     */    public AnakiaJDOMFactory()    {    }    /**     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String, org.jdom.Namespace)     */    public Element element(String name, Namespace namespace)    {        return new AnakiaElement(name, namespace);    }    /**     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String)     */    public Element element(String name)    {        return new AnakiaElement(name);    }    /**     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String, java.lang.String)     */    public Element element(String name, String uri)    {        return new AnakiaElement(name, uri);    }    /**     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String, java.lang.String, java.lang.String)     */    public Element element(String name, String prefix, String uri)    {        return new AnakiaElement(name, prefix, uri);    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. *//** * Logging Facade to use logging in various contexts. * * @author <a href="mailto:dev@velocity.apache.org">The Velocity developers community</a> * @version $Id: AnakiaLog.java 534871 2007-05-03 14:07:00Z henning $ */public interface AnakiaLog{    void info(final String message);    void error(final String message);    void log(final String message, final int level);}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */import java.io.File;import java.util.Arrays;import java.util.LinkedList;import java.util.List;import org.apache.commons.lang.StringUtils;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Project;import org.apache.tools.ant.taskdefs.MatchingTask;/** * The purpose of this Ant Task is to allow you to use * Velocity as an XML transformation tool like XSLT is. * So, instead of using XSLT, you will be able to use this * class instead to do your transformations. It works very * similar in concept to Ant's &lt;style&gt; task. * <p> * You can find more documentation about this class on the * Velocity * <a href="http://velocity.apache.org/engine/devel/docs/anakia.html">Website</a>. * * @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a> * @author <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a> * @version $Id: AnakiaTask.java 534869 2007-05-03 14:05:18Z henning $ */public class AnakiaTask extends MatchingTask        implements AnakiaLog{    /** the destination directory */    private File destDir = null;    /** the base directory */    File baseDir = null;    /** the style= attribute */    private String style = null;    /** the projectFile= attribute */    private String projectFile = null;    /** check the last modified date on files. defaults to true */    private boolean lastModifiedCheck = true;    /** the default output extension is .html */    private String extension = ".html";    /** the Velocity subcontexts */    private List contexts = new LinkedList();    /** the template path */    private File templatePath = null;    /** the file to get the velocity properties file */    private File propertiesFile = null;    private final Anakia anakia;    /**     * Constructor creates the SAXBuilder.     */    public AnakiaTask()    {        this.anakia = new Anakia();    }    /**     * Set the base directory.     * @param dir     */    public void setBasedir(final File baseDir)    {        this.baseDir = baseDir;    }    /**     * Set the destination directory into which the VSL result     * files should be copied to     * @param dir the name of the destination directory     */    public void setDestdir(final File destDir)    {        this.destDir = destDir;    }    /**     * Allow people to set the default output file extension     * @param extension     */    public void setExtension(final String extension)    {        this.extension = extension;    }    /**     * Allow people to set the path to the .vsl file     * @param style     */    public void setStyle(final String style)    {        this.style = style;    }    /**     * Allow people to set the path to the project.xml file     * @param projectFile     */    public void setProjectFile(final String projectFile)    {        this.projectFile = projectFile;    }    /**     * Set the path to the templates.     * The way it works is this:     * If you have a Velocity.properties file defined, this method     * will <strong>override</strong> whatever is set in the     * Velocity.properties file. This allows one to not have to define     * a Velocity.properties file, therefore using Velocity's defaults     * only.     * @param templatePath     */    public void setTemplatePath(final File templatePath)    {        this.templatePath = templatePath;    }    /**     * Allow people to set the path to the velocity.properties file     * This file is found relative to the path where the JVM was run.     * For example, if build.sh was executed in the ./build directory,     * then the path would be relative to this directory.     * This is optional based on the setting of setTemplatePath().     * @param propertiesFile     */    public void setVelocityPropertiesFile(final File propertiesFile)    {        this.propertiesFile = propertiesFile;    }    /**     * Turn on/off last modified checking. by default, it is on.     * @param lastmod     */    public void setLastModifiedCheck(final String lastmod)    {        if (lastmod.equalsIgnoreCase("false") || lastmod.equalsIgnoreCase("no")                || lastmod.equalsIgnoreCase("off"))        {            this.lastModifiedCheck = false;        }    }    public void info(final String message)    {        log(message, Project.MSG_INFO);    }    public void error(final String message)    {        log(message, Project.MSG_ERR);    }    /**     * Main body of the application     * @throws BuildException     */    public void execute() throws BuildException    {        if (baseDir == null || !baseDir.exists())        {            baseDir = getProject().resolveFile(".");        }        anakia.setBaseDir(baseDir);        if (destDir == null)        {            throw new BuildException("destdir attribute must be set!");        }        anakia.setDestDir(destDir);        if (StringUtils.isEmpty(style))        {            throw new BuildException("style attribute must be set!");        }        anakia.setStyleTemplate(style);        if (propertiesFile == null)        {            propertiesFile = new File(baseDir, "velocity.properties");        }        /*         * If the props file doesn't exist AND a templatePath hasn't         * been defined, then throw the exception.         */        if (!propertiesFile.exists() && (templatePath == null || !templatePath.exists()))        {            throw new BuildException ("No template path set and properties file '" +                    propertiesFile.getAbsolutePath() + "' does not exist!");        }        anakia.setTemplatePath(templatePath);        anakia.setPropertiesFile(propertiesFile);        log("Transforming into: " + destDir.getAbsolutePath(), Project.MSG_INFO);        if (StringUtils.isNotEmpty(projectFile))        {            File file = new File(baseDir, projectFile);            if (!file.exists())            {                throw new BuildException("Project file '" + file.getAbsolutePath() + "' does not exist!");            }            anakia.setProjectFile(file);        }        DirectoryScanner scanner = getDirectoryScanner(baseDir);        anakia.setFiles(Arrays.asList(scanner.getIncludedFiles()));        anakia.setCheckLastModified(lastModifiedCheck);        anakia.setExtension(extension);        anakia.setLog(this);        anakia.setContexts(contexts);        try        {            anakia.execute();        }        catch (RuntimeException re)        {            throw re;        }        catch (Exception e)        {            throw new BuildException(e);        }    }    /**     * Create a new context.     * @return A new context.     */    public Anakia.Context createContext()    {        Anakia.Context context = anakia.new Context(); // Always wanted to use that... :-)        contexts.add(context);        return context;    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     *//** * This class is for escaping CDATA sections. The code was * "borrowed" from the JDOM code. Also included is escaping * the " -> &amp;quot; character and the conversion of newlines * to the platform line separator. * * @author <a href="mailto:wglass@apache.org">Will Glass-Husain</a> * @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a> * @version $Id: Escape.java 524478 2007-03-31 20:51:49Z wglass $ */public class Escape{    /**     *     */    public static final String LINE_SEPARATOR = System.getProperty("line.separator");    /**     * Empty constructor     */    public Escape()    {        // left blank on purpose    }    /**     * Do the escaping.     * @param st     * @return The escaped text.     */    public static final String getText(String st)    {        StringBuffer buff = new StringBuffer();        char[] block = st.toCharArray();        String stEntity = null;        int i, last;        for (i=0, last=0; i < block.length; i++)        {            switch(block[i])            {                case '<' :                    stEntity = "&lt;";                    break;                case '>' :                    stEntity = "&gt;";                    break;                case '&' :                    stEntity = "&amp;";                    break;                case '"' :                    stEntity = "&quot;";                    break;                case '\n' :                    stEntity = LINE_SEPARATOR;                    break;                default :                    /* no-op */                    break;            }            if (stEntity != null)            {                buff.append(block, last, i - last);                buff.append(stEntity);                stEntity = null;                last = i + 1;            }        }        if(last < block.length)        {            buff.append(block, last, i - last);        }        return buff.toString();    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     */import java.io.IOException;import java.io.StringWriter;import java.io.Writer;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import org.jdom.Attribute;import org.jdom.CDATA;import org.jdom.Comment;import org.jdom.DocType;import org.jdom.Document;import org.jdom.Element;import org.jdom.EntityRef;import org.jdom.ProcessingInstruction;import org.jdom.Text;import org.jdom.output.XMLOutputter;/** * Provides a class for wrapping a list of JDOM objects primarily for use in template * engines and other kinds of text transformation tools. * It has a {@link #toString()} method that will output the XML serialized form of the * nodes it contains - again focusing on template engine usage, as well as the * {@link #selectNodes(String)} method that helps selecting a different set of nodes * starting from the nodes in this list. The class also implements the {@link java.util.List} * interface by simply delegating calls to the contained list (the {@link #subList(int, int)} * method is implemented by delegating to the contained list and wrapping the returned * sublist into a <code>NodeList</code>). * * @author <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a> * @version $Id: NodeList.java 524478 2007-03-31 20:51:49Z wglass $ */public class NodeList implements List, Cloneable{    private static final AttributeXMLOutputter DEFAULT_OUTPUTTER =        new AttributeXMLOutputter();    /** The contained nodes */    private List nodes;    /**     * Creates an empty node list.     */    public NodeList()    {        nodes = new ArrayList();    }    /**     * Creates a node list that holds a single {@link Document} node.     * @param document     */    public NodeList(Document document)    {        this((Object)document);    }    /**     * Creates a node list that holds a single {@link Element} node.     * @param element     */    public NodeList(Element element)    {        this((Object)element);    }    private NodeList(Object object)    {        if(object == null)        {            throw new IllegalArgumentException(                "Cannot construct NodeList with null.");        }        nodes = new ArrayList(1);        nodes.add(object);    }    /**     * Creates a node list that holds a list of nodes.     * @param nodes the list of nodes this template should hold. The created     * template will copy the passed nodes list, so changes to the passed list     * will not affect the model.     */    public NodeList(List nodes)    {        this(nodes, true);    }    /**     * Creates a node list that holds a list of nodes.     * @param nodes the list of nodes this template should hold.     * @param copy if true, the created template will copy the passed nodes     * list, so changes to the passed list will not affect the model. If false,     * the model will reference the passed list and will sense changes in it,     * altough no operations on the list will be synchronized.     */    public NodeList(List nodes, boolean copy)    {        if(nodes == null)        {            throw new IllegalArgumentException(                "Cannot initialize NodeList with null list");        }        this.nodes = copy ? new ArrayList(nodes) : nodes;    }    /**     * Retrieves the underlying list used to store the nodes. Note however, that     * you can fully use the underlying list through the <code>List</code> interface     * of this class itself. You would probably access the underlying list only for     * synchronization purposes.     * @return The internal node List.     */    public List getList()    {        return nodes;    }    /**     * This method returns the string resulting from concatenation of string     * representations of its nodes. Each node is rendered using its XML     * serialization format. This greatly simplifies creating XML-transformation     * templates, as to output a node contained in variable x as XML fragment,     * you simply write ${x} in the template (or whatever your template engine     * uses as its expression syntax).     * @return The Nodelist as printable object.     */    public String toString()    {        if(nodes.isEmpty())        {            return "";        }        StringWriter sw = new StringWriter(nodes.size() * 128);        try        {            for(Iterator i = nodes.iterator(); i.hasNext();)            {                Object node = i.next();                if(node instanceof Element)                {                    DEFAULT_OUTPUTTER.output((Element)node, sw);                }                else if(node instanceof Attribute)                {                    DEFAULT_OUTPUTTER.output((Attribute)node, sw);                }                else if(node instanceof Text)                {                    DEFAULT_OUTPUTTER.output((Text)node, sw);                }                else if(node instanceof Document)                {                    DEFAULT_OUTPUTTER.output((Document)node, sw);                }                else if(node instanceof ProcessingInstruction)                {                    DEFAULT_OUTPUTTER.output((ProcessingInstruction)node, sw);                }                else if(node instanceof Comment)                {                    DEFAULT_OUTPUTTER.output((Comment)node, sw);                }                else if(node instanceof CDATA)                {                    DEFAULT_OUTPUTTER.output((CDATA)node, sw);                }                else if(node instanceof DocType)                {                    DEFAULT_OUTPUTTER.output((DocType)node, sw);                }                else if(node instanceof EntityRef)                {                    DEFAULT_OUTPUTTER.output((EntityRef)node, sw);                }                else                {                    throw new IllegalArgumentException(                        "Cannot process a " +                        (node == null                         ? "null node"                         : "node of class " + node.getClass().getName()));                }            }        }        catch(IOException e)        {            // Cannot happen as we work with a StringWriter in memory            throw new Error();        }        return sw.toString();    }    /**     * Returns a NodeList that contains the same nodes as this node list.     * @return A clone of this list.     * @throws CloneNotSupportedException if the contained list's class does     * not have an accessible no-arg constructor.     */    public Object clone()        throws CloneNotSupportedException    {        NodeList clonedList = (NodeList)super.clone();        clonedList.cloneNodes();        return clonedList;    }    private void cloneNodes()        throws CloneNotSupportedException    {        Class listClass = nodes.getClass();        try        {            List clonedNodes = (List)listClass.newInstance();            clonedNodes.addAll(nodes);            nodes = clonedNodes;        }        catch(IllegalAccessException e)        {            throw new CloneNotSupportedException("Cannot clone NodeList since"            + " there is no accessible no-arg constructor on class "            + listClass.getName());        }        catch(InstantiationException e)        {            // Cannot happen as listClass represents a concrete, non-primitive,            // non-array, non-void class - there's an instance of it in "nodes"            // which proves these assumptions.            throw new Error();        }    }    /**     * Returns the hash code of the contained list.     * @return The hashcode of the list.     */    public int hashCode()    {        return nodes.hashCode();    }    /**     * Tests for equality with another object.     * @param o the object to test for equality     * @return true if the other object is also a NodeList and their contained     * {@link List} objects evaluate as equals.     */    public boolean equals(Object o)    {        return o instanceof NodeList            ? ((NodeList)o).nodes.equals(nodes)            : false;    }    /**     * Applies an XPath expression to the node list and returns the resulting     * node list. In order for this method to work, your application must have     * access to <a href="http://code.werken.com">werken.xpath</a> library     * classes. The implementation does cache the parsed format of XPath     * expressions in a weak hash map, keyed by the string representation of     * the XPath expression. As the string object passed as the argument is     * usually kept in the parsed template, this ensures that each XPath     * expression is parsed only once during the lifetime of the template that     * first invoked it.     * @param xpathString the XPath expression you wish to apply     * @return a NodeList representing the nodes that are the result of     * application of the XPath to the current node list. It can be empty.     */    public NodeList selectNodes(String xpathString)    {        return new NodeList(XPathCache.getXPath(xpathString).applyTo(nodes), false);    }// List methods implemented hereafter    /**     * @see java.util.List#add(java.lang.Object)     */    public boolean add(Object o)    {        return nodes.add(o);    }    /**     * @see java.util.List#add(int, java.lang.Object)     */    public void add(int index, Object o)    {        nodes.add(index, o);    }    /**     * @see java.util.List#addAll(java.util.Collection)     */    public boolean addAll(Collection c)    {        return nodes.addAll(c);    }    /**     * @see java.util.List#addAll(int, java.util.Collection)     */    public boolean addAll(int index, Collection c)    {        return nodes.addAll(index, c);    }    /**     * @see java.util.List#clear()     */    public void clear()    {        nodes.clear();    }    /**     * @see java.util.List#contains(java.lang.Object)     */    public boolean contains(Object o)    {        return nodes.contains(o);    }    /**     * @see java.util.List#containsAll(java.util.Collection)     */    public boolean containsAll(Collection c)    {        return nodes.containsAll(c);    }    /**     * @see java.util.List#get(int)     */    public Object get(int index)    {        return nodes.get(index);    }    /**     * @see java.util.List#indexOf(java.lang.Object)     */    public int indexOf(Object o)    {        return nodes.indexOf(o);    }    /**     * @see java.util.List#isEmpty()     */    public boolean isEmpty()    {        return nodes.isEmpty();    }    /**     * @see java.util.List#iterator()     */    public Iterator iterator()    {        return nodes.iterator();    }    /**     * @see java.util.List#lastIndexOf(java.lang.Object)     */    public int lastIndexOf(Object o)    {        return nodes.lastIndexOf(o);    }    /**     * @see java.util.List#listIterator()     */    public ListIterator listIterator()    {        return nodes.listIterator();    }    /**     * @see java.util.List#listIterator(int)     */    public ListIterator listIterator(int index)    {        return nodes.listIterator(index);    }    /**     * @see java.util.List#remove(int)     */    public Object remove(int index)    {        return nodes.remove(index);    }    /**     * @see java.util.List#remove(java.lang.Object)     */    public boolean remove(Object o)    {        return nodes.remove(o);    }    /**     * @see java.util.List#removeAll(java.util.Collection)     */    public boolean removeAll(Collection c)    {        return nodes.removeAll(c);    }    /**     * @see java.util.List#retainAll(java.util.Collection)     */    public boolean retainAll(Collection c)    {        return nodes.retainAll(c);    }    /**     * @see java.util.List#set(int, java.lang.Object)     */    public Object set(int index, Object o)    {        return nodes.set(index, o);    }    /**     * @see java.util.List#size()     */    public int size()    {        return nodes.size();    }    /**     * @see java.util.List#subList(int, int)     */    public List subList(int fromIndex, int toIndex)    {        return new NodeList(nodes.subList(fromIndex, toIndex));    }    /**     * @see java.util.List#toArray()     */    public Object[] toArray()    {        return nodes.toArray();    }    /**     * @see java.util.List#toArray(java.lang.Object[])     */    public Object[] toArray(Object[] a)    {        return nodes.toArray(a);    }    /**     * A special subclass of XMLOutputter that will be used to output     * Attribute nodes. As a subclass of XMLOutputter it can use its protected     * method escapeAttributeEntities() to serialize the attribute     * appropriately.     */    private static final class AttributeXMLOutputter extends XMLOutputter    {        /**         * @param attribute         * @param out         * @throws IOException         */        public void output(Attribute attribute, Writer out)            throws IOException        {            out.write(" ");            out.write(attribute.getQualifiedName());            out.write("=");            out.write("\"");            out.write(escapeAttributeEntities(attribute.getValue()));            out.write("\"");        }    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     */import java.io.IOException;import java.io.StringWriter;import org.jdom.Element;import org.jdom.output.XMLOutputter;import org.jdom.output.Format;/** * This class extends XMLOutputter in order to provide * a way to walk an Element tree into a String. * * @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a> * @author <a href="mailto:rubys@us.ibm.com">Sam Ruby</a> * @version $Id: OutputWrapper.java 524478 2007-03-31 20:51:49Z wglass $ */public class OutputWrapper extends XMLOutputter{    /**     * Empty constructor     */    public OutputWrapper()    {    }    /**     * @param f     */    public OutputWrapper(Format f)    {        super(f);    }    /**     * This method walks an Element tree into a String. The cool     * thing about it is that it will strip off the first Element.     * For example, if you have:     * <p>     * &lt;td&gt; foo &lt;strong&gt;bar&lt;/strong&gt; ack &lt;/td&gt;     * </p>     * It will output     * <p>     *  foo &lt;strong&gt;bar&lt;/strong&gt; ack &lt;/td&gt;     * </p>     * @param element     * @param strip     * @return The output string.     */    public String outputString(Element element, boolean strip)    {        StringWriter buff = new StringWriter();        try        {            outputElementContent(element, buff);        }        catch (IOException e)        {        }        return buff.toString();    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     */import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import org.jdom.Element;/** * This class allows you to walk a tree of JDOM Element objects. * It first walks the tree itself starting at the Element passed * into allElements() and stores each node of the tree * in a Vector which allElements() returns as a result of its * execution. You can then use a #foreach in Velocity to walk * over the Vector and visit each Element node. However, you can * achieve the same effect by calling <code>element.selectNodes("//*")</code>. * * @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a> * @author <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a> * @version $Id: TreeWalker.java 524478 2007-03-31 20:51:49Z wglass $ */public class TreeWalker{    /**     * Empty constructor     */    public TreeWalker()    {        // Left blank    }    /**     * Creates a new Vector and walks the Element tree.     *     * @param e the starting Element node     * @return Vector a vector of Element nodes     */    public NodeList allElements(Element e)    {        ArrayList theElements = new ArrayList();        treeWalk (e, theElements);        return new NodeList(theElements, false);    }    /**     * A recursive method to walk the Element tree.     * @param Element the current Element     */    private final void treeWalk(Element e, Collection theElements )    {        for (Iterator i=e.getChildren().iterator(); i.hasNext(); )        {            Element child = (Element)i.next();            theElements.add(child);            treeWalk(child, theElements);        }    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     */import com.werken.xpath.XPath;import java.util.Map;import java.util.WeakHashMap;/** * Provides a cache for XPath expressions. Used by {@link NodeList} and * {@link AnakiaElement} to minimize XPath parsing in their * <code>selectNodes()</code> methods. * * @author <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a> * @version $Id: XPathCache.java 524478 2007-03-31 20:51:49Z wglass $ */class XPathCache{    // Cache of already parsed XPath expressions, keyed by String representations    // of the expression as passed to getXPath().    private static final Map XPATH_CACHE = new WeakHashMap();    private XPathCache()    {    }    /**     * Returns an XPath object representing the requested XPath expression.     * A cached object is returned if it already exists for the requested expression.     * @param xpathString the XPath expression to parse     * @return the XPath object that represents the parsed XPath expression.     */    static XPath getXPath(String xpathString)    {        XPath xpath = null;        synchronized(XPATH_CACHE)        {            xpath = (XPath)XPATH_CACHE.get(xpathString);            if(xpath == null)            {                xpath = new XPath(xpathString);                XPATH_CACHE.put(xpathString, xpath);            }        }        return xpath;    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License.     */import java.util.List;import org.jdom.Document;import org.jdom.Element;/** * This class adds an entrypoint into XPath functionality, * for Anakia. * <p> * All methods take a string XPath specification, along with * a context, and produces a resulting java.util.List. * <p> * The W3C XPath Specification (http://www.w3.org/TR/xpath) refers * to NodeSets repeatedly, but this implementation simply uses * java.util.List to hold all Nodes.  A 'Node' is any object in * a JDOM object tree, such as an org.jdom.Element, org.jdom.Document, * or org.jdom.Attribute. * <p> * To use it in Velocity, do this: * <p> * <pre> * #set $authors = $xpath.applyTo("document/author", $root) * #foreach ($author in $authors) *   $author.getValue() * #end * #set $chapterTitles = $xpath.applyTo("document/chapter/@title", $root) * #foreach ($title in $chapterTitles) *   $title.getValue() * #end * </pre> * <p> * In newer Anakia builds, this class is obsoleted in favor of calling * <code>selectNodes()</code> on the element directly: * <pre> * #set $authors = $root.selectNodes("document/author") * #foreach ($author in $authors) *   $author.getValue() * #end * #set $chapterTitles = $root.selectNodes("document/chapter/@title") * #foreach ($title in $chapterTitles) *   $title.getValue() * #end * </pre> * <p> * * @author <a href="mailto:bob@werken.com">bob mcwhirter</a> * @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a> * @author <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a> * @version $Id: XPathTool.java 524478 2007-03-31 20:51:49Z wglass $ */public class XPathTool{    /**     * Constructor does nothing, as this is mostly     * just objectified static methods     */    public XPathTool()    {        //        RuntimeSingleton.info("XPathTool::XPathTool()");        // intentionally left blank    }    /**     * Apply an XPath to a JDOM Document     *     * @param xpathSpec The XPath to apply     * @param doc The Document context     *     * @return A list of selected nodes     */    public NodeList applyTo(String xpathSpec,                        Document doc)    {        //RuntimeSingleton.info("XPathTool::applyTo(String, Document)");        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( doc ), false);    }    /**     * Apply an XPath to a JDOM Element     *     * @param xpathSpec The XPath to apply     * @param elem The Element context     *     * @return A list of selected nodes     */    public NodeList applyTo(String xpathSpec,                        Element elem)    {        //RuntimeSingleton.info("XPathTool::applyTo(String, Element)");        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( elem ), false);    }    /**     * Apply an XPath to a nodeset     *     * @param xpathSpec The XPath to apply     * @param nodeSet The nodeset context     *     * @return A list of selected nodes     */    public NodeList applyTo(String xpathSpec,                        List nodeSet)    {        //RuntimeSingleton.info("XPathTool::applyTo(String, List)");        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( nodeSet ), false);    }}
Anakiapackage org.apache.anakia;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */import java.io.File;import java.util.Collections;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.anakia.test.Log;import org.apache.anakia.test.TestUtil;/** * This is a test case for Anakia. Right now, it simply will compare * two index.html files together. These are produced as a result of * first running Anakia and then running this test. * * @version $Id: AnakiaTestCase.java 965612 2010-07-19 20:09:41Z apetrelli $ */public class AnakiaTestCase extends TestCase{    public static final String TEST_DIR_KEY = "test.compare.dir";    public static final String RESULTS_DIR_KEY = "test.results.dir";    private File resultsDir;    private File compareDir;    private File testDir;    private static final Log log = new Log();    /**     * Creates a new instance.     *     */    public AnakiaTestCase(final String name)    {        super(name);    }    public static Test suite()    {        return new TestSuite(AnakiaTestCase.class);    }    /**     * Find the directories.     */    public void setUp()    {        resultsDir = new File(System.getProperty(RESULTS_DIR_KEY), "anakia");        testDir = new File(System.getProperty(TEST_DIR_KEY));        compareDir = new File (testDir, "anakia/compare");    }    /**     * Runs the test. This is empty on purpose because the     * code to do the Anakia output is in the .xml file that runs     * this test.     */    public void testAnakia()            throws Exception    {        TestUtil.assureResultsDirectoryExists(resultsDir);        Anakia anakia = new Anakia();        File baseDir = new File(testDir, "anakia/xdocs");        anakia.setBaseDir(baseDir);        anakia.setDestDir(resultsDir);        anakia.setProjectFile(new File(baseDir, "stylesheets/project.xml"));        anakia.setPropertiesFile(new File(testDir, "anakia/velocity.properties"));        anakia.setStyleTemplate("site_contexts.vsl");        anakia.setTemplatePath(new File(baseDir, "stylesheets"));        anakia.setCheckLastModified(false);        anakia.setExtension(".html");        anakia.setLog(log);        anakia.setFiles(Collections.singletonList("index.xml"));        anakia.execute();        // compare standard run        if (!TestUtil.compareFiles(                new File(compareDir, "index.html").toString(),                new File(resultsDir, "index.html").toString()))        {            fail("Anakia results are incorrect");        }        else        {            log.info ("Passed (standard)!");        }    }    /**     * Runs the test. This is empty on purpose because the     * code to do the Anakia output is in the .xml file that runs     * this test.     */    public void testAnakiaCustomContextResults ()            throws Exception    {        TestUtil.assureResultsDirectoryExists(resultsDir);        Anakia anakia = new Anakia();        File baseDir = new File(testDir, "anakia/xdocs");        anakia.setBaseDir(baseDir);        anakia.setDestDir(resultsDir);        anakia.setProjectFile(new File(baseDir, "stylesheets/project.xml"));        anakia.setStyleTemplate("site_contexts.vsl");        anakia.setTemplatePath(new File(baseDir, "stylesheets"));        anakia.setCheckLastModified(false);        anakia.setExtension(".context.html");        anakia.setLog(log);        anakia.setFiles(Collections.singletonList("index.xml"));        Anakia.Context context = anakia.new Context();        context.setName("customContext");        context.setFile("stylesheets/customContext.xml");        anakia.setContexts(Collections.singletonList(context));        anakia.execute();        // compare with custom context        if (!TestUtil.compareFiles(                new File(compareDir, "index.context.html").toString(),                new File(resultsDir, "index.context.html").toString()))        {        fail("Anakia results are incorrect");        }        else        {            log.info ("Passed (custom context)!");        }    }}
Anakiapackage org.apache.anakia.test;import org.apache.anakia.AnakiaLog;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. *//*** Simple class to log messages when running tests** @version $Id: Log.java 534873 2007-05-03 14:08:19Z henning $*/public class Log        implements AnakiaLog{    public Log ()    {    }    /**     * Output a message;     * @param message     */    public void log(final String message, final int level)    {         System.out.println("(Level " + level + ") " + message);    }    public void info(final String message)    {        System.out.println(message);    }    public void error(final String message)    {        System.err.println(message);    }}
Anakiapackage org.apache.anakia.test;/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */import java.io.File;/** * Miscellaneous routines to help with testing * * @version $Id: TestUtil.java 534873 2007-05-03 14:08:19Z henning $ */public class TestUtil{    private static final Log log = new Log();    /**     * Do not instantiate.     */    private TestUtil()    {    }    /**     * Assures that the results directory exists.  If the results directory     * cannot be created, fails the test.     */    public static void assureResultsDirectoryExists (final File resultsDirectory)    {        if (!resultsDirectory.exists())        {            log.info("Template results directory does not exist");            if (resultsDirectory.mkdirs())            {                log.info("Created template results directory");            }            else            {                throw new RuntimeException("Unable to create template results directory");            }        }    }    /**     * Normalizes lines to account for platform differences.  Macs use     * a single \r, DOS derived operating systems use \r\n, and Unix     * uses \n.  Replace each with a single \n.     *     * @author <a href="mailto:rubys@us.ibm.com">Sam Ruby</a>     * @return source with all line terminations changed to Unix style     */    public static String normalizeNewlines (String source)    {        return source.replaceAll("\r[\r]?[\n]","\n");    }    /**     * Returns whether the processed template matches the     * content of the provided comparison file.     *     * @return Whether the output matches the contents     *         of the comparison file.     *     * @exception Exception Test failure condition.     */    public static boolean compareFiles(String compareFileName, String resultsFileName)        throws Exception    {        log.info("Comparing result file '" + resultsFileName + "' with compare file '" + compareFileName + "'");        String resultText = org.apache.velocity.util.StringUtils.fileContentsToString(resultsFileName);        return compareTextWithFile(resultText, compareFileName);    }    /**     * Returns whether the processed template matches the     * content of the provided comparison file.     *     * @return Whether the output matches the contents     *         of the comparison file.     *     * @exception Exception Test failure condition.     */    public static boolean compareTextWithFile(String resultText, String compareFileName)        throws Exception    {        String compareText = org.apache.velocity.util.StringUtils.fileContentsToString(compareFileName);        /*         *  normalize each wrt newline         */        String normalizedResultText = normalizeNewlines(resultText);        String normalizedCompareText = normalizeNewlines(compareText);        return normalizedResultText.equals( normalizedCompareText );    }}
