Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.util.DOMElementWriter;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.XMLFragment;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Base class for NAntTask and MSBuildTask. */public abstract class AbstractBuildTask extends Task {    /**     * The buildfile to invoke the build tool for.     */    private File buildFile;    /**     * The targets to execute.     */    private List targets = new ArrayList();    /**     * Properties to set.     */    private List properties = new ArrayList(1);    /**     * Nested build file fragment.     */    private XMLFragment buildSnippet;    /**     * The vm attribute - if given.     */    private String vm;    /**     * Empty constructor.     */    protected AbstractBuildTask() {    }    /**     * Sets the name of the build file.     */    public final void setBuildfile(File f) {        buildFile = f;    }    /**     * Adds a build file fragment.     */    public void addBuild(XMLFragment f) {        if (buildSnippet == null) {            buildSnippet = f;        } else {            throw new BuildException("You must not specify more than one "                                     + "build element");        }    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * A target.     */    public static class Target {        private String name;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }    }    /**     * A target to execute.     */    public final void addTarget(Target t) {        targets.add(t);    }    /**     * A property.     */    // XXX, could have reused Property or Environment.Variable     //      - not decided so far    public static class Property {        private String name;        private String value;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public void setValue(String value) {            this.value = value;        }        public String getValue() {            return value;        }    }    /**     * A target to execute.     */    public final void addProperty(Property t) {        properties.add(t);    }    /**     * Must return the executable.     *     * @return must not return null     */    protected abstract String getExecutable();    /**     * Must return buildfile argument(s).     *     * @param buildFile the absolute File for the buildfile or null if     * the user didn't specify a buildfile.     *     * @return must not return null     */    protected abstract String[] getBuildfileArguments(File buildFile);    /**     * Must return target argument(s).     *     * @return must not return null     */    protected abstract String[] getTargetArguments(List targets);    /**     * Must return property argument(s).     *     * @return must not return null     */    protected abstract String[] getPropertyArguments(List properties);    /**     * Turn the DoucmentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>Must throw a BuildException if the snippet can not be turned     * into a build file.</p>     */    protected abstract Element makeTree(DocumentFragment f);    /**     * Perform the build.     */    public void execute() {        if (buildFile != null && buildSnippet != null) {            throw new BuildException("You must not specify the build file"                                     + " attribute and a nested build at the"                                     + " same time");        }        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      getExecutable(), null);        String[] args = getPropertyArguments(properties);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        args = getTargetArguments(targets);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        File generatedFile = null;        if (buildSnippet != null) {            try {                generatedFile = getBuildFile();            } catch (IOException e) {                throw new BuildException(e);            }            args = getBuildfileArguments(generatedFile);        } else {            args = getBuildfileArguments(buildFile);        }                for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        try {            exec.execute();        } finally {            if (generatedFile != null) {                generatedFile.delete();            }        }    }    private File getBuildFile() throws IOException {        File f = null;        if (buildSnippet != null) {            Element e = makeTree(buildSnippet.getFragment());            f = FileUtils.newFileUtils().createTempFile("build", ".xml", null);            f.deleteOnExit();            FileOutputStream out = null;            try {                out = new FileOutputStream(f);                (new DOMElementWriter()).write(e, out);            } finally {                if (out != null) {                    out.close();                }            }        }        return f;    }}
Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.taskdefs.ExecTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.Environment;/** * Specialized <exec> that knows how to deal with Mono vs. Microsoft's * VM - and maybe Rotor at some point. */public class DotNetExecTask extends ExecTask {    /**     * "Magic" VM argument for Microsoft's VM.     */    private static final String MS_VM = "microsoft";    /**     * The user supplied executable attribute.     */    private String executable;    /**     * The .NET VM to use.     *     * <p>Defaults to Microsoft's on Windows and mono on any other     * platform.</p>     */    private String vm = Os.isFamily("windows") ? MS_VM : "mono";    /**     * Empty Constructor.     */    public DotNetExecTask() {        super();    }    /**     * Set the name of the executable program.     * @param value the name of the executable program     */    public void setExecutable(String value) {        this.executable = value;    }    /**     * Set the name of the executable for the virtual machine or the     * magic name "microsoft" which implies that we can invoke the     * executable directly.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Do the work.     *     * @throws BuildException if executable is empty or &lt;exec&gt;     * throws an exception.     */    public void execute() throws BuildException {        if (executable == null) {            throw new BuildException("The executable attribute is required");        }        setupCommandline();        super.execute();    }    /**     * If the inherited Commandline doesn't know about the executable     * yet, set it and deal with the vm attribute.     *     * <p>The inherited Commandline may know the executable already if     * this task instance is getting reused.</p>     */    protected void setupCommandline() {        if (cmdl.getExecutable() == null) {            if (vm.equals(MS_VM)) {                // can invoke executable directly                super.setExecutable(executable);            } else {                boolean b = getResolveExecutable();                // Mono wants the absolte path of the assembly                setResolveExecutable(b || isMono(vm));                super.setExecutable(vm);                cmdl.createArgument(true)                    .setValue(resolveExecutable(executable, isMono(vm)));                setResolveExecutable(b);            }        }    }    /**     * Whether the given vm looks like the Mono executable.     */    protected final static boolean isMono(String vm) {        return "mono".equals(vm) || "mint".equals(vm);    }    /**     * Creates an instance of this task based on a different tasks settings.     */    public static DotNetExecTask getTask(Task t, String vm,                                          String executable,                                         Environment env) {        DotNetExecTask exec = new DotNetExecTask();        if (vm != null) {            exec.setVm(vm);        }        exec.setProject(t.getProject());        exec.setExecutable(executable);        exec.setTaskName(t.getTaskName());        if (env != null) {            String[] environment = env.getVariables();            if (environment != null) {                for (int i = 0; i < environment.length; i++) {                    int idx = environment[i].indexOf("=");                    Environment.Variable v = new Environment.Variable();                    v.setKey(environment[i].substring(0, idx));                    v.setValue(environment[i].substring(idx + 1));                    exec.addEnv(v);                }            }        }                return exec;    }}
Apache .NET Ant Library/* * Copyright 2003-2006 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.apache.tools.ant.BuildException;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a MSBuild build process. */public class MSBuildTask extends AbstractBuildTask {    private static final String TARGET = "generated-by-ant";    public MSBuildTask() {        super();    }    protected String getExecutable() {        return "MSBuild.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        if (targets.size() > 0) {            StringBuffer sb = new StringBuffer("/target:");            Iterator iter = targets.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Target t =                     (AbstractBuildTask.Target) iter.next();                if (!first) {                    sb.append(";");                } else {                    first = false;                }                sb.append(t.getName());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    protected String[] getPropertyArguments(List properties) {        if (properties.size() > 0) {            StringBuffer sb = new StringBuffer("/property:");            Iterator iter = properties.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Property p =                     (AbstractBuildTask.Property) iter.next();                if (!first) {                    sb.append(";");                } else {                    first = false;                }                sb.append(p.getName()).append("=").append(p.getValue());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <Project> child, return that.     * Otherwise if we have only <Task> children, wrap them into a     * <Target> which in turn gets wrapped into a <Project>.     * Otherwise, fail.</p>     */    protected Element makeTree(DocumentFragment f) {        throw new BuildException("MSBuild requires build files to have"                                 + " a certain default namespace, which"                                 + " cannot be achieved with Ant prior to"                                 + " Ant 1.7.");    }}
Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a NAnt build process. */public class NAntTask extends AbstractBuildTask {    public NAntTask() {        super();    }    protected String getExecutable() {        return "NAnt.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                "-buildfile:" + buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        ArrayList al = new ArrayList(targets.size());        Iterator iter = targets.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Target t = (AbstractBuildTask.Target) iter.next();            al.add(t.getName());        }        return (String[]) al.toArray(new String[al.size()]);    }    protected String[] getPropertyArguments(List properties) {        ArrayList al = new ArrayList(properties.size());        Iterator iter = properties.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                 (AbstractBuildTask.Property) iter.next();            al.add("-D:" + p.getName() + "=" + p.getValue());        }        return (String[]) al.toArray(new String[al.size()]);    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <project> child, return that.     * Otherwise assume that this is a valid build file snippet that     * just needs an empty project wrapped around it.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals("project")) {            return (Element) nl.item(0);        } else {            Element e = f.getOwnerDocument().createElement("project");            e.appendChild(f);            return e;        }    }}
Apache .NET Ant Library/* * Copyright 2004-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Environment;import org.apache.tools.ant.types.RedirectorElement;import java.io.File;import java.util.ArrayList;import java.util.Iterator;/** * Task to run the NUnit Console test runner. * * @see http://www.nunit.org/ */public class NUnitTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * Test assemblies.     */    private ArrayList testAssemblies = new ArrayList();    /**     * The /config argument.     */    private File configFile;    /**     * The /output argument.     */    private File out;    /**     * The /err argument.     */    private File err;    /**     * The /xml argument.     */    private File xmlOut;    /**     * The /transform argument.     */    private File transform;    /**     * The /thread argument.     */    private boolean thread = false;    /**     * The /fixture argument.     */    private String fixture;    /**     * Categories to include.     */    private ArrayList includes = new ArrayList();    /**     * Categories to exclude.     */    private ArrayList excludes = new ArrayList();    /**     * The /noshadow argument.     */    private boolean noshadow = false;    /**     * The /labels argument.     */    private boolean labels = false;    /**     * Redirects everything that NUnit wants to send to the console.     */    private RedirectorElement redirectorElement;    /**     * Whether a failure should stop the build.     */    private boolean failOnError = false;    /**     * Support for nested environment variables.     */    private Environment env = new Environment();    public NUnitTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the config file.     */    public void setConfig(File c) {        configFile = c;    }    /**     * The /output argument.     */    public void setOut(File out) {        this.out = out;    }    /**     * The /err argument.     */    public void setError(File err) {        this.err = err;    }    /**     * The /xml argument.     */    public void setXmlOut(File out) {        this.xmlOut = out;    }    /**     * The /transform argument.     */    public void setTransform(File transform) {        this.transform = transform;    }    /**     * The /thread argument.     */    public void setThread(boolean thread) {        this.thread = thread;    }    /**     * The /fixture argument.     */    public void setFixture(String fixture) {        this.fixture = fixture;    }    /**     * The /noshadow argument.     */    public void setNoshadow(boolean noshadow) {        this.noshadow = noshadow;    }    /**     * The /labels argument.     */    public void setLabels(boolean labels) {        this.labels = labels;    }    /**     * Whether a failure should stop the build.     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Adds a test assembly by name.     */    public void addTestAssembly(NamedElement a) {        testAssemblies.add(a);    }    /**     * Adds a category to the include list.     */    public void addInclude(NamedElement a) {        includes.add(a);    }    /**     * Adds a category to the exclude list.     */    public void addExclude(NamedElement a) {        excludes.add(a);    }    /**     * Add an environment variable to the launched process.     *     * @param var new environment variable     */    public void addEnv(Environment.Variable var) {        env.addVariable(var);    }    /**     * Add a <code>RedirectorElement</code> to this task.     *     * <p>This does not use the <code>out</code> and     * <code>error</code> attributes, it only captures NUnits output     * that has not been redirected by those attributes.</p>     */    public void addConfiguredRedirector(RedirectorElement redirectorElement) {        if (this.redirectorElement != null) {            throw new BuildException("cannot have > 1 nested <redirector>s");        } else {            this.redirectorElement = redirectorElement;        }    }    public void execute() {        if (testAssemblies.size() == 0) {            throw new BuildException("You must specify at least one test "                                     + "assembly.");        }                DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      "nunit-console.exe",                                                     env);        Iterator iter = testAssemblies.iterator();        while (iter.hasNext()) {            NamedElement a = (NamedElement) iter.next();            exec.createArg().setValue(a.getName());        }        if (configFile != null) {            exec.createArg().setValue("/config="                                       + configFile.getAbsolutePath());        }        exec.createArg().setValue("/nologo");        if (out != null) {            exec.createArg().setValue("/output=" + out.getAbsolutePath());        }        if (err != null) {            exec.createArg().setValue("/err=" + err.getAbsolutePath());        }        if (xmlOut != null) {            exec.createArg().setValue("/xml=" + xmlOut.getAbsolutePath());        }        if (transform != null) {            exec.createArg().setValue("/transform="                                       + transform.getAbsolutePath());        }        if (thread) {            exec.createArg().setValue("/thread");        }        if (noshadow) {            exec.createArg().setValue("/noshadow");        }        if (labels) {            exec.createArg().setValue("/labels");        }        if (fixture != null) {            exec.createArg().setValue("/fixture=" + fixture);        }                if (includes.size() > 0) {            StringBuffer sb = new StringBuffer("/include=");            iter = includes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (excludes.size() > 0) {            StringBuffer sb = new StringBuffer("/exclude=");            iter = excludes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (redirectorElement != null) {            exec.addConfiguredRedirector(redirectorElement);        }        exec.setFailonerror(failOnError);        exec.execute();    }    public static class NamedElement {        private String name;        public String getName() {return name;}        public void setName(String s) {name = s;}    }}
Apache .NET Ant Library/* * Copyright 2004-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;import java.io.File;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * Task to run the WiX utility to create MSI files from an XML description. * * @see http://sf.net/projects/wix */public class WixTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source files.     */    private ArrayList sources = new ArrayList();    /**     * Additional source files (include files in the case of candle,     * or media/files/whatever in the case of light).     */    private ArrayList moreSources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * What to do.     */    private Mode mode;    public WixTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>candle</code> may include more files than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * A set of source files.     */    public void addSources(FileSet fs) {        sources.add(fs);    }    /**     * A set of additional source files (include files in the case of     * candle, or media/files/whatever in the case of light).     *     * <p>Unlike the files specified as sources, these will not be     * passed on the command line, they only help Ant to determine     * whether the target is out-of-date.</p>     */    public void addMoreSources(FileSet fs) {        moreSources.add(fs);    }    public void execute() {        if (source == null && sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        }        String m = Mode.BOTH;        if (mode != null) {            m = mode.getValue();        }        if (target == null && !m.equals(Mode.CANDLE)) {            throw new BuildException("You must specify the target if you want"                                     + " to run light.");        }        List lightSources = new ArrayList();        if (!m.equals(Mode.LIGHT)) {            doCandle(lightSources);        } else {            if (source != null) {                lightSources.add(source);            }            if (sources.size() > 0) {                lightSources.addAll(grabFiles(sources));            }        }        List moreLightSources = new ArrayList();        if (moreSources.size() > 0) {            moreLightSources = grabFiles(moreSources);        }        if (!m.equals(Mode.CANDLE)) {            doLight(lightSources, moreLightSources);        }    }    /**     * Invoke candle on all sources that are newer than their targets.     *     * @param lightSources list that will be filled with File objects     * pointing to the generated object files.     */    private void doCandle(List lightSources) {        List s = new ArrayList();        if (source != null) {            s.add(source);        }        if (sources != null) {            s.addAll(grabFiles(sources));        }        List ms = new ArrayList();        if (moreSources != null) {            ms.addAll(grabFiles(moreSources));        }        Iterator iter = s.iterator();        List toProcess = new ArrayList();        while (iter.hasNext()) {            File thisSource = (File) iter.next();            File t = target;            if (t == null) {                t = getTarget(thisSource);            }            if (isOutOfDate(t, thisSource, ms)) {                toProcess.add(thisSource);                lightSources.add(t);            }        }        if (toProcess.size() != 0) {            runCandle(toProcess);        }    }    /**     * Invoke light on all sources that are newer than their targets.     */    private void doLight(List lightSources, List moreLightSources) {        List tmp = new ArrayList(lightSources);        tmp.addAll(moreLightSources);        if (isOutOfDate(target, tmp)) {            runLight(lightSources);        }    }    /**     * Run candle passing all files in list on the command line.     */    private void runCandle(List s) {        run("candle.exe", s, null);    }    /**     * Run light passing all files in list on the command line.     */    private void runLight(List s) {        run("light.exe", s, target);    }    /**     * Runs the specified command passing list on the command line an     * potentially adding an /out parameter.     */    private void run(String executable, List s, File target) {        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      executable, null);        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue(f.getAbsolutePath());        }        if (target != null) {            exec.createArg().setValue("/out");            exec.createArg().setValue(target.getAbsolutePath());        }                exec.execute();    }    /**     * Is t older than s or any of the files in list?     */    private boolean isOutOfDate(File t, File s, List l) {        return t.lastModified() < s.lastModified() || isOutOfDate(t, l);    }    /**     * Is t older than any of the files in list?     */    private boolean isOutOfDate(File t, List l) {        Iterator iter = l.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            if (t.lastModified() < f.lastModified()) {                return true;            }        }        return false;    }    /**     * Turn the fileset collection into a list of Files.     */    private List grabFiles(List s) {        List r = new ArrayList();        Iterator iter = s.iterator();        while (iter.hasNext()) {            FileSet fs = (FileSet) iter.next();            DirectoryScanner ds = fs.getDirectoryScanner(getProject());            String[] f = ds.getIncludedFiles();            File base = fs.getDir(getProject());            for (int i = 0; i < f.length; i++) {                r.add(new File(base, f[i]));            }        }        return r;    }    /**     * Generates the name of a candle target from the source file.     *     * <p>Simply chops of the extension and adds .wixobj.</p>     */    private File getTarget(File s) {        String name = s.getAbsolutePath();        int dot = name.lastIndexOf(".");        if (dot > -1) {            return new File(name.substring(0, dot) + ".wixobj");        } else {            return new File(name + ".wixobj");        }    }    public static class Mode extends EnumeratedAttribute {        private final static String CANDLE = "candle";        private final static String LIGHT = "light";        private final static String BOTH = "both";        public Mode() {            super();        }        public String[] getValues() {            return new String[] {CANDLE, LIGHT, BOTH,};        }    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.util;import org.w3c.dom.Document;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.Text;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DynamicConfiguratorNS;import org.apache.tools.ant.ProjectHelper;/** * Use this class as a nested element if you want to get a literal DOM * fragment of something nested into your task/type. * * <p>This is useful for tasks that want to deal with the "real" XML * from the build file instead of objects.</p> * * <p>Code heavily influenced by code written by Dominique Devienne.</p> * * @since Ant 1.7 */public class XMLFragment implements DynamicConfiguratorNS {    private Document doc;    private DocumentFragment fragment;    public XMLFragment() {        doc = JAXPUtils.getDocumentBuilder().newDocument();        fragment = doc.createDocumentFragment();    }    /**     * Return the DocumentFragment that corresponds to the nested     * structure.     */    public DocumentFragment getFragment() {        return fragment;    }    /**     * Add nested text.     */    public void addText(String s) {        addText(fragment, s);    }    /**     * No attributes for the wrapping element.     */    public void setDynamicAttribute(String uri, String name, String qName, String value)        throws BuildException {        throw new BuildException("Attribute " + name + " is not supported.");    }    /**     * Creates a nested element.     */    public Object createDynamicElement(String uri, String name, String qName) {        Element e = doc.createElementNS(uri, qName);        fragment.appendChild(e);        return new Child(e);    }    private void addText(Node n, String s) {        if (s != null && !s.trim().equals("")) {            Text t = doc.createTextNode(s);            n.appendChild(t);        }    }    public class Child implements DynamicConfiguratorNS {        private Element e;        Child(Element e) {            this.e = e;        }        /**         * Add nested text.         */        public void addText(String s) {            XMLFragment.this.addText(e, s);        }        /**         * Sets the attribute         */        public void setDynamicAttribute(            String uri, String name, String qName, String value) {            if (uri.equals("")) {                e.setAttribute(name, value);            } else {                e.setAttributeNS(uri, qName, value);            }        }        /**         * Creates a nested element.         */        public Object createDynamicElement(String uri, String name, String qName) {            Element e2 = null;            if (uri.equals("")) {                e2 = doc.createElement(name);            } else {                e2 = doc.createElementNS(uri, qName);            }            e.appendChild(e2);            return new Child(e2);        }    }}
Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the DotNetExecTask task, based off Ant's DotnetTest. * */public class DotNetExecTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public DotNetExecTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "dotnetexec.xml");    }    /**     * The teardown method for JUnit     */    public void tearDown() {        executeTarget("teardown");    }    /**     * A unit test for JUnit     */    public void testCSC() throws Exception {        executeTarget("testCSC");    }}
Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the MSBuildTask task. */public class MSBuildTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public MSBuildTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "msbuild.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }}
Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the NAntTask task. */public class NAntTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public NAntTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "nant.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }    public void testNestedTask() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-task", "foo is bar");        }    }}
Apache .NET Ant Library/* * Copyright 2004-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the NUnitTask task. */public class NUnitTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public NUnitTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "nunit.xml");    }    /**     * The teardown method for JUnit     */    public void tearDown() {        executeTarget("teardown");    }    public void testNoAssembly() {        expectSpecificBuildException("no-assembly", "no assembly",                                      "You must specify at least one test assembly.");    }    public void testPass() {        if (getProject().getProperty("nunit.found") != null) {            expectLogContaining("passing-test",                                 "Tests run: 1, Failures: 0, Not run: 0");        }    }    public void testFail() {        if (getProject().getProperty("nunit.found") != null) {            expectLogContaining("failing-test",                                 "Tests run: 1, Failures: 1, Not run: 0");        }    }    public void testFailOnFail() {        if (getProject().getProperty("nunit.found") != null) {            expectBuildException("failing-test-with-fail", "test should fail");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.taskdefs.Execute;import org.apache.tools.ant.taskdefs.ExecTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.Environment;/** * Specialized <exec> that knows how to deal with Mono vs. Microsoft's * VM - and maybe Rotor at some point. */public class DotNetExecTask extends ExecTask {    /**     * "Magic" VM argument for Microsoft's VM.     */    private static final String MS_VM = "microsoft";    /**     * The user supplied executable attribute.     */    private String executable;    /**     * The .NET VM to use.     *     * <p>Defaults to Microsoft's on Windows and mono on any other     * platform.</p>     */    private String vm = Os.isFamily("windows") ? MS_VM : "mono";    /**     * Name of property to set if execution fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Empty Constructor.     */    public DotNetExecTask() {        super();    }    /**     * Set the name of the executable program.     * @param value the name of the executable program     */    public void setExecutable(String value) {        this.executable = value;    }    /**     * Set the name of the executable for the virtual machine or the     * magic name "microsoft" which implies that we can invoke the     * executable directly.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the property to set if execution fails.     *     * <p>Not exposed as an attribute of the task, it just supports     * tasks like &lt;nunit&gt; which delegate to instances of this     * class.</p>     *     * @since 1.0 Beta 2     */    public void internalSetErrorProperty(String name) {        errorProperty = name;    }    /**     * Do the work.     *     * @throws BuildException if executable is empty or &lt;exec&gt;     * throws an exception.     */    public void execute() throws BuildException {        if (executable == null) {            throw new BuildException("The executable attribute is required");        }        setupCommandline();        super.execute();    }    /**     * Overridden to support the error-property handling required by     * NUnit, NAnt and friends.     *     * @since 1.0 Beta 2     */    protected void maybeSetResultPropertyValue(int result) {        if (errorProperty != null && Execute.isFailure(result)) {            getProject().setNewProperty(errorProperty, String.valueOf(true));        }        super.maybeSetResultPropertyValue(result);    }    /**     * If the inherited Commandline doesn't know about the executable     * yet, set it and deal with the vm attribute.     *     * <p>The inherited Commandline may know the executable already if     * this task instance is getting reused.</p>     */    protected void setupCommandline() {        if (cmdl.getExecutable() == null) {            if (vm.equals(MS_VM)) {                // can invoke executable directly                super.setExecutable(executable);            } else {                boolean b = getResolveExecutable();                // Mono wants the absolte path of the assembly                setResolveExecutable(b || isMono(vm));                super.setExecutable(vm);                cmdl.createArgument(true)                    .setValue(resolveExecutable(executable, isMono(vm)));                setResolveExecutable(b);            }        }    }    /**     * Whether the given vm looks like the Mono executable.     */    protected final static boolean isMono(String vm) {        return "mono".equals(vm) || "mint".equals(vm);    }    /**     * Creates an instance of this task based on a different tasks settings.     */    public static DotNetExecTask getTask(Task t, String vm,                                          String executable,                                         Environment env) {        DotNetExecTask exec = new DotNetExecTask();        if (vm != null) {            exec.setVm(vm);        }        exec.setProject(t.getProject());        exec.setExecutable(executable);        exec.setTaskName(t.getTaskName());        if (env != null) {            String[] environment = env.getVariables();            if (environment != null) {                for (int i = 0; i < environment.length; i++) {                    int idx = environment[i].indexOf("=");                    Environment.Variable v = new Environment.Variable();                    v.setKey(environment[i].substring(0, idx));                    v.setValue(environment[i].substring(idx + 1));                    exec.addEnv(v);                }            }        }                return exec;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Task to take a .NET or Mono -generated managed executable and turn it * into ILASM assembly code. Useful when converting imported typelibs into * assembler before patching and recompiling, as one has to do when doing * advanced typelib work. * <p> * As well as generating the named output file, the ildasm program * will also generate resource files <code>Icons.resources</code> * <code>Message.resources</code> and a .res file whose filename stub is derived * from the source in ways to obscure to determine. * There is no way to control whether or not these files are created, or where they are created * (they are created in the current directory; their names come from inside the * executable and may be those used by the original developer). This task * creates the resources in the directory specified by <code>resourceDir</code> if * set, else in the same directory as the <code>destFile</code>. * * <p> * This task requires the .NET SDK installed and ildasm on the path. * To disassemble using alternate CLR systems, set the executable attribute * to the name/path of the alternate implementation -one that must * support all the classic ildasm commands. * * <p> * Dependency logic: the task executes the command if the output file is missing * or older than the source file. It does not take into account changes * in the options of the task, or timestamp differences in resource files. * When the underlying ildasm executable fails for some reason, it leaves the * .il file in place with some error message. To prevent this from confusing * the dependency logic, the file specified by the <code>dest</code> * attribute is <i>always</i> deleted after an unsuccessful build. * @ant.task category="dotnet" */public class Ildasm extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();        /**     * source file (mandatory)     */    private File sourceFile;    /**     * dest file (mandatory)     */    private File destFile;    /**     * progress bar switch     */    private boolean progressBar = false;    /**     * what is our encoding     */    private String encoding;    /**     * /bytes flag for byte markup     */    private boolean bytes = false;    /**     * line numbers? /linenum     */    private boolean linenumbers = false;    /**     * /raweh flag for raw exception handling     */    private boolean rawExceptionHandling = false;    /**     * show the source; /source     */    private boolean showSource = false;    /**     * /quoteallnames to quote all names     */    private boolean quoteallnames = false;    /**     * /header for header information     */    private boolean header = false;    /**     * when false, sets the /noil attribute     * to suppress assembly info     */    private boolean assembler = true;    /**     * include metadata     * /tokens     */    private boolean metadata = false;    /**     * what visibility do we want.     *     */    private String visibility;    /**     * specific item to disassemble     */    private String item;    /**     * override for the executable     */    private String executable = "ildasm";    /**     *  name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    private File resourceDir;    /**     * Set the name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    public void setResourceDir(File resourceDir) {        this.resourceDir = resourceDir;    }    /**     * override the name of the executable (normally ildasm) or set     * its full path. Do not set a relative path, as the ugly hacks     * needed to create resource files in the dest directory     * force us to change to this directory before running the application.     * i.e use &lt;property location&gt to create an absolute path from a     * relative one before setting this value.     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     * Select the output encoding: ascii, utf8 or unicode     * @param encoding     */    public void setEncoding(EncodingTypes encoding) {        this.encoding = encoding.getValue();    }    /**     * enable (default) or disable assembly language in the output     * @param assembler     */    public void setAssembler(boolean assembler) {        this.assembler = assembler;    }    /**     * enable or disable (default) the original bytes as comments     * @param bytes     */    public void setBytes(boolean bytes) {        this.bytes = bytes;    }    /**     * the output file (required)     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * include header information; default false.     * @param header     */    public void setHeader(boolean header) {        this.header = header;    }    /**     * name a single item to decode; a class or a method     * e.g item="Myclass::method" or item="namespace1::namespace2::Myclass:method(void(int32))     * @param item     */    public void setItem(String item) {        this.item = item;    }    /**     * include line number information; default=false     * @param linenumbers     */    public void setLinenumbers(boolean linenumbers) {        this.linenumbers = linenumbers;    }    /**     * include metadata information     * @param metadata     */    public void setMetadata(boolean metadata) {        this.metadata = metadata;    }    /**     * show a graphical progress bar in a window during the process; off by default     * @param progressBar     */    public void setProgressBar(boolean progressBar) {        this.progressBar = progressBar;    }    /**     * quote all names.     * @param quoteallnames     */    public void setQuoteallnames(boolean quoteallnames) {        this.quoteallnames = quoteallnames;    }    /**     * enable raw exception handling (default = false)     * @param rawExceptionHandling     */    public void setRawExceptionHandling(boolean rawExceptionHandling) {        this.rawExceptionHandling = rawExceptionHandling;    }    /**     * include the source as comments (default=false)     */    public void setShowSource(boolean showSource) {        this.showSource = showSource;    }    /**     * the file to disassemble -required     * @param sourceFile     */    public void setSourceFile(File sourceFile) {        this.sourceFile = sourceFile;    }    /**     * alternate name for sourceFile     * @param sourceFile     */    public void setSrcFile(File sourceFile) {        setSourceFile(sourceFile);    }    /**     * This method sets the visibility options. It chooses one or more of the following, with + signs to     * concatenate them:     * <pre>     * pub : Public     * pri : Private     * fam : Family     * asm : Assembly     * faa : Family and Assembly     * foa : Family or Assembly     * psc : Private Scope     *</pre>     * e.g. visibility="pub+pri".     * Family means <code>protected</code> in C#;     * @param visibility     */    public void setVisibility(String visibility) {        this.visibility = visibility;    }    /**     *  verify that source and dest are ok     */    private void validate() {        if (sourceFile == null || !sourceFile.exists() || !sourceFile.isFile()) {            throw new BuildException("invalid source");        }        if (destFile == null || destFile.isDirectory()) {            throw new BuildException("invalid dest");        }        if (resourceDir != null                && (!resourceDir.exists() || !resourceDir.isDirectory())) {            throw new BuildException("invalid resource directory");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isDisassemblyNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = sourceFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The .il file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * do the work     * @throws BuildException     */    public void execute() throws BuildException {        validate();        if (!isDisassemblyNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ildasm", executable);        command.setFailOnError(true);        //fill in args        command.addArgument("/text");        command.addArgument("/out=" + destFile.toString());        if (!progressBar) {            command.addArgument("/nobar");        }        if (linenumbers) {            command.addArgument("/linenum");        }        if (showSource) {            command.addArgument("/source");        }        if (quoteallnames) {            command.addArgument("/quoteallnames");        }        if (header) {            command.addArgument("/header");        }        if (!assembler) {            command.addArgument("/noil");        }        if (metadata) {            command.addArgument("/tokens");        }        command.addArgument("/item:", item);        if (rawExceptionHandling) {            command.addArgument("/raweh");        }        command.addArgument(EncodingTypes.getEncodingOption(encoding));        if (bytes) {            command.addArgument("/bytes");        }        command.addArgument("/vis:", visibility);        //add the source file        command.addArgument(sourceFile.getAbsolutePath());        //determine directory: resourceDir if set,        //the dir of the destFile if not        File execDir = resourceDir;        if (execDir == null) {            execDir = destFile.getParentFile();        }        command.setDirectory(execDir);        //now run        try {            command.runCommand();        } catch (BuildException e) {            //forcibly delete the output file in case of trouble            if (destFile.exists()) {                log("Deleting destination file as it may be corrupt");                destFile.delete();            }            //then rethrow the exception            throw e;        }    }    /**     * encoding options; the default is ascii     */    public static class EncodingTypes extends EnumeratedAttribute {        public final static String UNICODE = "unicode";        public final static String UTF8 = "utf8";        public final static String ASCII = "ascii";        public String[] getValues() {            return new String[]{                ASCII,                UTF8,                UNICODE,            };        }        /**         * This method maps from an encoding enum to an encoding option.         * @param enumValue         * @return The encoding option indicated by the enum value.         */        public static String getEncodingOption(String enumValue) {            if (UNICODE.equals(enumValue)) {                return "/unicode";            }            if (UTF8.equals(enumValue)) {                return "/utf8";            }            return null;        }    }    /**     * visibility options for decoding     */    public static class VisibilityOptions extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "pub", //Public                "pri", //Private                "fam", //Family                "asm", //Assembly                "faa", //Family and Assembly                "foa", //Family or Assembly                "psc", //Private Scope            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.Task;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Import a COM type library into the .NET framework. * <p> * * This task is a wrapper to .NET's tlbimport; it imports a tlb file to a NET assembly * by generating a binary assembly (.dll) that contains all the binding * metadata. It uses date timestamps to minimise rebuilds. * <p> * Example * <pre> *     &lt;importtypelib *       srcfile="xerces.tlb" *       destfile="xerces.dll" *       namespace="Apache.Xerces"/&gt; * </pre> * @since Ant 1.6 * @ant.task category="dotnet" */public class ImportTypelib extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * input file; precedes options     */    private File srcFile;    /**     * /out:file     */    private File destFile;    /**     *  /namespace:[string]     */    private String namespace;    /**     * /sysarray     */    private boolean useSysArray = false;    /**     * /unsafe     */    private boolean unsafe = false;    /**     * extra commands?     */    private String extraOptions = null;    /**     * This method names the output file.     *     * This is an operation which is required to have been performed.     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * This method sets what namespace the typelib is to be in.     * This is an operation which is required to have been performed.     * @param namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * This method sets which is the source .tlb file.     * This is an operation which is required to have been performed.     * @param srcFile     */    public void setSrcFile(File srcFile) {        this.srcFile = srcFile;    }    /**     * do you want unsafe code.     * @param unsafe     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     * set this to map a COM SafeArray to the System.Array class     * @param useSysArray     */    public void setUseSysArray(boolean useSysArray) {        this.useSysArray = useSysArray;    }    /**     * set any extra options that are not yet supported by this task.     * @param extraOptions     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException("destination file must be specified");        }        if (destFile.isDirectory()) {            throw new BuildException(                    "destination file is a directory");        }        if (srcFile == null || !srcFile.exists()) {            throw new BuildException(                    "source file does not exist");        }        if (srcFile.isDirectory()) {            throw new BuildException(                    "source file is a directory");        }        if (namespace == null) {            throw new BuildException("No namespace");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isExecuteNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = srcFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The output file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * Create a typelib command     * @exception BuildException if something goes wrong with the build     */    public void execute() throws BuildException {        validate();        log("Importing typelib " + srcFile            + " to assembly " + destFile            + " in namespace " + namespace, Project.MSG_VERBOSE);        //rebuild unless the dest file is newer than the source file        if (!isExecuteNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ImportTypelib", "tlbimp");        command.setFailOnError(true);        command.addArgument(srcFile.toString());        //fill in args        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/namespace:", namespace);        if (useSysArray) {            command.addArgument("/sysarray");        }        if (unsafe) {            command.addArgument("/unsafe");        }        command.addArgument(extraOptions);        command.runCommand();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  The reference CD to listen to while editing this file is *  Underworld Everything, Everything *  variable naming policy from Fowler's refactoring book. */// place below the optional ant tasks packagepackage org.apache.ant.dotnet;// importsimport java.io.File;import java.io.IOException;import java.io.FileOutputStream;import java.io.PrintWriter;import java.io.BufferedOutputStream;import java.util.Hashtable;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.taskdefs.Execute;import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;import org.apache.tools.ant.taskdefs.LogStreamHandler;import org.apache.tools.ant.types.Commandline;/** *  This is a helper class to spawn net commands out. In its initial form it *  contains no .net specifics, just contains all the command line/exe *  construction stuff. However, it may be handy in future to have a means of *  setting the path to point to the dotnet bin directory; in which case the *  shared code should go in here. * *@version    0.5 */public class NetCommand {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     *  owner project     */    protected Task owner;    /**     *  executable     */    protected Execute executable;    /**     *  what is the command line     */    protected Commandline commandLine;    /**     *  title of the command     */    protected String title;    /**     *  actual program to invoke     */    protected String program;    /**     *  trace flag     */    protected boolean traceCommandLine = false;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     * the directory to execute the command in. When null, the current     * directory is used.     */    private File directory;    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    /**     * name of a temp file; may be null     */    private File temporaryCommandFile;    /**     * internal threshold for auto-switch     */    private int automaticResponseFileThreshold = 64;    /**     *  constructor     *     *@param  title        (for logging/errors)     *@param  owner        owner task     *@param  program      app we are to run     */    public NetCommand(Task owner, String title, String program) {        this.owner = owner;        this.title = title;        this.program = program;        commandLine = new Commandline();        commandLine.setExecutable(program);    }    /**     *  turn tracing on or off     *     *@param  b  trace flag     */    public void setTraceCommandLine(boolean b) {        traceCommandLine = b;    }    /**     *  set fail on error flag     *     *@param  b  fail flag -set to true to cause an exception to be raised if     *      the return value != 0     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailFailOnError() {        return failOnError;    }    /**     * set the directory to run from, if the default is inadequate     * @param directory     */    public void setDirectory(File directory) {        this.directory = directory;    }    /**     *  verbose text log     *     *@param  msg  string to add to log if verbose is defined for the build     */    protected void logVerbose(String msg) {        owner.getProject().log(msg, Project.MSG_VERBOSE);    }    /**     *  error text log     *     *@param  msg  message to display as an error     */    protected void logError(String msg) {        owner.getProject().log(msg, Project.MSG_ERR);    }    /**     *  add an argument to a command line; do nothing if the arg is null or     *  empty string     *     *@param  argument  The feature to be added to the Argument attribute     */    public void addArgument(String argument) {        if (argument != null && argument.length() != 0) {            commandLine.createArgument().setValue(argument);        }    }    /**     *  add an argument to a command line; do nothing if the arg is null or     *  empty string     *     *@param  arguments  The features to be added to the Argument attribute     */    public void addArguments(String[] arguments) {        if (arguments != null && arguments.length != 0) {            for (int i = 0; i < arguments.length; i++) {                addArgument(arguments[i]);            }        }    }    /**     *  concatenate two strings together and add them as a single argument,     *  but only if argument2 is non-null and non-zero length     *     *@param  argument1  The first argument     *@param  argument2  The second argument     */    public void addArgument(String argument1, String argument2) {        if (argument2 != null && argument2.length() != 0) {            commandLine.createArgument().setValue(argument1 + argument2);        }    }    /**     * getter     * @return response file state     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * set this to true to always use the response file     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     * getter for threshold     * @return 0 for disabled, or a threshold for enabling response files     */    public int getAutomaticResponseFileThreshold() {        return automaticResponseFileThreshold;    }    /**     * set threshold for automatically using response files -use 0 for off     * @param automaticResponseFileThreshold     */    public void setAutomaticResponseFileThreshold(int automaticResponseFileThreshold) {        this.automaticResponseFileThreshold = automaticResponseFileThreshold;    }    /**     *  set up the command sequence..     */    protected void prepareExecutor() {        // default directory to the project's base directory        if (owner == null) {            throw new RuntimeException("no owner");        }        if (owner.getProject() == null) {            throw new RuntimeException("Owner has no project");        }        File dir = owner.getProject().getBaseDir();        if (directory != null) {            dir = directory;        }        ExecuteStreamHandler handler = new LogStreamHandler(owner,                Project.MSG_INFO, Project.MSG_WARN);        executable = new Execute(handler, null);        executable.setAntRun(owner.getProject());        executable.setWorkingDirectory(dir);    }    /**     *  Run the command using the given Execute instance.     *     *@exception  BuildException  if something goes wrong and the     *      failOnError flag is true     */    public void runCommand()             throws BuildException {        prepareExecutor();        int err = -1;        // assume the worst        try {            if (traceCommandLine) {                owner.log("In directory " + executable.getWorkingDirectory());                owner.log(commandLine.describeCommand());            } else {                //in verbose mode we always log stuff                logVerbose("In directory " + executable.getWorkingDirectory());                logVerbose(commandLine.describeCommand());            }            setExecutableCommandLine();            err = executable.execute();            if (Execute.isFailure(err)) {                if (failOnError) {                    throw new BuildException(title + " returned: " + err, owner.getLocation());                } else {                    owner.log(title + "  Result: " + err, Project.MSG_ERR);                }            }        } catch (IOException e) {            throw new BuildException(title + " failed: " + e, e, owner.getLocation());        } finally {            if (temporaryCommandFile != null) {                temporaryCommandFile.delete();            }        }    }    /**     * set the executable command line     */    private void setExecutableCommandLine() {        String[] commands = commandLine.getCommandline();        //always trigger file mode if commands are big enough        if (automaticResponseFileThreshold > 0            && commands.length > automaticResponseFileThreshold) {            useResponseFile = true;        }        if (!useResponseFile || commands.length <= 1) {            //the simple action is to send the command line in as is            executable.setCommandline(commands);        } else {            //but for big operations, we save all the params to a temp file            //and set @tmpfile as the command -then we remember to delete the tempfile            //afterwards            FileOutputStream fos = null;            temporaryCommandFile = FILE_UTILS.createTempFile("cmd", ".txt", null);            owner.log("Using response file " + temporaryCommandFile, Project.MSG_VERBOSE);            try {                fos = new FileOutputStream(temporaryCommandFile);                PrintWriter out = new PrintWriter(new BufferedOutputStream(fos));                //start at 1 because element 0 is the executable name                for (int i = 1; i < commands.length; ++i) {                    out.println(commands[i]);                }                out.flush();                out.close();            } catch (IOException ex) {                throw new BuildException("saving command stream to " + temporaryCommandFile, ex);            }            String newCommandLine[] = new String[2];            newCommandLine[0] = commands[0];            newCommandLine[1] = "@" + temporaryCommandFile.getAbsolutePath();            logVerbose(Commandline.describeCommand(newCommandLine));            executable.setCommandline(newCommandLine);        }    }    /**     * scan through one fileset for files to include     * @param scanner     * @param filesToBuild     * @param outputTimestamp timestamp to compare against     * @return #of files out of date     * @todo: should FAT granularity be included here?     */    public int scanOneFileset(DirectoryScanner scanner, Hashtable filesToBuild,                                        long outputTimestamp) {        int filesOutOfDate = 0;        String[] dependencies = scanner.getIncludedFiles();        File base = scanner.getBasedir();        //add to the list        for (int i = 0; i < dependencies.length; i++) {            File targetFile = new File(base, dependencies[i]);            if (filesToBuild.get(targetFile) == null) {                filesToBuild.put(targetFile, targetFile);                if (targetFile.lastModified() > outputTimestamp) {                    filesOutOfDate++;                    owner.log(targetFile.toString() + " is out of date",                              Project.MSG_VERBOSE);                } else {                    owner.log(targetFile.toString(),                              Project.MSG_VERBOSE);                }            }        }        return filesOutOfDate;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Environment;import org.apache.tools.ant.types.RedirectorElement;import java.io.File;import java.util.ArrayList;import java.util.Iterator;/** * Task to run the NUnit Console test runner. * * @see http://www.nunit.org/ */public class NUnitTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * Test assemblies.     */    private ArrayList testAssemblies = new ArrayList();    /**     * The /config argument.     */    private File configFile;    /**     * The /output argument.     */    private File out;    /**     * The /err argument.     */    private File err;    /**     * The /xml argument.     */    private File xmlOut;    /**     * The /transform argument.     */    private File transform;    /**     * The /thread argument.     */    private boolean thread = false;    /**     * The /fixture argument.     */    private String fixture;    /**     * Categories to include.     */    private ArrayList includes = new ArrayList();    /**     * Categories to exclude.     */    private ArrayList excludes = new ArrayList();    /**     * The /noshadow argument.     */    private boolean noshadow = false;    /**     * The /labels argument.     */    private boolean labels = false;    /**     * Redirects everything that NUnit wants to send to the console.     */    private RedirectorElement redirectorElement;    /**     * Whether a failure should stop the build.     */    private boolean failOnError = false;    /**     * Name of property to set if a test fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Support for nested environment variables.     */    private Environment env = new Environment();    public NUnitTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the config file.     */    public void setConfig(File c) {        configFile = c;    }    /**     * The /output argument.     */    public void setOut(File out) {        this.out = out;    }    /**     * The /err argument.     */    public void setError(File err) {        this.err = err;    }    /**     * The /xml argument.     */    public void setXmlOut(File out) {        this.xmlOut = out;    }    /**     * The /transform argument.     */    public void setTransform(File transform) {        this.transform = transform;    }    /**     * The /thread argument.     */    public void setThread(boolean thread) {        this.thread = thread;    }    /**     * The /fixture argument.     */    public void setFixture(String fixture) {        this.fixture = fixture;    }    /**     * The /noshadow argument.     */    public void setNoshadow(boolean noshadow) {        this.noshadow = noshadow;    }    /**     * The /labels argument.     */    public void setLabels(boolean labels) {        this.labels = labels;    }    /**     * Whether a failure should stop the build.     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Name of property to set if a test fails.     *     * @since 1.0 Beta 2     */    public void setErrorProperty(String name) {        errorProperty = name;    }    /**     * Adds a test assembly by name.     */    public void addTestAssembly(NamedElement a) {        testAssemblies.add(a);    }    /**     * Adds a category to the include list.     */    public void addInclude(NamedElement a) {        includes.add(a);    }    /**     * Adds a category to the exclude list.     */    public void addExclude(NamedElement a) {        excludes.add(a);    }    /**     * Add an environment variable to the launched process.     *     * @param var new environment variable     */    public void addEnv(Environment.Variable var) {        env.addVariable(var);    }    /**     * Add a <code>RedirectorElement</code> to this task.     *     * <p>This does not use the <code>out</code> and     * <code>error</code> attributes, it only captures NUnits output     * that has not been redirected by those attributes.</p>     */    public void addConfiguredRedirector(RedirectorElement redirectorElement) {        if (this.redirectorElement != null) {            throw new BuildException("cannot have > 1 nested <redirector>s");        } else {            this.redirectorElement = redirectorElement;        }    }    public void execute() {        if (testAssemblies.size() == 0) {            throw new BuildException("You must specify at least one test "                                     + "assembly.");        }                DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      "nunit-console.exe",                                                     env);        Iterator iter = testAssemblies.iterator();        while (iter.hasNext()) {            NamedElement a = (NamedElement) iter.next();            exec.createArg().setValue(a.getName());        }        if (configFile != null) {            exec.createArg().setValue("/config="                                       + configFile.getAbsolutePath());        }        exec.createArg().setValue("/nologo");        if (out != null) {            exec.createArg().setValue("/output=" + out.getAbsolutePath());        }        if (err != null) {            exec.createArg().setValue("/err=" + err.getAbsolutePath());        }        if (xmlOut != null) {            exec.createArg().setValue("/xml=" + xmlOut.getAbsolutePath());        }        if (transform != null) {            exec.createArg().setValue("/transform="                                       + transform.getAbsolutePath());        }        if (thread) {            exec.createArg().setValue("/thread");        }        if (noshadow) {            exec.createArg().setValue("/noshadow");        }        if (labels) {            exec.createArg().setValue("/labels");        }        if (fixture != null) {            exec.createArg().setValue("/fixture=" + fixture);        }                if (includes.size() > 0) {            StringBuffer sb = new StringBuffer("/include=");            iter = includes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (excludes.size() > 0) {            StringBuffer sb = new StringBuffer("/exclude=");            iter = excludes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (redirectorElement != null) {            exec.addConfiguredRedirector(redirectorElement);        }        exec.setFailonerror(failOnError);        exec.internalSetErrorProperty(errorProperty);        exec.execute();    }    public static class NamedElement {        private String name;        public String getName() {return name;}        public void setName(String s) {name = s;}    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.util.DOMElementWriter;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.XMLFragment;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Base class for NAntTask and MSBuildTask. */public abstract class AbstractBuildTask extends Task {    /**     * The buildfile to invoke the build tool for.     */    private File buildFile;    /**     * The targets to execute.     */    private List targets = new ArrayList();    /**     * Properties to set.     */    private List properties = new ArrayList(1);    /**     * Nested build file fragment.     */    private XMLFragment buildSnippet;    /**     * The vm attribute - if given.     */    private String vm;    /**     * Whether a failure should stop the build.     *     * @since 1.0 Beta 2     */    private boolean failOnError = true;    /**     * Name of property to set if a build fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Empty constructor.     */    protected AbstractBuildTask() {    }    /**     * Sets the name of the build file.     */    public final void setBuildfile(File f) {        buildFile = f;    }    /**     * Adds a build file fragment.     */    public void addBuild(XMLFragment f) {        if (buildSnippet == null) {            buildSnippet = f;        } else {            throw new BuildException("You must not specify more than one "                                     + "build element");        }    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * A target.     */    public static class Target {        private String name;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }    }    /**     * A target to execute.     */    public final void addTarget(Target t) {        targets.add(t);    }    /**     * A property.     */    // XXX, could have reused Property or Environment.Variable     //      - not decided so far    public static class Property {        private String name;        private String value;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public void setValue(String value) {            this.value = value;        }        public String getValue() {            return value;        }    }    /**     * A target to execute.     */    public final void addProperty(Property t) {        properties.add(t);    }    /**     * Whether a failure should stop the build.     *     * @since 1.0 Beta 2     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Name of property to set if a build fails.     *     * @since 1.0 Beta 2     */    public void setErrorProperty(String name) {        errorProperty = name;    }    /**     * Must return the executable.     *     * @return must not return null     */    protected abstract String getExecutable();    /**     * Must return buildfile argument(s).     *     * @param buildFile the absolute File for the buildfile or null if     * the user didn't specify a buildfile.     *     * @return must not return null     */    protected abstract String[] getBuildfileArguments(File buildFile);    /**     * Must return target argument(s).     *     * @return must not return null     */    protected abstract String[] getTargetArguments(List targets);    /**     * Must return property argument(s).     *     * @return must not return null     */    protected abstract String[] getPropertyArguments(List properties);    /**     * Turn the DoucmentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>Must throw a BuildException if the snippet can not be turned     * into a build file.</p>     */    protected abstract Element makeTree(DocumentFragment f);    /**     * Perform the build.     */    public void execute() {        if (buildFile != null && buildSnippet != null) {            throw new BuildException("You must not specify the build file"                                     + " attribute and a nested build at the"                                     + " same time");        }        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      getExecutable(), null);        String[] args = getPropertyArguments(properties);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        args = getTargetArguments(targets);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        File generatedFile = null;        if (buildSnippet != null) {            try {                generatedFile = getBuildFile();            } catch (IOException e) {                throw new BuildException(e);            }            args = getBuildfileArguments(generatedFile);        } else {            args = getBuildfileArguments(buildFile);        }                for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        exec.setFailonerror(failOnError);        exec.internalSetErrorProperty(errorProperty);        try {            exec.execute();        } finally {            if (generatedFile != null) {                generatedFile.delete();            }        }    }    private File getBuildFile() throws IOException {        File f = null;        if (buildSnippet != null) {            Element e = makeTree(buildSnippet.getFragment());            f = FileUtils.getFileUtils().createTempFile("build", ".xml", null);            f.deleteOnExit();            FileOutputStream out = null;            try {                out = new FileOutputStream(f);                DOMElementWriter w =                    new DOMElementWriter(true,                                         DOMElementWriter.XmlNamespacePolicy                                         .ONLY_QUALIFY_ELEMENTS);                w.write(e, out);            } finally {                if (out != null) {                    out.close();                }            }        }        return f;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.Iterator;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a MSBuild build process. */public class MSBuildTask extends AbstractBuildTask {    private static final String TARGET = "generated-by-ant";    private static final String ROOT = "Project";    private static final String MSBUILD_NS =	"http://schemas.microsoft.com/developer/msbuild/2003";    public MSBuildTask() {        super();    }    protected String getExecutable() {        return "MSBuild.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        if (targets.size() > 0) {            StringBuffer sb = new StringBuffer("/target:");            Iterator iter = targets.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Target t =                     (AbstractBuildTask.Target) iter.next();                if (!first) {                    sb.append(";");                } else {                    first = false;                }                sb.append(t.getName());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    protected String[] getPropertyArguments(List properties) {        if (properties.size() > 0) {            StringBuffer sb = new StringBuffer("/property:");            Iterator iter = properties.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Property p =                     (AbstractBuildTask.Property) iter.next();                if (!first) {                    sb.append(";");                } else {                    first = false;                }                sb.append(p.getName()).append("=").append(p.getValue());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <Project> child, return that.     * Otherwise if we have only <Task> children, wrap them into a     * <Target> which in turn gets wrapped into a <Project>.     * Otherwise, fail.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals(ROOT)) {            return (Element) nl.item(0);        } else {            Element p = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     ROOT);            p.setAttribute("DefaultTargets", TARGET);            Element t = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     "Target");            t.setAttribute("Name", TARGET);            p.appendChild(t);            t.appendChild(f);            return p;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a NAnt build process. */public class NAntTask extends AbstractBuildTask {    public NAntTask() {        super();    }    protected String getExecutable() {        return "NAnt.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                "-buildfile:" + buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        ArrayList al = new ArrayList(targets.size());        Iterator iter = targets.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Target t = (AbstractBuildTask.Target) iter.next();            al.add(t.getName());        }        return (String[]) al.toArray(new String[al.size()]);    }    protected String[] getPropertyArguments(List properties) {        ArrayList al = new ArrayList(properties.size());        Iterator iter = properties.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                 (AbstractBuildTask.Property) iter.next();            al.add("-D:" + p.getName() + "=" + p.getValue());        }        return (String[]) al.toArray(new String[al.size()]);    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <project> child, return that.     * Otherwise assume that this is a valid build file snippet that     * just needs an empty project wrapped around it.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals("project")) {            return (Element) nl.item(0);        } else {            Element e = f.getOwnerDocument().createElement("project");            e.appendChild(f);            return e;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */// ====================================================================// place in the optional ant tasks package// but in its own dotnet group// ====================================================================package org.apache.ant.dotnet.compile;// ====================================================================// imports// ====================================================================import org.apache.ant.dotnet.NetCommand;import java.io.File;// ====================================================================/** *  Compiles C# source into executables or modules. * * csc.exe on Windows or mcs on other platforms must be on the execute * path, unless another executable or the full path to that executable * is specified in the <tt>executable</tt> parameter * <p> * All parameters are optional: &lt;csc/&gt; should suffice to produce a debug * build of all *.cs files. However, naming an <tt>destFile</tt>stops the * csc compiler from choosing an output name from random, and * allows the dependency checker to determine if the file is out of date. * <p> *  The task is a directory based task, so attributes like <b>includes="*.cs" *  </b> and <b>excludes="broken.cs"</b> can be used to control the files pulled *  in. By default, all *.cs files from the project folder down are included in *  the command. When this happens the output file -if not specified- is taken *  as the first file in the list, which may be somewhat hard to control. *  Specifying the output file with <tt>destFile</tt> seems prudent. <p> * * <p> * For more complex source trees, nested <tt>src</tt> elemements can be * supplied. When such an element is present, the implicit fileset is ignored. * This makes sense, when you think about it :) * * <p>For historical reasons the pattern * <code>**</code><code>/*.cs</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * <p> * References to external files can be made through the references attribute, * or (since Ant1.6), via nested &lt;reference&gt; filesets. With the latter, * the timestamps of the references are also used in the dependency * checking algorithm. * <p> * * Example * * <pre>&lt;csc *       optimize=&quot;true&quot; *       debug=&quot;false&quot; *       docFile=&quot;documentation.xml&quot; *       warnLevel=&quot;4&quot; *       unsafe=&quot;false&quot; *       targetType=&quot;exe&quot; *       incremental=&quot;false&quot; *       mainClass = &quot;MainApp&quot; *       destFile=&quot;NetApp.exe&quot; *       &gt; *           &lt;src dir="src" includes="*.cs" /&gt; *       &lt;reference file="${testCSC.dll}" /&gt; *       &lt;define name="RELEASE" /&gt; *       &lt;define name="DEBUG" if="debug.property"/&gt; *       &lt;define name="def3" unless="def3.property"/&gt; *    &lt;/csc&gt; * </pre> * * * @ant.task    name="csc" category="dotnet" * @since Ant 1.3 */public class CSharp extends DotnetCompile {    /**     *  defines list: RELEASE;WIN32;NO_SANITY_CHECKS;;SOMETHING_ELSE'     */    String definitions;    /**     *  output XML documentation flag     */    private File docFile;    /**     *  file alignment; 0 means let the compiler decide     */    private int fileAlign = 0;    /**     *  use full paths to things     */    private boolean fullpaths = false;    /**     *  incremental build flag     */    private boolean incremental;    /**     *  enable unsafe code flag. Clearly set to false by default     */    protected boolean unsafe;    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     */    private boolean noconfig = false;    /**     *  constructor inits everything and set up the search pattern     */    public CSharp() {        clear();    }    /**     * full cleanup     */    public void clear() {        super.clear();        docFile = null;        fileAlign = 0;        fullpaths = true;        incremental = false;        unsafe = false;        noconfig = false;        definitions = null;        setExecutable(isWindows ? "csc" : "mcs");    }    /**     *  file for generated XML documentation     *     *@param  f  output file     */    public void setDocFile(File f) {        docFile = f;    }    /**     *  get the argument or null for no argument needed     *     *@return    The DocFile Parameter to CSC     */    protected String getDocFileParameter() {        if (docFile != null) {            return "/doc:" + docFile.toString();        } else {            return null;        }    }    /**     * Set the file alignment.     * Valid values are 0,512, 1024, 2048, 4096, 8192,     * and 16384, 0 means 'leave to the compiler'     */    public void setFileAlign(int fileAlign) {        this.fileAlign = fileAlign;    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getFileAlignParameter() {        if (fileAlign != 0 && !"mcs".equals(getExecutable())) {            return "/filealign:" + fileAlign;        } else {            return null;        }    }    /**     * If true, print the full path of files on errors.     *     *@param  enabled  The new fullPaths value     */    public void setFullPaths(boolean enabled) {        fullpaths = enabled;    }    /**     *  Gets the fullPathsParameter attribute of the CSharp object     *     *@return    The fullPathsParameter value or null if unset     */    protected String getFullPathsParameter() {        return fullpaths ? "/fullpaths" : null;    }    /**     *  set the incremental compilation flag on or off.     *     *@param  incremental  on/off flag     */    public void setIncremental(boolean incremental) {        this.incremental = incremental;    }    /**     *  query the incrementalflag     *     *@return    true if incremental compilation is turned on     */    public boolean getIncremental() {        return incremental;    }    /**     *  get the incremental build argument     *     *@return    The Incremental Parameter to CSC     */    protected String getIncrementalParameter() {        return "/incremental" + (incremental ? "+" : "-");    }    /**     *  The output file. This is identical to the destFile attribute.     *     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        setDestFile(params);    }    /**     * If true, enables the unsafe keyword.     *     *@param  unsafe  The new Unsafe value     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     *  query the Unsafe attribute     *     *@return    The Unsafe value     */    public boolean getUnsafe() {        return this.unsafe;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Unsafe Parameter to CSC     */    protected String getUnsafeParameter() {        return unsafe ? "/unsafe" : null;    }    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     *     *@param  enabled  The new noConfig value     */    public void setNoConfig(boolean enabled) {        noconfig = enabled;    }    /**     *  Gets the noConfigParameter attribute of the CSharp object     *     *@return    The noConfigParameter value     */    protected String getNoConfigParameter() {        return noconfig ? "/noconfig" : null;    }    /**     *  Semicolon separated list of defined constants.     *     *@param  params  The new definitions value     */    public void setDefinitions(String params) {        definitions = params;    }    /**     * override the superclasses version of this method (which we call)     * with a check for a definitions attribute, the contents of which     * are appended to the list.     *@return    The Definitions Parameter to CSC     */    protected String getDefinitionsParameter() {        String predecessors = super.getDefinitionsParameter();        if (notEmpty(definitions)) {            if (predecessors == null) {                predecessors = "/define:";            }            return  predecessors + definitions;        } else {            return predecessors;        }    }    /**     * add Commands unique to C#.     * @param command ongoing command     */    public void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getIncludeDefaultReferencesParameter());        command.addArgument(getWarnLevelParameter());        command.addArgument(getDocFileParameter());        command.addArgument(getFullPathsParameter());        command.addArgument(getFileAlignParameter());        command.addArgument(getIncrementalParameter());        command.addArgument(getNoConfigParameter());        command.addArgument(getUnsafeParameter());    }    // end execute    /**     * Returns the delimiter which C# uses to separate references, i.e., a semi colon.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * This method indicates the filename extension for C# files.     * @return the file extension for C#, i.e., "cs" (without the dot).     */    public String getFileExtension() {        return "cs";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.taskdefs.MatchingTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.Project;import org.apache.tools.ant.DirectoryScanner;import java.io.File;import java.util.Vector;import java.util.Hashtable;import java.util.Enumeration;/** * refactoring of some stuff so that different things (like ILASM) * can use shared code. */public class DotnetBaseMatchingTask extends MatchingTask {    /**     *  output file. If not supplied this is derived from the source file     */    protected File outputFile;    /**     * filesets of file to compile     */    protected Vector filesets = new Vector();    /**     *  source directory upon which the search pattern is applied     */    protected File srcDir;    /**     * Are we running on Windows?     *     * @since Ant 1.6.3     */    protected static final boolean isWindows = Os.isFamily("windows");    /**    * Overridden because we need to be able to set the srcDir.    */    public File getSrcDir() {        return this.srcDir;    }    /**     *  Set the source directory of the files to be compiled.     *     *@param  srcDirName  The new SrcDir value     */    public void setSrcDir(File srcDirName) {        this.srcDir = srcDirName;    }    /**     *  Set the name of exe/library to create.     *     *@param  file  The new outputFile value     */    public void setDestFile(File file) {        outputFile = file;    }    /**     * add a new source directory to the compile     * @param src     */    public void addSrc(FileSet src) {        filesets.add(src);    }    /**     * get the destination file     * @return the dest file or null for not assigned     */    public File getDestFile() {        return outputFile;    }    /**     * create the list of files     * @param filesToBuild vector to add files to     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int buildFileList(NetCommand command, Hashtable filesToBuild, long outputTimestamp) {        int filesOutOfDate = 0;        boolean scanImplicitFileset            = getSrcDir() != null || filesets.size() == 0;        if (scanImplicitFileset) {            //scan for an implicit fileset if there was a srcdir set            //or there was no srcDir set but there was no contained classes            if (getSrcDir() == null) {                //if there is no src dir here, set it                setSrcDir(getProject().resolveFile("."));            }            log("working from source directory " + getSrcDir(),                    Project.MSG_VERBOSE);            //get dependencies list.            DirectoryScanner scanner = getDirectoryScanner(getSrcDir());            filesOutOfDate = command.scanOneFileset(scanner,                    filesToBuild, outputTimestamp);        }        //get any included source directories        for (int i = 0; i < filesets.size(); i++) {            FileSet fs = (FileSet) filesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        return filesOutOfDate;    }    /**     * add the list of files to a command     * @param filesToBuild vector of files     * @param command the command to append to     */    protected void addFilesToCommand(Hashtable filesToBuild, NetCommand command) {        int count = filesToBuild.size();        log("compiling " + count + " file" + ((count == 1) ? "" : "s"),                Project.MSG_VERBOSE);        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            command.addArgument(file.toString());        }    }    /**     * determine the timestamp of the output file     * @return a timestamp or 0 for no output file known/exists     */    protected long getOutputFileTimestamp() {        long outputTimestamp;        if (getDestFile() != null && getDestFile().exists()) {            outputTimestamp = getDestFile().lastModified();        } else {            outputTimestamp = 0;        }        return outputTimestamp;    }    /**     * finish off the command by adding all dependent files, execute     * @param command     */    protected void addFilesAndExecute(NetCommand command, boolean ignoreTimestamps) {        long outputTimestamp = getOutputFileTimestamp();        Hashtable filesToBuild = new Hashtable();        int filesOutOfDate = buildFileList(command, filesToBuild, outputTimestamp);        //now run the command of exe + settings + files        if (filesOutOfDate > 0) {            //add the files to the command            addFilesToCommand(filesToBuild, command);            command.runCommand();        } else {            log("output file is up to date", Project.MSG_VERBOSE);        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap:Cream+Live+2001+CD+2 */// place in the optional ant tasks package// but in its own dotnet grouppackage org.apache.ant.dotnet.compile;// importsimport java.io.File;import java.util.Vector;import java.util.Enumeration;import java.util.Hashtable;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.Path;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.types.EnumeratedAttribute;/** *  Abstract superclass for dotnet compiler tasks. * *  History *  <table> *    <tr> *      <td> *        0.1 *      </td> *      <td> *        First creation *      </td> *      <td> *        Most of the code here was copied verbatim from v0.3 of *        Steve Loughran's CSharp optional task. Abstracted functionality *        to allow subclassing of other dotnet compiler types. *      </td> *    </tr> * *  </table> * * * @version     0.1 */public abstract class DotnetCompile         extends DotnetBaseMatchingTask {    /**     *  list of reference classes. (pretty much a classpath equivalent)     */    private String references;    /**     *  flag to enable automatic reference inclusion     */    private boolean includeDefaultReferences = true;    /**     *  icon for incorporation into apps     */    private File win32icon;    /**     *  icon for incorporation into apps     */    private File win32res;    /**     *  flag to control action on execution trouble     */    private boolean failOnError;    /**     *  using the path approach didn't work as it could not handle the implicit     *  execution path. Perhaps that could be extracted from the runtime and     *  then the path approach would be viable     */    private Path referenceFiles;    /**     *  optimise flag     */    private boolean optimize;    /**     * a list of definitions to support;     */    protected Vector definitionList = new Vector();    /**     * our resources     */    protected Vector resources = new Vector();    /**     *  executable     */    protected String executable;    protected static final String REFERENCE_OPTION = "/reference:";    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  warning level: 0-4, with 4 being most verbose     */    private int warnLevel;    /**     *  main class (or null for automatic choice)     */    protected String mainClass;    /**     *  any extra command options?     */    protected String extraOptions;    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  utf out flag     */    protected boolean utf8output = false;    /**     *  list of extra modules to refer to     */    protected String additionalModules;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    private static final int AUTOMATIC_RESPONSE_FILE_THRESHOLD = 64;    /**     *  constructor inits everything and set up the search pattern     */    public DotnetCompile() {        clear();        setIncludes(getFilePattern());    }    /**     *  reset all contents.     */    public void clear() {        targetType = null;        win32icon = null;        srcDir = null;        mainClass = null;        warnLevel = 3;        optimize = false;        debug = true;        references = null;        failOnError = true;        additionalModules = null;        includeDefaultReferences = true;        extraOptions = null;    }    /**     * Semicolon separated list of DLLs to refer to.     *     *@param  s  The new References value     */    public void setReferences(String s) {        references = s;    }    /**     *  get the reference string or null for no argument needed     *     *@return    The References Parameter to CSC     */    protected String getReferencesParameter() {        //bail on no references        if (notEmpty(references)) {            if (isWindows) {                return '\"' + REFERENCE_OPTION + references + '\"';            } else {                return REFERENCE_OPTION + references;            }        } else {            return null;        }    }    /**     * Path of references to include.     * Wildcards should work.     *     *@param  path  another path to append     */    public void setReferenceFiles(Path path) {        //demand create pathlist        if (referenceFiles == null) {            referenceFiles = new Path(this.getProject());        }        referenceFiles.append(path);    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     *  turn the path list into a list of files and a /references argument     *     *@return    null or a string of references.     */    protected String getReferenceFilesParameter() {        //bail on no references        if (references == null) {            return null;        }        //iterate through the ref list & generate an entry for each        //or just rely on the fact that the toString operator does this, but        //noting that the separator is ';' on windows, ':' on unix        //bail on no references listed        if (references.length() == 0) {            return null;        }        StringBuffer s = new StringBuffer(REFERENCE_OPTION);        if (isWindows) {            s.append('\"');        }        s.append(references);        if (isWindows) {            s.append('\"');        }        return s.toString();    }    /**     * If true, automatically includes the common assemblies     * in dotnet, and tells the compiler to link in mscore.dll.     *     *  set the automatic reference inclusion flag on or off this flag controls     *  the /nostdlib option in CSC     *     *@param  f  on/off flag     */    public void setIncludeDefaultReferences(boolean f) {        includeDefaultReferences = f;    }    /**     *  query automatic reference inclusion flag     *     *@return    true if flag is turned on     */    public boolean getIncludeDefaultReferences() {        return includeDefaultReferences;    }    /**     *  get the include default references flag or null for no argument needed     *     *@return    The Parameter to CSC     */    protected String getIncludeDefaultReferencesParameter() {        return "/nostdlib" + (includeDefaultReferences ? "-" : "+");    }    /**     * If true, enables optimization flag.     *     *@param  f  on/off flag     */    public void setOptimize(boolean f) {        optimize = f;    }    /**     *  query the optimise flag     *     *@return    true if optimise is turned on     */    public boolean getOptimize() {        return optimize;    }    /**     *  get the optimise flag or null for no argument needed     *     *@return    The Optimize Parameter to CSC     */    protected String getOptimizeParameter() {        return "/optimize" + (optimize ? "+" : "-");    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the debug switch argument     *     *@return    The Debug Parameter to CSC     */    protected String getDebugParameter() {        return "/debug" + (debug ? "+" : "-");    }    /**     * Level of warning currently between 1 and 4     * with 4 being the strictest.     *     *@param  warnLevel  warn level -see .net docs for valid range (probably     *      0-4)     */    public void setWarnLevel(int warnLevel) {        this.warnLevel = warnLevel;    }    /**     *  query warn level     *     *@return    current value     */    public int getWarnLevel() {        return warnLevel;    }    /**     *  get the warn level switch     *     *@return    The WarnLevel Parameter to CSC     */    protected String getWarnLevelParameter() {        return "/warn:" + warnLevel;    }    /**     *  Sets the name of main class for executables.     *     *@param  mainClass  The new MainClass value     */    public void setMainClass(String mainClass) {        this.mainClass = mainClass;    }    /**     *  Gets the MainClass attribute     *     *@return    The MainClass value     */    public String getMainClass() {        return this.mainClass;    }    /**     *  get the /main argument or null for no argument needed     *     *@return    The MainClass Parameter to CSC     */    protected String getMainClassParameter() {        if (mainClass != null && mainClass.length() != 0) {            return "/main:" + mainClass;        } else {            return null;        }    }    /**     * Any extra options which are not explicitly supported     * by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     *  get any extra options or null for no argument needed, split     *  them if they represent multiple options.     *     * @return    The ExtraOptions Parameter to CSC     */    protected String[] getExtraOptionsParameters() {        String extra = getExtraOptionsParameter();        return extra == null ? null : Commandline.translateCommandline(extra);    }    /**     * Set the destination directory of files to be compiled.     *     *@param  dirName  The new DestDir value     */    public void setDestDir(File dirName) {        log("DestDir currently unused", Project.MSG_WARN);    }    /**     * set the target type to one of exe|library|module|winexe     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Set the type of target.     *     *@param  ttype          The new TargetType value     *@exception  BuildException  if target is not one of     *      exe|library|module|winexe     */    public void setTargetType(String ttype)             throws BuildException {        ttype = ttype.toLowerCase();        if (ttype.equals("exe") || ttype.equals("library")            || ttype.equals("module") || ttype.equals("winexe")) {            targetType = ttype;        } else {            throw new BuildException("targetType " + ttype                    + " is not one of 'exe', 'module', 'winexe' or 'library'");        }    }    /**     *  Gets the TargetType attribute     *     *@return    The TargetType value     */    public String getTargetType() {        return targetType;    }    /**     *  get the argument or null for no argument needed     *     *@return    The TargetType Parameter to CSC     */    protected String getTargetTypeParameter() {        if (notEmpty(targetType)) {            return "/target:" + targetType;        } else {            return null;        }    }    /**     *  Set the filename of icon to include.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Icon(File fileName) {        win32icon = fileName;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Icon Parameter to CSC     */    protected String getWin32IconParameter() {        if (win32icon != null) {            return "/win32icon:" + win32icon.toString();        } else {            return null;        }    }    /**     * Sets the filename of a win32 resource (.RES) file to include.     * This is not a .NET resource, but what Windows is used to.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Res(File fileName) {        win32res = fileName;    }    /**     * Gets the file of the win32 .res file to include.     * @return path to the file.     */    public File getWin32Res() {        return win32res;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (win32res != null) {            return "/win32res:" + win32res.toString();        } else {            return null;        }    }    /**     * If true, require all compiler output to be in UTF8 format.     *     *@param  enabled  The new utf8Output value     */    public void setUtf8Output(boolean enabled) {        utf8output = enabled;    }    /**     *  Gets the utf8OutpuParameter attribute of the CSharp object     *     *@return    The utf8OutpuParameter value     */    protected String getUtf8OutputParameter() {        return utf8output ? "/utf8output" : null;    }    /**     * add a define to the list of definitions     * @param define     */    public void addDefine(DotnetDefine define) {        definitionList.addElement(define);    }    /**     * get a list of definitions or null     * @return a string beginning /D: or null for no definitions     */    protected String getDefinitionsParameter() throws BuildException {        StringBuffer defines = new StringBuffer();        Enumeration defEnum = definitionList.elements();        boolean firstDefinition = true;        while (defEnum.hasMoreElements()) {            //loop through all definitions            DotnetDefine define = (DotnetDefine) defEnum.nextElement();            if (define.isSet(this)) {                //add those that are set, and a delimiter                if (!firstDefinition) {                    defines.append(getDefinitionsDelimiter());                }                defines.append(define.getValue(this));                firstDefinition = false;            }        }        if (defines.length() == 0) {            return null;        } else {            return "/d:" + defines;        }    }    /**     * Semicolon separated list of modules to refer to.     *     *@param  params  The new additionalModules value     */    public void setAdditionalModules(String params) {        additionalModules = params;    }    /**     *  get the argument or null for no argument needed     *     *@return    The AdditionalModules Parameter to CSC     */    protected String getAdditionalModulesParameter() {        if (notEmpty(additionalModules)) {            return "/addmodule:" + additionalModules;        } else {            return null;        }    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getDestFileParameter() {        if (outputFile != null) {            return "/out:" + outputFile.toString();        } else {            return null;        }    }    /**     * If true, fail on compilation errors.     *     *@param  b  The new FailOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The FailFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     * link or embed a resource     * @param resource     */    public void addResource(DotnetResource resource) {        resources.add(resource);    }    /**     * This method gets the name of the executable.     * @return the name of the executable     */    protected String getExecutable() {        return executable;    }    /**     * set the name of the program, overriding the defaults.     * Can be used to set the full path to a program, or to switch     * to an alternate implementation of the command, such as the Mono or Rotor     * versions -provided they use the same command line arguments as the     * .NET framework edition     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     *  test for a string containing something useful     *     *@param  s  string in     *@return    true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (outputFile != null && outputFile.isDirectory()) {            throw new BuildException("destFile cannot be a directory");        }        if (getExecutable() == null) {            throw new BuildException("There is no executable defined for this task");        }    }    /**     * Get the pattern for files to compile.     * @return The compilation file pattern.     */    public String getFilePattern() {        return "**/*." + getFileExtension();    }    /**     * getter for flag     * @return The flag indicating whether the compilation is using a response file.     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * Flag to turn on response file use; default=false.     * When set the command params are saved to a file and     * this is passed in with @file. The task automatically switches     * to this mode with big commands; this option is here for     * testing and emergencies     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        validate();        NetCommand command = createNetCommand();        //set up response file options        command.setAutomaticResponseFileThreshold(AUTOMATIC_RESPONSE_FILE_THRESHOLD);        command.setUseResponseFile(useResponseFile);        //fill in args        fillInSharedParameters(command);        addResources(command);        addCompilerSpecificOptions(command);        int referencesOutOfDate            = addReferenceFilesets(command, getOutputFileTimestamp());        //if the refs are out of date, force a build.        boolean forceBuild = referencesOutOfDate > 0;        addFilesAndExecute(command, forceBuild);    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public abstract String getReferenceDelimiter();    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public abstract String getFileExtension();    /**     * fill in the common information     * @param command     */    protected void fillInSharedParameters(NetCommand command) {        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument("/nologo");        command.addArgument(getAdditionalModulesParameter());        command.addArgument(getDebugParameter());        command.addArgument(getDefinitionsParameter());        command.addArguments(getExtraOptionsParameters());        command.addArgument(getMainClassParameter());        command.addArgument(getOptimizeParameter());        command.addArgument(getDestFileParameter());        command.addArgument(getReferencesParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getUtf8OutputParameter());        command.addArgument(getWin32IconParameter());        command.addArgument(getWin32ResParameter());    }    /**     * for every resource declared, we get the (language specific)     * resource setting     */    protected void addResources(NetCommand command) {        Enumeration e = resources.elements();        while (e.hasMoreElements()) {            DotnetResource resource = (DotnetResource) e.nextElement();            createResourceParameter(command, resource);        }    }    /* XXX Javadoc makes little sense, rewrite     * from a resource, get the     * @param resource     * @return a string containing the resource param, or a null string     * to conditionally exclude a resource.     */    protected abstract void createResourceParameter(NetCommand command, DotnetResource resource);    /**     * run through the list of reference files and add them to the command     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int addReferenceFilesets(NetCommand command, long outputTimestamp) {        int filesOutOfDate = 0;        Hashtable filesToBuild = new Hashtable();        for (int i = 0; i < referenceFilesets.size(); i++) {            FileSet fs = (FileSet) referenceFilesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        //bail out early if there were no files        if (filesToBuild.size() == 0) {            return 0;        }        //now scan the hashtable and add the files        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            if (isFileManagedBinary(file)) {                if (isWindows) command.addArgument('"'+REFERENCE_OPTION+file.toString()+'"');                else command.addArgument(REFERENCE_OPTION+file.toString());            } else {                log("ignoring " + file + " as it is not a managed executable",                        Project.MSG_VERBOSE);            }        }        return filesOutOfDate;    }    /**     * create our helper command     * @return a command prefilled with the exe name and task name     */    protected NetCommand createNetCommand() {        NetCommand command = new NetCommand(this, getTaskName(), getExecutable());        return command;    }    /**     * add any compiler specifics     * @param command     */    protected abstract void addCompilerSpecificOptions(NetCommand command);    /**     * override point for delimiting definitions.     * @return The definitions limiter, i.e., ";"     */    public String getDefinitionsDelimiter() {        return ";";    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[] {                "exe",                "library",                "module",                "winexe"            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;/** * definitions can be conditional. What .NET conditions can not be * is in any state other than defined and undefined; you cannot give * a definition a value. */public class DotnetDefine {    private String name;    private String ifCond;    private String unlessCond;    /**     * the name of a property which must be defined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setIf(String condition) {        this.ifCond = condition;    }    /**     * the name of a property which must be undefined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setUnless(String condition) {        this.unlessCond = condition;    }    public String getName() {        return name;    }    /**     * the name of the definition. Required.     * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * This method gets the value of this definition. Will be null if a condition     * was declared and not met     * @param owner owning task     * @return The value of the definition.     * @throws BuildException     */    public String getValue(Task owner) throws BuildException {        if (name == null) {            throw new BuildException("No name provided for the define element",                owner.getLocation());        }        if (!isSet(owner)) {            return null;        }        return name;    }    /**     * logic taken from patternset     * @param owner     * @return true if the condition is valid     */    public boolean isSet(Task owner) {        Project p = owner.getProject();        if (ifCond != null && p.getProperty(ifCond) == null) {            return false;        } else if (unlessCond != null && p.getProperty(unlessCond) != null) {            return false;        }        return true;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import java.io.File;import java.util.ArrayList;import org.apache.tools.ant.types.FileSet;import java.util.Iterator;import org.apache.tools.ant.*;/** * Used by {@link DotnetCompile} to name resources. * Could be upgraded to a datatype in the distant future. * A resource maps to /res:file,name */public class DotnetResource {    /**     * name of resource     */    private File file;    /**     * embed (default) or link the resource     */    private boolean embed = true;    /**     * this is used in VBC and JSC     */    private Boolean isPublic = null;    /**     * name of the object     */    private String name = null;    /**     * A list of filesets with resources.     */    private ArrayList fileSets = new ArrayList();    /**     * a namespace to be used with <filesets>     */    private String namespace = null;    public boolean isEmbed() {        return embed;    }    /**     * embed the resource in the assembly (default, true) or just link to it.     *      * @param embed     */    public void setEmbed(boolean embed) {        this.embed = embed;    }    public File getFile() {        return file;    }    /**     * name the resource     *      * @param file     */    public void setFile(File file) {        this.file = file;    }    public Boolean getPublic() {        return isPublic;    }    /**     * VB and J# only: is a resource public or not?     *      * @param aPublic     */    public void setPublic(Boolean aPublic) {        isPublic = aPublic;    }    public String getName() {        return name;    }    /**     * should the resource have a name?     *      * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * Filesets root namespace. The value always ends with '.' .     *      * @return String namespace name     */    public String getNamespace() {        return namespace;    }    /**     * Sets filesets root namespace.     *      * @param namespace     *            String root namespace     */    public void setNamespace(String namespace) {        if (namespace == null) {            this.namespace = null;        } else {            this.namespace = (namespace.length() == 0 || namespace.endsWith(".") ? namespace                    : namespace + '.');        }    }    private void checkParameters() {        if (hasFilesets()) {            if (getName() != null)                throw new BuildException(                        "Cannot use <resource name=\"...\"> attribute with filesets");            if (getFile() != null)                throw new BuildException(                        "Cannot use <resource file=\"...\"> attribute with filesets");        } else {            if (getNamespace() != null)                throw new BuildException(                        "Cannot use <resource namespace=\"...\"> attribute without filesets");        }    }    /**     * build the C# style parameter (which has no public/private option)     */    public void getParameters(Project p, NetCommand command, boolean csharpStyle) {        checkParameters();        if (hasFilesets()) {            for (Iterator listIter = fileSets.iterator(); listIter.hasNext();) {                FileSet fs = (FileSet) listIter.next();                String baseDirectory = fs.getDir(p).toString();                String namespace = getNamespace(); // ends with '.' or null                DirectoryScanner ds = fs.getDirectoryScanner(p);                String[] files = ds.getIncludedFiles();                for (int i = 0; i < files.length; i++) {                    String file = files[i];                    command.addArgument(getParameter(baseDirectory + File.separatorChar + file,                            (namespace == null ? null : namespace                                    + file.replace(File.separatorChar, '.')), csharpStyle));                }            }        } else {            command.addArgument(getParameter(getFile().toString(), getName(), csharpStyle));        }    }    private String getParameter(String fileName, String name, boolean csharpStyle) {        StringBuffer buffer = new StringBuffer();        buffer.append(isEmbed() ? "/resource" : "/linkresource");        buffer.append(':');        buffer.append(fileName);        if (name != null) {            buffer.append(',');            buffer.append(name);            if (csharpStyle) {                if (getPublic() != null) {                    throw new BuildException("This compiler does not support the "                            + "public/private option.");                } else {                    if (getPublic() != null) {                        buffer.append(',');                        buffer.append(getPublic().booleanValue() ? "public" : "private");                    }                }            } else if (getPublic() != null) {                throw new BuildException("You cannot have a public or private "                        + "option without naming the resource");            }        }        return buffer.toString();    }    /**     * Adds a resource file set.     *      * @param fileset     *            FileSet     */    public void addFileset(FileSet fileset) {        fileSets.add(fileset);    }    /**     * Checks that <resource> node has embedded <filesets>     *      * @return boolean     */    public boolean hasFilesets() {        return fileSets.size() > 0;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;/** * Assembles .NET Intermediate Language files. * ilasm.exe must be on the execute path, unless another executable * or the full path to that executable is specified in the <tt>executable</tt> * parameter *  <p> * *  <p> * *  All parameters are optional: &lt;il/&gt; should suffice to produce a debug *  build of all *.il files. The option set is roughly compatible with the *  CSharp class; even though the command line options are only vaguely *  equivalent. [The low level commands take things like /OUT=file, csc wants *  /out:file ... /verbose is used some places; /quiet here in ildasm... etc.] *  It would be nice if someone made all the command line tools consistent (and *  not as brittle as the java cmdline tools) <p> *  <p> *  The task is a directory based task, so attributes like <b>includes="*.il" *  </b> and <b>excludes="broken.il"</b> can be used to control the files pulled *  in. You can also use nested &lt;src&gt filesets to refer to source. * <p> * * @ant.task    name="ilasm" category="dotnet" */public class Ilasm         extends DotnetBaseMatchingTask {    /**     *  Name of the executable. The .exe suffix is deliberately not included in     *  anticipation of the unix version     */    protected static final String exe_name = "ilasm";    /**     *  what is the file extension we search on?     */    protected static final String file_ext = "il";    /**     *  and now derive the search pattern from the extension     */    protected static final String file_pattern = "**/*." + file_ext;    /**     *  title of task for external presentation     */    protected static final String exe_title = "ilasm";    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  verbose flag     */    protected boolean verbose;    /**     *  listing flag     */    protected boolean listing;    /**     *  resource file (.res format) to include in the app.     */    protected File resourceFile;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  file containing private key     */    private File keyfile;    /**     *  any extra command options?     */    protected String extraOptions;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * @since Ant 1.7     */    private boolean isMono = !Os.isFamily("windows");    /**     *  constructor inits everything and set up the search pattern     */    public Ilasm() {        Clear();        setIncludes(file_pattern);    }    /**     *  reset all contents.     */    public void Clear() {        targetType = null;        srcDir = null;        listing = false;        verbose = false;        debug = true;        outputFile = null;        failOnError = true;        resourceFile = null;        extraOptions = null;    }    /**     * Sets the type of target, either "exe" or "library".     *     *@param  targetType          one of exe|library|     *@exception  BuildException  if target is not one of     *      exe|library     */    public void setTargetType(String targetType)             throws BuildException {        this.targetType = targetType.toLowerCase();        if (!targetType.equals("exe") && !targetType.equals("library")) {            throw new BuildException("targetType " + targetType + " is not a valid type");        }    }    /**     *  accessor method for target type     *     *@return    the current target option     */    public String getTargetType() {        return targetType;    }    /**     *  g get the target type or null for no argument needed     *     *@return    The TargetTypeParameter value     */    protected String getTargetTypeParameter() {        if (!notEmpty(targetType)) {            return null;        }        if (targetType.equals("exe")) {            return "/exe";        } else if (targetType.equals("library")) {            return "/dll";        } else {            return null;        }    }    /**     * Sets the Owner attribute.     *     * @param  s  The new Owner value     * @ant.attribute ignore="true"     */    public void setOwner(String s) {        log("This option is not supported by ILASM as of Beta-2, "            + "and will be ignored", Project.MSG_WARN);    }    /**     *  test for a string containing something useful     *     *@param  s       any string     *@return         true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     *  If true, enable verbose ILASM output.     *     *@param  b  flag set to true for verbose on     */    public void setVerbose(boolean b) {        verbose = b;    }    /**     *  turn the verbose flag into a parameter for ILASM     *     *@return    null or the appropriate command line string     */    protected String getVerboseParameter() {        return verbose ? null : "/quiet";    }    /**     * If true, produce a listing (off by default).     *     *@param  b  flag set to true for listing on     */    public void setListing(boolean b) {        listing = b;    }    /**     *  turn the listing flag into a parameter for ILASM     *     *@return    the appropriate string from the state of the listing flag     */    protected String getListingParameter() {        if (!isMono) {            return listing ? "/listing" : "/nolisting";        }        return null;    }    /**     * Set the output file; identical to setDestFile     * @see DotnetBaseMatchingTask#setDestFile     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        outputFile = params;    }    /**     *  get the output file     *     *@return    the argument string or null for no argument     */    protected String getOutputFileParameter() {        if (outputFile == null) {            return null;        }        return "/output=" + outputFile.toString();    }    /**     * name of resource file to include.     *     * @param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setResourceFile(File fileName) {        resourceFile = fileName;    }    /**     *  Gets the resourceFileParameter attribute of the Ilasm task     *     *@return    The resourceFileParameter value     */    protected String getResourceFileParameter() {        if (resourceFile != null) {            return "/resource=" + resourceFile.toString();        } else {            return null;        }    }    /**     * If true, fails if ilasm tool fails.     *     *@param  b  The new failOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the argument or null for no argument needed     *     *@return    The debugParameter value     */    protected String getDebugParameter() {        return debug ? "/debug" : null;    }    /**     * the name of a file containing a private key.     *     *@param  keyfile  The new keyfile value     */    public void setKeyfile(File keyfile) {        this.keyfile = keyfile;    }    /**     *  get the argument or null for no argument needed     *     *@return    The keyfileParameter value     */    protected String getKeyfileParameter() {        if (keyfile != null) {            return "/keyfile:" + keyfile.toString();        } else {            return null;        }    }    /**     * Any extra options which are not explicitly     * supported by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     * set the target type to one of exe|library     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Explicitly override the Mono auto-detection.     *     * <p>Defaults to false on Windows and true on any other platform.</p>     *     * @since Ant 1.7     */    public void setMono(boolean b) {        isMono = b;    }    /**     *  This is the execution entry point. Build a list of files and call ilasm     *  on each of them.     *     *@throws  BuildException  if the assembly failed and FailOnError is true     */    public void execute()             throws BuildException {        NetCommand command = buildIlasmCommand();        addFilesAndExecute(command, false);    }    // end execute    /**     * build up our ilasm command     * @return     */    private NetCommand buildIlasmCommand() {        NetCommand command = new NetCommand(this, exe_title, exe_name);        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument(getDebugParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getListingParameter());        command.addArgument(getOutputFileParameter());        command.addArgument(getResourceFileParameter());        command.addArgument(getVerboseParameter());        command.addArgument(getKeyfileParameter());        command.addArgument(getExtraOptionsParameter());        /*         *  space for more argumentativeness         *  command.addArgument();         *  command.addArgument();         */        return command;    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "exe",                "library",            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * Compile J# source down to a managed .NET application. * <p> * J# is not Java. But it is the language closest to Java in the .NET framework. * This task compiles jsharp source (.java files), and * generates a .NET managed exe or dll. * <p> * * <p>For historical reasons the pattern * <code>**</code><code>/*.java</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * @see <A=ref="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_vjsharp/html/vjoriMicrosoftVisualJ.asp"> * Visual J++ online documentation</a> * * @since ant1.6 * @ant.task category="dotnet" name="jsharpc" */public class JSharp extends DotnetCompile {    /**     * hex base address     */    String baseAddress;    /** /x option to disable J++ and J# lang extensions     *     */    boolean pureJava = true;    /**     * whether to make package scoped stuff public or assembly scoped     */    boolean secureScoping = false;    public JSharp() {        setExecutable("vjc");    }    public void setBaseAddress(String baseAddress) {        this.baseAddress = baseAddress;    }    /**     * do we want pure java (default, true) or corrupted J#?     * @param pureJava     */    public void setPureJava(boolean pureJava) {        this.pureJava = pureJava;    }    /**     * Make package scoped code visible to the current assembly only (default: false)     * .NET does not have package scoping. Instead it has assembly, private and public.     * By default, package content is public to all.     * @param secureScoping     */    public void setSecureScoping(boolean secureScoping) {        this.secureScoping = secureScoping;    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return ".java";    }    /**     * add jvc specific commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        if (pureJava) {            command.addArgument("/x:all");        }        if (secureScoping) {            command.addArgument("/securescoping");        }    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }    /**     * validation code     * @throws  org.apache.tools.ant.BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * This task compiles Visual Basic.NET source into executables or modules. * The task requires vbc.exe on the execute path, unless it or an equivalent * program is specified in the <tt>executable</tt> parameter * * <p> * All parameters are optional: &lt;vbc/&gt; should suffice to produce a debug * build of all *.vb files. * * <p> * The task is a directory based task, so attributes like * <tt>includes=&quot;**\/*.vb&quot;</tt> and * <tt>excludes=&quot;broken.vb&quot;</tt> can be used to control * the files pulled in. By default, * all *.vb files from the project folder down are included in the command. * When this happens the destFile -if not specified- * is taken as the first file in the list, which may be somewhat hard to control.   Specifying the output file with <tt>destfile</tt> is prudent. </p> <p> * Also, dependency checking only works if destfile is set. * * <p>For historical reasons the pattern * <code>**</code><code>/*.vb</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * As with &lt;csc&gt; nested <tt>src</tt> filesets of source, * reference filesets, definitions and resources can be provided. * * <p> * Example * </p> * <pre>&lt;vbc *   optimize=&quot;true&quot; *   debug=&quot;false&quot; *   warnLevel=&quot;4&quot; *   targetType=&quot;exe&quot; *   definitions=&quot;RELEASE&quot; *   excludes=&quot;src/unicode_class.vb&quot; *   mainClass = &quot;MainApp&quot; *   destFile=&quot;NetApp.exe&quot; *   optionExplicit=&quot;true&quot; *   optionCompare=&quot;text&quot; *   references="System.Xml,System.Web.Xml" *   &gt; *          &lt;reference file="${testCSC.dll}" /&gt; *          &lt;define name="RELEASE" /&gt; *          &lt;define name="DEBUG" if="debug.property"/&gt; *          &lt;define name="def3" unless="def2.property"/&gt; *   &lt;/vbc&gt; </pre> * @ant.task    name="vbc" category="dotnet" */public class VisualBasicCompile extends DotnetCompile {    /**     * Compiler option to remove integer checks. Default: false.     */    private boolean removeIntChecks = false;    /**     * Require explicit declaration of variables? Default: false.     */    private boolean optionExplicit = false;    /**     * Enforce strict language semantics? Default: false.     */    private boolean optionStrict = false;    /**     * Whether to compare strings as "text" or "binary". Default: "binary".     */    private String optionCompare;    /**     * Root namespace for all type declarations.     */    private String rootNamespace;    /**     * Declare global imports fornamespaces in referenced metadata files.     */    private String imports;    /**     * Constructor for VisualBasicCompile.     */    public VisualBasicCompile() {        clear();    }    /**     *  reset all contents.     */    public void clear() {        super.clear();        imports = null;        rootNamespace = null;        optionCompare = null;        optionExplicit = false;        optionStrict = false;        removeIntChecks = false;        setExecutable("vbc");    }    /**     *  get the argument or null for no argument needed     *  This is overridden from DotnetCompile.java because VBC uses     *  "/win32resource:" rather than "/win32res:"     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (getWin32Res() != null) {            return "/win32resource:" + getWin32Res().toString();        } else {            return null;        }    }    /**     * Whether to remove integer checks. Default false.     * @param  flag  on/off flag     */    public void setRemoveIntChecks(boolean flag) {        removeIntChecks = flag;    }    /**     * Get the flag for removing integer checks.     * @return    true if flag is turned on     */    public boolean getRemoveIntChecks() {        return removeIntChecks;    }    /**     * Form the option string for removeIntChecks.     * @return The parameter string.     */    public String getRemoveIntChecksParameter() {        return "/removeintchecks" + (removeIntChecks ? "+" : "-");    }    /**     * Whether to require explicit declaration of variables.     * @param  flag  on/off flag     */    public void setOptionExplicit(boolean flag) {        optionExplicit = flag;    }    /**     * Get the flag for whether to require explicit declaration of variables.     *@return    true if flag is turned on     */    public boolean getOptionExplicit() {        return optionExplicit;    }    /**     * Form the option string for optionExplicit..     * @return The parameter string.     */    public String getOptionExplicitParameter() {        return "/optionexplicit" + (optionExplicit ? "+" : "-");    }    /**     * Enforce strict language semantics.     * @param  flag  on/off flag     */    public void setOptionStrict(boolean flag) {        optionStrict = flag;    }    /**     * Get the flag for whether to enforce strict language semantics.     * @return    true if flag is turned on     */    public boolean getOptionStrict() {        return optionStrict;    }    /**     * For the option string for optionStrict.     * @return The parameter string.     */    public String getOptionStrictParameter() {        return "/optionstrict" + (optionStrict ? "+" : "-");    }    /**     * Specifies the root namespace for all type declarations.     * @param rootNamespace a root namespace.     */    public void setRootNamespace(String rootNamespace) {        this.rootNamespace = rootNamespace;    }    /**     * Get the root namespace.     * @return  the root namespace.     */    public String getRootNamespace() {        return this.rootNamespace;    }    /**     * Form the option string for rootNamespace.     * @return  the root namespace option string.     */    protected String getRootNamespaceParameter() {        if (rootNamespace != null && rootNamespace.length() != 0) {            return "/rootnamespace:" + rootNamespace;        } else {            return null;        }    }    /**     * Declare global imports for namespaces in referenced metadata files.     * @param imports the imports string     */    public void setImports(String imports) {        this.imports = imports;    }    /**     * Get global imports for namespaces in referenced metadata files.     * @return  the imports string.     */    public String getImports() {        return this.imports;    }    /**     * Format the option for imports.     * @return  the formatted import option.     */    protected String getImportsParameter() {        if (imports != null && imports.length() != 0) {            return "/imports:" + imports;        } else {            return null;        }    }    /**     * Specify binary- or text-style string comparisons. Defaults     * to "binary"     * @param optionCompare the option compare style. "text" | "binary".     */    public void setOptionCompare(String optionCompare) {        if ("text".equalsIgnoreCase(optionCompare)) {            this.optionCompare = "text";        } else {            this.optionCompare = "binary";        }    }    /**     * "binary" or "text" for the string-comparison style.     * @return  the option compare style.     */    public String getOptionCompare() {        return this.optionCompare;    }    /**     * Format the option for string comparison style.     * @return  The formatted option.     */    protected String getOptionCompareParameter() {        if (optionCompare != null && "text".equalsIgnoreCase(optionCompare)) {            return "/optioncompare:text";        } else {            return "/optioncompare:binary";        }    }    /**     * implement VBC commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getRemoveIntChecksParameter());        command.addArgument(getImportsParameter());        command.addArgument(getOptionExplicitParameter());        command.addArgument(getOptionStrictParameter());        command.addArgument(getRootNamespaceParameter());        command.addArgument(getOptionCompareParameter());    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ",";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return "vb";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, false);    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import java.util.Iterator;import java.net.MalformedURLException;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.util.FileUtils;/** * Converts a WSDL file or URL resource into a .NET language. * * Why add a wrapper to the MS WSDL tool? * So that you can verify that your web services, be they written with Axis or *anyone else's SOAP toolkit, work with .NET clients. * *This task is dependency aware when using a file as a source and destination; *so if you &lt;get&gt; the file (with <code>usetimestamp="true"</code>) then *you only rebuild stuff when the WSDL file is changed. Of course, *if the server generates a new timestamp every time you ask for the WSDL, *this is not enough...use the &lt;filesmatch&gt; &lt;condition&gt; to *to byte for byte comparison against a cached WSDL file then make *the target conditional on that test failing. * See "Creating an XML Web Service Proxy", "wsdl.exe" docs in * the framework SDK documentation * @version     0.5 * @ant.task    category="dotnet" * @since       Ant 1.5 */public class WsdlToDotnet extends Task  {    /**     * used for timestamp checking     */    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * name of output file (required)     */    private File destFile = null;    /**     * language; defaults to C#     */    private String language = "CS";    /**     * flag set to true to generate server side skeleton     */    private boolean server = false;    /**     * namespace     */    private String namespace = null;    /**     *  flag to control action on execution trouble     */    private boolean failOnError = true;    /**     *  any extra command options?     */    protected String extraOptions = null;    /**     * protocol string. Exact value set depends on SOAP stack version.     * @since Ant 1.7     */    private String protocol = null;    /**     * should errors come in an IDE format. This     * is WSE only.     * @since Ant 1.7     */    private boolean ideErrors = false;    /**     * filesets of file to compile     * @since Ant 1.7     */    private Vector schemas = new Vector();    /**     * our WSDL file.     * @since ant1.7     */    private Schema wsdl = new Schema();    /**     * compiler     * @since ant1.7     */    private Compiler compiler = null;    /**     * error message: dest file is a directory     */    public static final String ERROR_DEST_FILE_IS_DIR = "destination file is a directory";    /**     * error message: no dest file     */    public static final String ERROR_NO_DEST_FILE = "destination file must be specified";    /**     * Name of the file to generate. Required     * @param destFile filename     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * Sets the URL to fetch. Fetching is by wsdl.exe; Ant proxy settings     * are ignored; either url or srcFile is required.     * @param url url to save     */    public void setUrl(String url) {        wsdl.setUrl(url);    }    /**     * The local WSDL file to parse; either url or srcFile is required.     * @param srcFile WSDL file     */    public void setSrcFile(File srcFile) {        wsdl.setFile(srcFile);    }    /**     * set the language; one of "CS", "JS", or "VB"     * optional, default is CS for C# source     * @param language language to generate     */    public void setLanguage(String language) {        this.language = language;    }    /**     * flag to enable server side code generation;     * optional, default=false     * @param server server-side flag     */    public void setServer(boolean server) {        this.server = server;    }    /**     * namespace to place  the source in.     * optional; default ""     * @param namespace new namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * Whether or not a failure should halt the build.     * Optional - default is <code>true</code>.     * @param failOnError new failure option     */    public void setFailOnError(boolean failOnError) {        this.failOnError = failOnError;    }    /**     *  Any extra WSDL.EXE options which aren't explicitly     *  supported by the ant wrapper task; optional     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * Defines wether errors are machine parseable.     * Optional, default=true     *     * @since Ant 1.7     * @param ideErrors     */    public void setIdeErrors(boolean ideErrors) {        this.ideErrors = ideErrors;    }    /**     * what protocol to use. SOAP, SOAP1.2, HttpPost and HttpGet     * are the base options. Different version and implementations may.     * offer different options.     * @since Ant 1.7     *     * @param protocol     */    public void setProtocol(String protocol) {        this.protocol = protocol;    }    /**     * add a new source schema to the compilation     * @since Ant 1.7     *     * @param source     */    public void addSchema(Schema source) {        schemas.add(source);    }    /**     * flag to trigger turning a filename into a file:url     * ignored for the mono compiler.     * @param b     */    public void setMakeURL(boolean b) {        wsdl.setMakeURL(b);    }    /**     * identify the compiler     * @since Ant 1.7     * @param compiler     */    public void setCompiler(Compiler compiler) {        this.compiler = compiler;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException(ERROR_NO_DEST_FILE);        }        if (destFile.isDirectory()) {            throw new BuildException(                    ERROR_DEST_FILE_IS_DIR);        }        wsdl.validate();    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        if ("WsdlToDotnet".equals(getTaskType())) {            log("Warning: the task name <WsdlToDotnet> is deprecated. Use <wsdltodotnet> (all lowercase) instead.", Project.MSG_WARN);        }        if (compiler == null) {            compiler = Compiler.createDefaultCompiler();        }        validate();        NetCommand command = new NetCommand(this,                "WSDL",                compiler.getCommand());        command.setFailOnError(failOnError);        //fill in args        compiler.applyExtraArgs(command);        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/language:", language);        if (server) {            command.addArgument("/server");        }        command.addArgument("/namespace:", namespace);        if (protocol != null) {            command.addArgument("/protocol:" + protocol);        }        if (ideErrors) {            command.addArgument("/parsableErrors");        }        command.addArgument(extraOptions);        //set source and rebuild options        boolean rebuild = true;        long destLastModified = -1;        //rebuild unless the dest file is newer than the source file        if (destFile.exists()) {            destLastModified = destFile.lastModified();            rebuild = isRebuildNeeded(wsdl, destLastModified);        }        String path;        //mark for a rebuild if the dest file is newer        path = wsdl.evaluate();        if (!compiler.supportsAbsoluteFiles() && wsdl.getFile() != null) {            // Mono 1.0's wsdl doesn't deal with absolute paths            File f = wsdl.getFile();            command.setDirectory(f.getParentFile());            path = f.getName();        }        command.addArgument(path);        //add in any extra files.        //this is an error in mono, but we do not warn on it as they may fix that outside        //the ant build cycle.        Iterator it = schemas.iterator();        while (it.hasNext()) {            Schema schema = (Schema) it.next();            //mark for a rebuild if we are newer            rebuild |= isRebuildNeeded(schema, destLastModified);            command.addArgument(schema.evaluate());        }        //conditionally compile        if (rebuild) {            command.runCommand();        }    }    /**     * checks for a schema being out of data     * @param schema url/file     * @param destLastModified timestamp, -1 for no dest     * @return true if a rebuild is needed.     */    private boolean isRebuildNeeded(Schema schema, long destLastModified) {        if (destLastModified == -1) {            return true;        }        return !FILE_UTILS.isUpToDate(schema.getTimestamp(), destLastModified);    }    /**     * nested schema class     * Only supported on NET until mono add multi-URL handling on the command line     */    public static class Schema {        private File file;        private String url;        private boolean makeURL = false;        public static final String ERROR_NONE_DECLARED = "One of file and url must be set";        public static final String ERROR_BOTH_DECLARED = "Only one of file or url can be set";        public static final String ERROR_FILE_NOT_FOUND = "Not found: ";        public static final String ERROR_FILE_IS_DIR = "File is a directory: ";        public static final String ERROR_NO_URL_CONVERT = "Could not URL convert ";        /**         * validate the schema         */        public  void validate() {            if (file != null) {                if (!file.exists()) {                    throw new BuildException(ERROR_FILE_NOT_FOUND + file.toString());                }                if (file.isDirectory()) {                    throw new BuildException(ERROR_FILE_IS_DIR + file.toString());                }            }            if (file != null && url != null) {                throw new BuildException(ERROR_BOTH_DECLARED);            }            if (file == null && url == null) {                throw new BuildException(ERROR_NONE_DECLARED);            }        }        /**         * Validate our settings.         * @return either the URL or the full file path         */        public String evaluate() {            validate();            if (url != null) {                return getUrl();            }            if (makeURL) {                try {                    return file.toURL().toExternalForm();                } catch (MalformedURLException e) {                    throw new BuildException(ERROR_NO_URL_CONVERT + file);                }            }            return file.toString();        }        public File getFile() {            return file;        }        /**         * name of a file to use as a source of WSDL or XSD data         * @param file         */        public void setFile(File file) {            this.file = file;        }        public String getUrl() {            return url;        }        /**         * url of a resource.         * URLs have no timestamp checking, and are not validated         * @param url         */        public void setUrl(String url) {            this.url = url;        }        public boolean isMakeURL() {            return makeURL;        }        /**         * flag to request that a file is turned into an absolute file: URL         * before being passed to the WSDL compiler         * @param makeURL         */        public void setMakeURL(boolean makeURL) {            this.makeURL = makeURL;        }        /**         * Gets the file timestamp.         * @return the timestamp of a file, or -1 for a URL (meaning we do not know its age)         */        public long getTimestamp() {            if (file != null) {                return file.lastModified();            } else {                return -1;            }        }    }    /**     * The enumerated values for our compiler     */    public static class Compiler extends EnumeratedAttribute {        public static final String COMPILER_MS = "microsoft";        public static final String COMPILER_MONO = "mono";        public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono";        String[] compilers = {            COMPILER_MS,            COMPILER_MONO,            COMPILER_MS_ON_MONO        };        public static final String EXE_WSDL = "wsdl";        public static final String EXE_MONO = "mono";        /**         * programs to run         */        String[] compilerExecutables = {            EXE_WSDL,            EXE_WSDL,            EXE_MONO        };        /**         * extra things         */        String[][] extraCompilerArgs = {            {},            {},            {EXE_WSDL + ".exe"}        };        boolean[] absoluteFiles = {            true,            false,            true        };        /**         * This is the only method a subclass needs to implement.         *         * @return an array holding all possible values of the enumeration.         *         The order of elements must be fixed so that <tt>indexOfValue(String)</tt>         *         always return the same index for the same value.         */        public String[] getValues() {            return compilers;        }        /**         * Create the default compiler for this platform.         * @return the default compiler         */        public static Compiler createDefaultCompiler() {            Compiler c = new Compiler();            String compilerName;            compilerName = Os.isFamily("windows") ? COMPILER_MS : COMPILER_MONO;            c.setValue(compilerName);            return c;        }        /**         * return the command to run         * @return the command         */        public String getCommand() {            return compilerExecutables[getIndex()];        }        /**         * return any extra arguments for the compiler         * @return extra compiler arguments         */        public String[] getExtraArgs() {            return extraCompilerArgs[getIndex()];        }        public boolean supportsAbsoluteFiles() {            return absoluteFiles[getIndex()];        }        /**         * apply any extra arguments of this class         * @param command         */        public void applyExtraArgs(NetCommand command) {            String[] args = getExtraArgs();            for (int i = 0; i < args.length; i++) {               command.addArgument(args[i]);            }        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.wix;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.ant.dotnet.build.AbstractBuildTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;import java.io.File;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;/** * Task to run the WiX utility to create MSI files from an XML description. * * @see http://sf.net/projects/wix */public class WixTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source files.     */    private ArrayList sources = new ArrayList();    /**     * Additional source files (include files in the case of candle,     * or media/files/whatever in the case of light).     */    private ArrayList moreSources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * What to do.     */    private Mode mode;    /**     * Where is WiX installed?     */    private File wixHome = null;    /**     * Where to place the generated .wixobj files.     */    private File wixobjDestDir = null;    /**     * list of parameters for the preprocessor.     */    private ArrayList parameters = new ArrayList();    public WixTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>candle</code> may include more files than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * The main target file.     *     * @param File object of the main target file.     */    public void setTarget(File f) {        target = f;    }    /**     * A set of source files.     */    public void addSources(FileSet fs) {        sources.add(fs);    }    /**     * A set of additional source files (include files in the case of     * candle, or media/files/whatever in the case of light).     *     * <p>Unlike the files specified as sources, these will not be     * passed on the command line, they only help Ant to determine     * whether the target is out-of-date.</p>     */    public void addMoreSources(FileSet fs) {        moreSources.add(fs);    }    /**     * Sets the installation directory of WiX.     *     * <p>If omitted, Ant will assume that WiX's executables can be     * found on the PATH.</p>     */    public void setWixHome(File f) {        wixHome = f;    }    /**     * Whether to run candle, light or both.     */    public void setMode(Mode m) {        mode = m;    }    /**     * Sets the destination directory for wixobj files generated by candle.     *     * <p>Let's candle decide and assumes they'll be created in the     * current working directory.</p>     */    public void setWixobjDestDir(File f) {        wixobjDestDir = f;    }    /**     * A parameter to pass to candle.exe.     */    public final void addCandleParameter(AbstractBuildTask.Property t) {        parameters.add(t);    }    public void execute() {        if (source == null && sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        }        if (source != null && !source.exists()) {            throw new BuildException("Source file " + source                                     + " doesn't exist.");        }        String m = Mode.BOTH;        if (mode != null) {            m = mode.getValue();        }        if (target == null && !m.equals(Mode.CANDLE)) {            throw new BuildException("You must specify the target if you want"                                     + " to run light.");        }        Collection lightSources = null;        if (!m.equals(Mode.LIGHT)) {            lightSources = doCandle();        } else {            lightSources = new HashSet();            if (source != null) {                lightSources.add(source);            }            if (sources.size() > 0) {                lightSources.addAll(grabFiles(sources));            }        }        if (!m.equals(Mode.CANDLE)) {            Collection moreLightSources = Collections.EMPTY_SET;            if (moreSources.size() > 0) {                moreLightSources = grabFiles(moreSources);            }            doLight(lightSources, moreLightSources);        }    }    /**     * Invoke candle on all sources that are newer than their targets.     *     * @return a set of File objects pointing to the generated files.     */    private Collection doCandle() {        Set s = new HashSet();        if (source != null) {            s.add(source);        }        if (sources != null) {            s.addAll(grabFiles(sources));        }        Set ms = new HashSet();        if (moreSources != null) {            ms.addAll(grabFiles(moreSources));        }        Set toProcess = new HashSet();        Set generatedTargets = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            File thisSource = (File) iter.next();            File t = getTarget(thisSource);            generatedTargets.add(t);            if (isOutOfDate(t, thisSource, ms)) {                toProcess.add(thisSource);            }        }        if (toProcess.size() != 0) {            runCandle(toProcess);            return generatedTargets;        }        return Collections.EMPTY_SET;    }    /**     * Invoke light on all sources that are newer than their targets.     */    private void doLight(Collection lightSources,                         Collection moreLightSources) {        Set tmp = new HashSet(lightSources);        tmp.addAll(moreLightSources);        if (isOutOfDate(target, tmp)) {            runLight(lightSources);        }    }    /**     * Run candle passing all files of the collection on the command line.     */    private void runCandle(Collection s) {        run(wixExecutable("candle.exe"), s, null, wixobjDestDir, parameters);    }    /**     * Run light passing all files of the collection on the command line.     */    private void runLight(Collection s) {        run(wixExecutable("light.exe"), s, target, null, Collections.EMPTY_LIST);    }    /**     * returns an absolute path for the given executable if wixHome     * has been specified, the given name otherwise.     */    private String wixExecutable(String name) {        return wixHome == null ? name            : new File(wixHome, name).getAbsolutePath();    }    /**     * Runs the specified command passing all files of the collection     * on the command line - potentially adding an /out parameter.     */    private void run(String executable, Collection s, File target,                     File runInDir, Collection params) {        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      executable, null);        if (runInDir != null) {            exec.setDir(runInDir);        }        exec.setFailonerror(true);        exec.setTaskType("wix");        exec.createArg().setValue("/nologo");        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue(f.getAbsolutePath());        }        if (target != null) {            exec.createArg().setValue("/out");            exec.createArg().setValue(target.getAbsolutePath());        }                iter = params.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                (AbstractBuildTask.Property) iter.next();            exec.createArg().setValue("-d" + p.getName() + "=" + p.getValue());        }        exec.execute();    }    /**     * Is t older than s or any of the files in list?     */    private boolean isOutOfDate(File t, File s, Collection l) {        return t.lastModified() < s.lastModified() || isOutOfDate(t, l);    }    /**     * Is t older than any of the files in list?     */    private boolean isOutOfDate(File t, Collection l) {        Iterator iter = l.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            if (t.lastModified() < f.lastModified()) {                return true;            }        }        return false;    }    /**     * Turn the fileset collection into a list of Files.     */    private Collection grabFiles(Collection s) {        Set r = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            FileSet fs = (FileSet) iter.next();            DirectoryScanner ds = fs.getDirectoryScanner(getProject());            String[] f = ds.getIncludedFiles();            File base = fs.getDir(getProject());            for (int i = 0; i < f.length; i++) {                r.add(new File(base, f[i]));            }        }        return r;    }    /**     * Generates the name of a candle target from the source file.     *     * <p>Simply chops of the extension, adds .wixobj and calculates     * the absolute path based on wixobjDestDir.</p>     */    private File getTarget(File s) {        String name = s.getName();        int dot = name.lastIndexOf(".");        if (dot > -1) {            name = name.substring(0, dot) + ".wixobj";        } else {            name = name + ".wixobj";        }        return wixobjDestDir == null            ? new File(name) : new File(wixobjDestDir, name);    }    public static class Mode extends EnumeratedAttribute {        private final static String CANDLE = "candle";        private final static String LIGHT = "light";        private final static String BOTH = "both";        public Mode() {            super();        }        public String[] getValues() {            return new String[] {CANDLE, LIGHT, BOTH,};        }    }}
Apache .NET Ant Library/*  *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. *  */ /** * this is a j# class, not a java one. */public class jsharp {        public static void main(String args[]) {		System.out.println("hello, I look like Java, but I'm really J#");    }    }
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.taskdefs.ExecTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.Environment;/** * Specialized <exec> that knows how to deal with Mono vs. Microsoft's * VM - and maybe Rotor at some point. */public class DotNetExecTask extends ExecTask {    /**     * "Magic" VM argument for Microsoft's VM.     */    private static final String MS_VM = "microsoft";    /**     * The user supplied executable attribute.     */    private String executable;    /**     * The .NET VM to use.     *     * <p>Defaults to Microsoft's on Windows and mono on any other     * platform.</p>     */    private String vm = Os.isFamily("windows") ? MS_VM : "mono";    /**     * Empty Constructor.     */    public DotNetExecTask() {        super();    }    /**     * Set the name of the executable program.     * @param value the name of the executable program     */    public void setExecutable(String value) {        this.executable = value;    }    /**     * Set the name of the executable for the virtual machine or the     * magic name "microsoft" which implies that we can invoke the     * executable directly.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Do the work.     *     * @throws BuildException if executable is empty or &lt;exec&gt;     * throws an exception.     */    public void execute() throws BuildException {        if (executable == null) {            throw new BuildException("The executable attribute is required");        }        setupCommandline();        super.execute();    }    /**     * If the inherited Commandline doesn't know about the executable     * yet, set it and deal with the vm attribute.     *     * <p>The inherited Commandline may know the executable already if     * this task instance is getting reused.</p>     */    protected void setupCommandline() {        if (cmdl.getExecutable() == null) {            if (vm.equals(MS_VM)) {                // can invoke executable directly                super.setExecutable(executable);            } else {                boolean b = getResolveExecutable();                // Mono wants the absolte path of the assembly                setResolveExecutable(b || isMono(vm));                super.setExecutable(vm);                cmdl.createArgument(true)                    .setValue(resolveExecutable(executable, isMono(vm)));                setResolveExecutable(b);            }        }    }    /**     * Whether the given vm looks like the Mono executable.     */    protected final static boolean isMono(String vm) {        return "mono".equals(vm) || "mint".equals(vm);    }    /**     * Creates an instance of this task based on a different tasks settings.     */    public static DotNetExecTask getTask(Task t, String vm,                                          String executable,                                         Environment env) {        DotNetExecTask exec = new DotNetExecTask();        if (vm != null) {            exec.setVm(vm);        }        exec.setProject(t.getProject());        exec.setExecutable(executable);        exec.setTaskName(t.getTaskName());        if (env != null) {            String[] environment = env.getVariables();            if (environment != null) {                for (int i = 0; i < environment.length; i++) {                    int idx = environment[i].indexOf("=");                    Environment.Variable v = new Environment.Variable();                    v.setKey(environment[i].substring(0, idx));                    v.setValue(environment[i].substring(idx + 1));                    exec.addEnv(v);                }            }        }                return exec;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Task to take a .NET or Mono -generated managed executable and turn it * into ILASM assembly code. Useful when converting imported typelibs into * assembler before patching and recompiling, as one has to do when doing * advanced typelib work. * <p> * As well as generating the named output file, the ildasm program * will also generate resource files <code>Icons.resources</code> * <code>Message.resources</code> and a .res file whose filename stub is derived * from the source in ways to obscure to determine. * There is no way to control whether or not these files are created, or where they are created * (they are created in the current directory; their names come from inside the * executable and may be those used by the original developer). This task * creates the resources in the directory specified by <code>resourceDir</code> if * set, else in the same directory as the <code>destFile</code>. * * <p> * This task requires the .NET SDK installed and ildasm on the path. * To disassemble using alternate CLR systems, set the executable attribute * to the name/path of the alternate implementation -one that must * support all the classic ildasm commands. * * <p> * Dependency logic: the task executes the command if the output file is missing * or older than the source file. It does not take into account changes * in the options of the task, or timestamp differences in resource files. * When the underlying ildasm executable fails for some reason, it leaves the * .il file in place with some error message. To prevent this from confusing * the dependency logic, the file specified by the <code>dest</code> * attribute is <i>always</i> deleted after an unsuccessful build. * @ant.task category="dotnet" */public class Ildasm extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();        /**     * source file (mandatory)     */    private File sourceFile;    /**     * dest file (mandatory)     */    private File destFile;    /**     * progress bar switch     */    private boolean progressBar = false;    /**     * what is our encoding     */    private String encoding;    /**     * /bytes flag for byte markup     */    private boolean bytes = false;    /**     * line numbers? /linenum     */    private boolean linenumbers = false;    /**     * /raweh flag for raw exception handling     */    private boolean rawExceptionHandling = false;    /**     * show the source; /source     */    private boolean showSource = false;    /**     * /quoteallnames to quote all names     */    private boolean quoteallnames = false;    /**     * /header for header information     */    private boolean header = false;    /**     * when false, sets the /noil attribute     * to suppress assembly info     */    private boolean assembler = true;    /**     * include metadata     * /tokens     */    private boolean metadata = false;    /**     * what visibility do we want.     *     */    private String visibility;    /**     * specific item to disassemble     */    private String item;    /**     * override for the executable     */    private String executable = "ildasm";    /**     *  name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    private File resourceDir;    /**     * Set the name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    public void setResourceDir(File resourceDir) {        this.resourceDir = resourceDir;    }    /**     * override the name of the executable (normally ildasm) or set     * its full path. Do not set a relative path, as the ugly hacks     * needed to create resource files in the dest directory     * force us to change to this directory before running the application.     * i.e use &lt;property location&gt to create an absolute path from a     * relative one before setting this value.     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     * Select the output encoding: ascii, utf8 or unicode     * @param encoding     */    public void setEncoding(EncodingTypes encoding) {        this.encoding = encoding.getValue();    }    /**     * enable (default) or disable assembly language in the output     * @param assembler     */    public void setAssembler(boolean assembler) {        this.assembler = assembler;    }    /**     * enable or disable (default) the original bytes as comments     * @param bytes     */    public void setBytes(boolean bytes) {        this.bytes = bytes;    }    /**     * the output file (required)     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * include header information; default false.     * @param header     */    public void setHeader(boolean header) {        this.header = header;    }    /**     * name a single item to decode; a class or a method     * e.g item="Myclass::method" or item="namespace1::namespace2::Myclass:method(void(int32))     * @param item     */    public void setItem(String item) {        this.item = item;    }    /**     * include line number information; default=false     * @param linenumbers     */    public void setLinenumbers(boolean linenumbers) {        this.linenumbers = linenumbers;    }    /**     * include metadata information     * @param metadata     */    public void setMetadata(boolean metadata) {        this.metadata = metadata;    }    /**     * show a graphical progress bar in a window during the process; off by default     * @param progressBar     */    public void setProgressBar(boolean progressBar) {        this.progressBar = progressBar;    }    /**     * quote all names.     * @param quoteallnames     */    public void setQuoteallnames(boolean quoteallnames) {        this.quoteallnames = quoteallnames;    }    /**     * enable raw exception handling (default = false)     * @param rawExceptionHandling     */    public void setRawExceptionHandling(boolean rawExceptionHandling) {        this.rawExceptionHandling = rawExceptionHandling;    }    /**     * include the source as comments (default=false)     */    public void setShowSource(boolean showSource) {        this.showSource = showSource;    }    /**     * the file to disassemble -required     * @param sourceFile     */    public void setSourceFile(File sourceFile) {        this.sourceFile = sourceFile;    }    /**     * alternate name for sourceFile     * @param sourceFile     */    public void setSrcFile(File sourceFile) {        setSourceFile(sourceFile);    }    /**     * This method sets the visibility options. It chooses one or more of the following, with + signs to     * concatenate them:     * <pre>     * pub : Public     * pri : Private     * fam : Family     * asm : Assembly     * faa : Family and Assembly     * foa : Family or Assembly     * psc : Private Scope     *</pre>     * e.g. visibility="pub+pri".     * Family means <code>protected</code> in C#;     * @param visibility     */    public void setVisibility(String visibility) {        this.visibility = visibility;    }    /**     *  verify that source and dest are ok     */    private void validate() {        if (sourceFile == null || !sourceFile.exists() || !sourceFile.isFile()) {            throw new BuildException("invalid source");        }        if (destFile == null || destFile.isDirectory()) {            throw new BuildException("invalid dest");        }        if (resourceDir != null                && (!resourceDir.exists() || !resourceDir.isDirectory())) {            throw new BuildException("invalid resource directory");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isDisassemblyNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = sourceFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The .il file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * do the work     * @throws BuildException     */    public void execute() throws BuildException {        validate();        if (!isDisassemblyNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ildasm", executable);        command.setFailOnError(true);        //fill in args        command.addArgument("/text");        command.addArgument("/out=" + destFile.toString());        if (!progressBar) {            command.addArgument("/nobar");        }        if (linenumbers) {            command.addArgument("/linenum");        }        if (showSource) {            command.addArgument("/source");        }        if (quoteallnames) {            command.addArgument("/quoteallnames");        }        if (header) {            command.addArgument("/header");        }        if (!assembler) {            command.addArgument("/noil");        }        if (metadata) {            command.addArgument("/tokens");        }        command.addArgument("/item:", item);        if (rawExceptionHandling) {            command.addArgument("/raweh");        }        command.addArgument(EncodingTypes.getEncodingOption(encoding));        if (bytes) {            command.addArgument("/bytes");        }        command.addArgument("/vis:", visibility);        //add the source file        command.addArgument(sourceFile.getAbsolutePath());        //determine directory: resourceDir if set,        //the dir of the destFile if not        File execDir = resourceDir;        if (execDir == null) {            execDir = destFile.getParentFile();        }        command.setDirectory(execDir);        //now run        try {            command.runCommand();        } catch (BuildException e) {            //forcibly delete the output file in case of trouble            if (destFile.exists()) {                log("Deleting destination file as it may be corrupt");                destFile.delete();            }            //then rethrow the exception            throw e;        }    }    /**     * encoding options; the default is ascii     */    public static class EncodingTypes extends EnumeratedAttribute {        public final static String UNICODE = "unicode";        public final static String UTF8 = "utf8";        public final static String ASCII = "ascii";        public String[] getValues() {            return new String[]{                ASCII,                UTF8,                UNICODE,            };        }        /**         * This method maps from an encoding enum to an encoding option.         * @param enumValue         * @return The encoding option indicated by the enum value.         */        public static String getEncodingOption(String enumValue) {            if (UNICODE.equals(enumValue)) {                return "/unicode";            }            if (UTF8.equals(enumValue)) {                return "/utf8";            }            return null;        }    }    /**     * visibility options for decoding     */    public static class VisibilityOptions extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "pub", //Public                "pri", //Private                "fam", //Family                "asm", //Assembly                "faa", //Family and Assembly                "foa", //Family or Assembly                "psc", //Private Scope            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.Task;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Import a COM type library into the .NET framework. * <p> * * This task is a wrapper to .NET's tlbimport; it imports a tlb file to a NET assembly * by generating a binary assembly (.dll) that contains all the binding * metadata. It uses date timestamps to minimise rebuilds. * <p> * Example * <pre> *     &lt;importtypelib *       srcfile="xerces.tlb" *       destfile="xerces.dll" *       namespace="Apache.Xerces"/&gt; * </pre> * @since Ant 1.6 * @ant.task category="dotnet" */public class ImportTypelib extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * input file; precedes options     */    private File srcFile;    /**     * /out:file     */    private File destFile;    /**     *  /namespace:[string]     */    private String namespace;    /**     * /sysarray     */    private boolean useSysArray = false;    /**     * /unsafe     */    private boolean unsafe = false;    /**     * extra commands?     */    private String extraOptions = null;    /**     * This method names the output file.     *     * This is an operation which is required to have been performed.     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * This method sets what namespace the typelib is to be in.     * This is an operation which is required to have been performed.     * @param namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * This method sets which is the source .tlb file.     * This is an operation which is required to have been performed.     * @param srcFile     */    public void setSrcFile(File srcFile) {        this.srcFile = srcFile;    }    /**     * do you want unsafe code.     * @param unsafe     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     * set this to map a COM SafeArray to the System.Array class     * @param useSysArray     */    public void setUseSysArray(boolean useSysArray) {        this.useSysArray = useSysArray;    }    /**     * set any extra options that are not yet supported by this task.     * @param extraOptions     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException("destination file must be specified");        }        if (destFile.isDirectory()) {            throw new BuildException(                    "destination file is a directory");        }        if (srcFile == null || !srcFile.exists()) {            throw new BuildException(                    "source file does not exist");        }        if (srcFile.isDirectory()) {            throw new BuildException(                    "source file is a directory");        }        if (namespace == null) {            throw new BuildException("No namespace");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isExecuteNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = srcFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The output file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * Create a typelib command     * @exception BuildException if something goes wrong with the build     */    public void execute() throws BuildException {        validate();        log("Importing typelib " + srcFile            + " to assembly " + destFile            + " in namespace " + namespace, Project.MSG_VERBOSE);        //rebuild unless the dest file is newer than the source file        if (!isExecuteNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ImportTypelib", "tlbimp");        command.setFailOnError(true);        command.addArgument(srcFile.toString());        //fill in args        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/namespace:", namespace);        if (useSysArray) {            command.addArgument("/sysarray");        }        if (unsafe) {            command.addArgument("/unsafe");        }        command.addArgument(extraOptions);        command.runCommand();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  The reference CD to listen to while editing this file is *  Underworld Everything, Everything *  variable naming policy from Fowler's refactoring book. */// place below the optional ant tasks packagepackage org.apache.ant.dotnet;// importsimport java.io.File;import java.io.IOException;import java.io.FileOutputStream;import java.io.PrintWriter;import java.io.BufferedOutputStream;import java.util.Hashtable;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.taskdefs.Execute;import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;import org.apache.tools.ant.taskdefs.LogStreamHandler;import org.apache.tools.ant.types.Commandline;/** *  This is a helper class to spawn net commands out. In its initial form it *  contains no .net specifics, just contains all the command line/exe *  construction stuff. However, it may be handy in future to have a means of *  setting the path to point to the dotnet bin directory; in which case the *  shared code should go in here. * *@version    0.5 */public class NetCommand {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     *  owner project     */    protected Task owner;    /**     *  executable     */    protected Execute executable;    /**     *  what is the command line     */    protected Commandline commandLine;    /**     *  title of the command     */    protected String title;    /**     *  actual program to invoke     */    protected String program;    /**     *  trace flag     */    protected boolean traceCommandLine = false;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     * the directory to execute the command in. When null, the current     * directory is used.     */    private File directory;    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    /**     * name of a temp file; may be null     */    private File temporaryCommandFile;    /**     * internal threshold for auto-switch     */    private int automaticResponseFileThreshold = 64;    /**     *  constructor     *     *@param  title        (for logging/errors)     *@param  owner        owner task     *@param  program      app we are to run     */    public NetCommand(Task owner, String title, String program) {        this.owner = owner;        this.title = title;        this.program = program;        commandLine = new Commandline();        commandLine.setExecutable(program);    }    /**     *  turn tracing on or off     *     *@param  b  trace flag     */    public void setTraceCommandLine(boolean b) {        traceCommandLine = b;    }    /**     *  set fail on error flag     *     *@param  b  fail flag -set to true to cause an exception to be raised if     *      the return value != 0     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailFailOnError() {        return failOnError;    }    /**     * set the directory to run from, if the default is inadequate     * @param directory     */    public void setDirectory(File directory) {        this.directory = directory;    }    /**     *  verbose text log     *     *@param  msg  string to add to log if verbose is defined for the build     */    protected void logVerbose(String msg) {        owner.getProject().log(msg, Project.MSG_VERBOSE);    }    /**     *  error text log     *     *@param  msg  message to display as an error     */    protected void logError(String msg) {        owner.getProject().log(msg, Project.MSG_ERR);    }    /**     *  add an argument to a command line; do nothing if the arg is null or     *  empty string     *     *@param  argument  The feature to be added to the Argument attribute     */    public void addArgument(String argument) {        if (argument != null && argument.length() != 0) {            commandLine.createArgument().setValue(argument);        }    }    /**     *  add an argument to a command line; do nothing if the arg is null or     *  empty string     *     *@param  arguments  The features to be added to the Argument attribute     */    public void addArguments(String[] arguments) {        if (arguments != null && arguments.length != 0) {            for (int i = 0; i < arguments.length; i++) {                addArgument(arguments[i]);            }        }    }    /**     *  concatenate two strings together and add them as a single argument,     *  but only if argument2 is non-null and non-zero length     *     *@param  argument1  The first argument     *@param  argument2  The second argument     */    public void addArgument(String argument1, String argument2) {        if (argument2 != null && argument2.length() != 0) {            commandLine.createArgument().setValue(argument1 + argument2);        }    }    /**     * getter     * @return response file state     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * set this to true to always use the response file     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     * getter for threshold     * @return 0 for disabled, or a threshold for enabling response files     */    public int getAutomaticResponseFileThreshold() {        return automaticResponseFileThreshold;    }    /**     * set threshold for automatically using response files -use 0 for off     * @param automaticResponseFileThreshold     */    public void setAutomaticResponseFileThreshold(int automaticResponseFileThreshold) {        this.automaticResponseFileThreshold = automaticResponseFileThreshold;    }    /**     *  set up the command sequence..     */    protected void prepareExecutor() {        // default directory to the project's base directory        if (owner == null) {            throw new RuntimeException("no owner");        }        if (owner.getProject() == null) {            throw new RuntimeException("Owner has no project");        }        File dir = owner.getProject().getBaseDir();        if (directory != null) {            dir = directory;        }        ExecuteStreamHandler handler = new LogStreamHandler(owner,                Project.MSG_INFO, Project.MSG_WARN);        executable = new Execute(handler, null);        executable.setAntRun(owner.getProject());        executable.setWorkingDirectory(dir);    }    /**     *  Run the command using the given Execute instance.     *     *@exception  BuildException  if something goes wrong and the     *      failOnError flag is true     */    public void runCommand()             throws BuildException {        prepareExecutor();        int err = -1;        // assume the worst        try {            if (traceCommandLine) {                owner.log("In directory " + executable.getWorkingDirectory());                owner.log(commandLine.describeCommand());            } else {                //in verbose mode we always log stuff                logVerbose("In directory " + executable.getWorkingDirectory());                logVerbose(commandLine.describeCommand());            }            setExecutableCommandLine();            err = executable.execute();            if (Execute.isFailure(err)) {                if (failOnError) {                    throw new BuildException(title + " returned: " + err, owner.getLocation());                } else {                    owner.log(title + "  Result: " + err, Project.MSG_ERR);                }            }        } catch (IOException e) {            throw new BuildException(title + " failed: " + e, e, owner.getLocation());        } finally {            if (temporaryCommandFile != null) {                temporaryCommandFile.delete();            }        }    }    /**     * set the executable command line     */    private void setExecutableCommandLine() {        String[] commands = commandLine.getCommandline();        //always trigger file mode if commands are big enough        if (automaticResponseFileThreshold > 0            && commands.length > automaticResponseFileThreshold) {            useResponseFile = true;        }        if (!useResponseFile || commands.length <= 1) {            //the simple action is to send the command line in as is            executable.setCommandline(commands);        } else {            //but for big operations, we save all the params to a temp file            //and set @tmpfile as the command -then we remember to delete the tempfile            //afterwards            FileOutputStream fos = null;            temporaryCommandFile = FILE_UTILS.createTempFile("cmd", ".txt", null);            owner.log("Using response file " + temporaryCommandFile, Project.MSG_VERBOSE);            try {                fos = new FileOutputStream(temporaryCommandFile);                PrintWriter out = new PrintWriter(new BufferedOutputStream(fos));                //start at 1 because element 0 is the executable name                for (int i = 1; i < commands.length; ++i) {                    out.println(commands[i]);                }                out.flush();                out.close();            } catch (IOException ex) {                throw new BuildException("saving command stream to " + temporaryCommandFile, ex);            }            String newCommandLine[] = new String[2];            newCommandLine[0] = commands[0];            newCommandLine[1] = "@" + temporaryCommandFile.getAbsolutePath();            logVerbose(Commandline.describeCommand(newCommandLine));            executable.setCommandline(newCommandLine);        }    }    /**     * scan through one fileset for files to include     * @param scanner     * @param filesToBuild     * @param outputTimestamp timestamp to compare against     * @return #of files out of date     * @todo: should FAT granularity be included here?     */    public int scanOneFileset(DirectoryScanner scanner, Hashtable filesToBuild,                                        long outputTimestamp) {        int filesOutOfDate = 0;        String[] dependencies = scanner.getIncludedFiles();        File base = scanner.getBasedir();        //add to the list        for (int i = 0; i < dependencies.length; i++) {            File targetFile = new File(base, dependencies[i]);            if (filesToBuild.get(targetFile) == null) {                filesToBuild.put(targetFile, targetFile);                if (targetFile.lastModified() > outputTimestamp) {                    filesOutOfDate++;                    owner.log(targetFile.toString() + " is out of date",                              Project.MSG_VERBOSE);                } else {                    owner.log(targetFile.toString(),                              Project.MSG_VERBOSE);                }            }        }        return filesOutOfDate;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Environment;import org.apache.tools.ant.types.RedirectorElement;import java.io.File;import java.util.ArrayList;import java.util.Iterator;/** * Task to run the NUnit Console test runner. * * @see http://www.nunit.org/ */public class NUnitTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * Test assemblies.     */    private ArrayList testAssemblies = new ArrayList();    /**     * The /config argument.     */    private File configFile;    /**     * The /output argument.     */    private File out;    /**     * The /err argument.     */    private File err;    /**     * The /xml argument.     */    private File xmlOut;    /**     * The /transform argument.     */    private File transform;    /**     * The /thread argument.     */    private boolean thread = false;    /**     * The /fixture argument.     */    private String fixture;    /**     * Categories to include.     */    private ArrayList includes = new ArrayList();    /**     * Categories to exclude.     */    private ArrayList excludes = new ArrayList();    /**     * The /noshadow argument.     */    private boolean noshadow = false;    /**     * The /labels argument.     */    private boolean labels = false;    /**     * Redirects everything that NUnit wants to send to the console.     */    private RedirectorElement redirectorElement;    /**     * Whether a failure should stop the build.     */    private boolean failOnError = false;    /**     * Support for nested environment variables.     */    private Environment env = new Environment();    public NUnitTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the config file.     */    public void setConfig(File c) {        configFile = c;    }    /**     * The /output argument.     */    public void setOut(File out) {        this.out = out;    }    /**     * The /err argument.     */    public void setError(File err) {        this.err = err;    }    /**     * The /xml argument.     */    public void setXmlOut(File out) {        this.xmlOut = out;    }    /**     * The /transform argument.     */    public void setTransform(File transform) {        this.transform = transform;    }    /**     * The /thread argument.     */    public void setThread(boolean thread) {        this.thread = thread;    }    /**     * The /fixture argument.     */    public void setFixture(String fixture) {        this.fixture = fixture;    }    /**     * The /noshadow argument.     */    public void setNoshadow(boolean noshadow) {        this.noshadow = noshadow;    }    /**     * The /labels argument.     */    public void setLabels(boolean labels) {        this.labels = labels;    }    /**     * Whether a failure should stop the build.     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Adds a test assembly by name.     */    public void addTestAssembly(NamedElement a) {        testAssemblies.add(a);    }    /**     * Adds a category to the include list.     */    public void addInclude(NamedElement a) {        includes.add(a);    }    /**     * Adds a category to the exclude list.     */    public void addExclude(NamedElement a) {        excludes.add(a);    }    /**     * Add an environment variable to the launched process.     *     * @param var new environment variable     */    public void addEnv(Environment.Variable var) {        env.addVariable(var);    }    /**     * Add a <code>RedirectorElement</code> to this task.     *     * <p>This does not use the <code>out</code> and     * <code>error</code> attributes, it only captures NUnits output     * that has not been redirected by those attributes.</p>     */    public void addConfiguredRedirector(RedirectorElement redirectorElement) {        if (this.redirectorElement != null) {            throw new BuildException("cannot have > 1 nested <redirector>s");        } else {            this.redirectorElement = redirectorElement;        }    }    public void execute() {        if (testAssemblies.size() == 0) {            throw new BuildException("You must specify at least one test "                                     + "assembly.");        }                DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      "nunit-console.exe",                                                     env);        Iterator iter = testAssemblies.iterator();        while (iter.hasNext()) {            NamedElement a = (NamedElement) iter.next();            exec.createArg().setValue(a.getName());        }        if (configFile != null) {            exec.createArg().setValue("/config="                                       + configFile.getAbsolutePath());        }        exec.createArg().setValue("/nologo");        if (out != null) {            exec.createArg().setValue("/output=" + out.getAbsolutePath());        }        if (err != null) {            exec.createArg().setValue("/err=" + err.getAbsolutePath());        }        if (xmlOut != null) {            exec.createArg().setValue("/xml=" + xmlOut.getAbsolutePath());        }        if (transform != null) {            exec.createArg().setValue("/transform="                                       + transform.getAbsolutePath());        }        if (thread) {            exec.createArg().setValue("/thread");        }        if (noshadow) {            exec.createArg().setValue("/noshadow");        }        if (labels) {            exec.createArg().setValue("/labels");        }        if (fixture != null) {            exec.createArg().setValue("/fixture=" + fixture);        }                if (includes.size() > 0) {            StringBuffer sb = new StringBuffer("/include=");            iter = includes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (excludes.size() > 0) {            StringBuffer sb = new StringBuffer("/exclude=");            iter = excludes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (redirectorElement != null) {            exec.addConfiguredRedirector(redirectorElement);        }        exec.setFailonerror(failOnError);        exec.execute();    }    public static class NamedElement {        private String name;        public String getName() {return name;}        public void setName(String s) {name = s;}    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.util.DOMElementWriter;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.XMLFragment;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Base class for NAntTask and MSBuildTask. */public abstract class AbstractBuildTask extends Task {    /**     * The buildfile to invoke the build tool for.     */    private File buildFile;    /**     * The targets to execute.     */    private List targets = new ArrayList();    /**     * Properties to set.     */    private List properties = new ArrayList(1);    /**     * Nested build file fragment.     */    private XMLFragment buildSnippet;    /**     * The vm attribute - if given.     */    private String vm;    /**     * Empty constructor.     */    protected AbstractBuildTask() {    }    /**     * Sets the name of the build file.     */    public final void setBuildfile(File f) {        buildFile = f;    }    /**     * Adds a build file fragment.     */    public void addBuild(XMLFragment f) {        if (buildSnippet == null) {            buildSnippet = f;        } else {            throw new BuildException("You must not specify more than one "                                     + "build element");        }    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * A target.     */    public static class Target {        private String name;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }    }    /**     * A target to execute.     */    public final void addTarget(Target t) {        targets.add(t);    }    /**     * A property.     */    // XXX, could have reused Property or Environment.Variable     //      - not decided so far    public static class Property {        private String name;        private String value;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public void setValue(String value) {            this.value = value;        }        public String getValue() {            return value;        }    }    /**     * A target to execute.     */    public final void addProperty(Property t) {        properties.add(t);    }    /**     * Must return the executable.     *     * @return must not return null     */    protected abstract String getExecutable();    /**     * Must return buildfile argument(s).     *     * @param buildFile the absolute File for the buildfile or null if     * the user didn't specify a buildfile.     *     * @return must not return null     */    protected abstract String[] getBuildfileArguments(File buildFile);    /**     * Must return target argument(s).     *     * @return must not return null     */    protected abstract String[] getTargetArguments(List targets);    /**     * Must return property argument(s).     *     * @return must not return null     */    protected abstract String[] getPropertyArguments(List properties);    /**     * Turn the DoucmentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>Must throw a BuildException if the snippet can not be turned     * into a build file.</p>     */    protected abstract Element makeTree(DocumentFragment f);    /**     * Perform the build.     */    public void execute() {        if (buildFile != null && buildSnippet != null) {            throw new BuildException("You must not specify the build file"                                     + " attribute and a nested build at the"                                     + " same time");        }        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      getExecutable(), null);        String[] args = getPropertyArguments(properties);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        args = getTargetArguments(targets);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        File generatedFile = null;        if (buildSnippet != null) {            try {                generatedFile = getBuildFile();            } catch (IOException e) {                throw new BuildException(e);            }            args = getBuildfileArguments(generatedFile);        } else {            args = getBuildfileArguments(buildFile);        }                for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        try {            exec.execute();        } finally {            if (generatedFile != null) {                generatedFile.delete();            }        }    }    private File getBuildFile() throws IOException {        File f = null;        if (buildSnippet != null) {            Element e = makeTree(buildSnippet.getFragment());            f = FileUtils.getFileUtils().createTempFile("build", ".xml", null);            f.deleteOnExit();            FileOutputStream out = null;            try {                out = new FileOutputStream(f);                DOMElementWriter w =                    new DOMElementWriter(true,                                         DOMElementWriter.XmlNamespacePolicy                                         .ONLY_QUALIFY_ELEMENTS);                w.write(e, out);            } finally {                if (out != null) {                    out.close();                }            }        }        return f;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.Iterator;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a MSBuild build process. */public class MSBuildTask extends AbstractBuildTask {    private static final String TARGET = "generated-by-ant";    private static final String ROOT = "Project";    private static final String MSBUILD_NS =	"http://schemas.microsoft.com/developer/msbuild/2003";    public MSBuildTask() {        super();    }    protected String getExecutable() {        return "MSBuild.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        if (targets.size() > 0) {            StringBuffer sb = new StringBuffer("/target:");            Iterator iter = targets.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Target t =                     (AbstractBuildTask.Target) iter.next();                if (!first) {                    sb.append(";");                } else {                    first = false;                }                sb.append(t.getName());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    protected String[] getPropertyArguments(List properties) {        if (properties.size() > 0) {            StringBuffer sb = new StringBuffer("/property:");            Iterator iter = properties.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Property p =                     (AbstractBuildTask.Property) iter.next();                if (!first) {                    sb.append(";");                } else {                    first = false;                }                sb.append(p.getName()).append("=").append(p.getValue());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <Project> child, return that.     * Otherwise if we have only <Task> children, wrap them into a     * <Target> which in turn gets wrapped into a <Project>.     * Otherwise, fail.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals(ROOT)) {            return (Element) nl.item(0);        } else {            Element p = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     ROOT);            p.setAttribute("DefaultTargets", TARGET);            Element t = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     "Target");            t.setAttribute("Name", TARGET);            p.appendChild(t);            t.appendChild(f);            return p;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a NAnt build process. */public class NAntTask extends AbstractBuildTask {    public NAntTask() {        super();    }    protected String getExecutable() {        return "NAnt.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                "-buildfile:" + buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        ArrayList al = new ArrayList(targets.size());        Iterator iter = targets.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Target t = (AbstractBuildTask.Target) iter.next();            al.add(t.getName());        }        return (String[]) al.toArray(new String[al.size()]);    }    protected String[] getPropertyArguments(List properties) {        ArrayList al = new ArrayList(properties.size());        Iterator iter = properties.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                 (AbstractBuildTask.Property) iter.next();            al.add("-D:" + p.getName() + "=" + p.getValue());        }        return (String[]) al.toArray(new String[al.size()]);    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <project> child, return that.     * Otherwise assume that this is a valid build file snippet that     * just needs an empty project wrapped around it.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals("project")) {            return (Element) nl.item(0);        } else {            Element e = f.getOwnerDocument().createElement("project");            e.appendChild(f);            return e;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */// ====================================================================// place in the optional ant tasks package// but in its own dotnet group// ====================================================================package org.apache.ant.dotnet.compile;// ====================================================================// imports// ====================================================================import org.apache.ant.dotnet.NetCommand;import java.io.File;// ====================================================================/** *  Compiles C# source into executables or modules. * * csc.exe on Windows or mcs on other platforms must be on the execute * path, unless another executable or the full path to that executable * is specified in the <tt>executable</tt> parameter * <p> * All parameters are optional: &lt;csc/&gt; should suffice to produce a debug * build of all *.cs files. However, naming an <tt>destFile</tt>stops the * csc compiler from choosing an output name from random, and * allows the dependency checker to determine if the file is out of date. * <p> *  The task is a directory based task, so attributes like <b>includes="*.cs" *  </b> and <b>excludes="broken.cs"</b> can be used to control the files pulled *  in. By default, all *.cs files from the project folder down are included in *  the command. When this happens the output file -if not specified- is taken *  as the first file in the list, which may be somewhat hard to control. *  Specifying the output file with <tt>destFile</tt> seems prudent. <p> * * <p> * For more complex source trees, nested <tt>src</tt> elemements can be * supplied. When such an element is present, the implicit fileset is ignored. * This makes sense, when you think about it :) * * <p>For historical reasons the pattern * <code>**</code><code>/*.cs</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * <p> * References to external files can be made through the references attribute, * or (since Ant1.6), via nested &lt;reference&gt; filesets. With the latter, * the timestamps of the references are also used in the dependency * checking algorithm. * <p> * * Example * * <pre>&lt;csc *       optimize=&quot;true&quot; *       debug=&quot;false&quot; *       docFile=&quot;documentation.xml&quot; *       warnLevel=&quot;4&quot; *       unsafe=&quot;false&quot; *       targetType=&quot;exe&quot; *       incremental=&quot;false&quot; *       mainClass = &quot;MainApp&quot; *       destFile=&quot;NetApp.exe&quot; *       &gt; *           &lt;src dir="src" includes="*.cs" /&gt; *       &lt;reference file="${testCSC.dll}" /&gt; *       &lt;define name="RELEASE" /&gt; *       &lt;define name="DEBUG" if="debug.property"/&gt; *       &lt;define name="def3" unless="def3.property"/&gt; *    &lt;/csc&gt; * </pre> * * * @ant.task    name="csc" category="dotnet" * @since Ant 1.3 */public class CSharp extends DotnetCompile {    /**     *  defines list: RELEASE;WIN32;NO_SANITY_CHECKS;;SOMETHING_ELSE'     */    String definitions;    /**     *  output XML documentation flag     */    private File docFile;    /**     *  file alignment; 0 means let the compiler decide     */    private int fileAlign = 0;    /**     *  use full paths to things     */    private boolean fullpaths = false;    /**     *  incremental build flag     */    private boolean incremental;    /**     *  enable unsafe code flag. Clearly set to false by default     */    protected boolean unsafe;    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     */    private boolean noconfig = false;    /**     *  constructor inits everything and set up the search pattern     */    public CSharp() {        clear();    }    /**     * full cleanup     */    public void clear() {        super.clear();        docFile = null;        fileAlign = 0;        fullpaths = true;        incremental = false;        unsafe = false;        noconfig = false;        definitions = null;        setExecutable(isWindows ? "csc" : "mcs");    }    /**     *  file for generated XML documentation     *     *@param  f  output file     */    public void setDocFile(File f) {        docFile = f;    }    /**     *  get the argument or null for no argument needed     *     *@return    The DocFile Parameter to CSC     */    protected String getDocFileParameter() {        if (docFile != null) {            return "/doc:" + docFile.toString();        } else {            return null;        }    }    /**     * Set the file alignment.     * Valid values are 0,512, 1024, 2048, 4096, 8192,     * and 16384, 0 means 'leave to the compiler'     */    public void setFileAlign(int fileAlign) {        this.fileAlign = fileAlign;    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getFileAlignParameter() {        if (fileAlign != 0 && !"mcs".equals(getExecutable())) {            return "/filealign:" + fileAlign;        } else {            return null;        }    }    /**     * If true, print the full path of files on errors.     *     *@param  enabled  The new fullPaths value     */    public void setFullPaths(boolean enabled) {        fullpaths = enabled;    }    /**     *  Gets the fullPathsParameter attribute of the CSharp object     *     *@return    The fullPathsParameter value or null if unset     */    protected String getFullPathsParameter() {        return fullpaths ? "/fullpaths" : null;    }    /**     *  set the incremental compilation flag on or off.     *     *@param  incremental  on/off flag     */    public void setIncremental(boolean incremental) {        this.incremental = incremental;    }    /**     *  query the incrementalflag     *     *@return    true if incremental compilation is turned on     */    public boolean getIncremental() {        return incremental;    }    /**     *  get the incremental build argument     *     *@return    The Incremental Parameter to CSC     */    protected String getIncrementalParameter() {        return "/incremental" + (incremental ? "+" : "-");    }    /**     *  The output file. This is identical to the destFile attribute.     *     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        setDestFile(params);    }    /**     * If true, enables the unsafe keyword.     *     *@param  unsafe  The new Unsafe value     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     *  query the Unsafe attribute     *     *@return    The Unsafe value     */    public boolean getUnsafe() {        return this.unsafe;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Unsafe Parameter to CSC     */    protected String getUnsafeParameter() {        return unsafe ? "/unsafe" : null;    }    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     *     *@param  enabled  The new noConfig value     */    public void setNoConfig(boolean enabled) {        noconfig = enabled;    }    /**     *  Gets the noConfigParameter attribute of the CSharp object     *     *@return    The noConfigParameter value     */    protected String getNoConfigParameter() {        return noconfig ? "/noconfig" : null;    }    /**     *  Semicolon separated list of defined constants.     *     *@param  params  The new definitions value     */    public void setDefinitions(String params) {        definitions = params;    }    /**     * override the superclasses version of this method (which we call)     * with a check for a definitions attribute, the contents of which     * are appended to the list.     *@return    The Definitions Parameter to CSC     */    protected String getDefinitionsParameter() {        String predecessors = super.getDefinitionsParameter();        if (notEmpty(definitions)) {            if (predecessors == null) {                predecessors = "/define:";            }            return  predecessors + definitions;        } else {            return predecessors;        }    }    /**     * add Commands unique to C#.     * @param command ongoing command     */    public void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getIncludeDefaultReferencesParameter());        command.addArgument(getWarnLevelParameter());        command.addArgument(getDocFileParameter());        command.addArgument(getFullPathsParameter());        command.addArgument(getFileAlignParameter());        command.addArgument(getIncrementalParameter());        command.addArgument(getNoConfigParameter());        command.addArgument(getUnsafeParameter());    }    // end execute    /**     * Returns the delimiter which C# uses to separate references, i.e., a semi colon.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * This method indicates the filename extension for C# files.     * @return the file extension for C#, i.e., "cs" (without the dot).     */    public String getFileExtension() {        return "cs";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.taskdefs.MatchingTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.Project;import org.apache.tools.ant.DirectoryScanner;import java.io.File;import java.util.Vector;import java.util.Hashtable;import java.util.Enumeration;/** * refactoring of some stuff so that different things (like ILASM) * can use shared code. */public class DotnetBaseMatchingTask extends MatchingTask {    /**     *  output file. If not supplied this is derived from the source file     */    protected File outputFile;    /**     * filesets of file to compile     */    protected Vector filesets = new Vector();    /**     *  source directory upon which the search pattern is applied     */    protected File srcDir;    /**     * Are we running on Windows?     *     * @since Ant 1.6.3     */    protected static final boolean isWindows = Os.isFamily("windows");    /**    * Overridden because we need to be able to set the srcDir.    */    public File getSrcDir() {        return this.srcDir;    }    /**     *  Set the source directory of the files to be compiled.     *     *@param  srcDirName  The new SrcDir value     */    public void setSrcDir(File srcDirName) {        this.srcDir = srcDirName;    }    /**     *  Set the name of exe/library to create.     *     *@param  file  The new outputFile value     */    public void setDestFile(File file) {        outputFile = file;    }    /**     * add a new source directory to the compile     * @param src     */    public void addSrc(FileSet src) {        filesets.add(src);    }    /**     * get the destination file     * @return the dest file or null for not assigned     */    public File getDestFile() {        return outputFile;    }    /**     * create the list of files     * @param filesToBuild vector to add files to     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int buildFileList(NetCommand command, Hashtable filesToBuild, long outputTimestamp) {        int filesOutOfDate = 0;        boolean scanImplicitFileset            = getSrcDir() != null || filesets.size() == 0;        if (scanImplicitFileset) {            //scan for an implicit fileset if there was a srcdir set            //or there was no srcDir set but there was no contained classes            if (getSrcDir() == null) {                //if there is no src dir here, set it                setSrcDir(getProject().resolveFile("."));            }            log("working from source directory " + getSrcDir(),                    Project.MSG_VERBOSE);            //get dependencies list.            DirectoryScanner scanner = getDirectoryScanner(getSrcDir());            filesOutOfDate = command.scanOneFileset(scanner,                    filesToBuild, outputTimestamp);        }        //get any included source directories        for (int i = 0; i < filesets.size(); i++) {            FileSet fs = (FileSet) filesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        return filesOutOfDate;    }    /**     * add the list of files to a command     * @param filesToBuild vector of files     * @param command the command to append to     */    protected void addFilesToCommand(Hashtable filesToBuild, NetCommand command) {        int count = filesToBuild.size();        log("compiling " + count + " file" + ((count == 1) ? "" : "s"),                Project.MSG_VERBOSE);        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            command.addArgument(file.toString());        }    }    /**     * determine the timestamp of the output file     * @return a timestamp or 0 for no output file known/exists     */    protected long getOutputFileTimestamp() {        long outputTimestamp;        if (getDestFile() != null && getDestFile().exists()) {            outputTimestamp = getDestFile().lastModified();        } else {            outputTimestamp = 0;        }        return outputTimestamp;    }    /**     * finish off the command by adding all dependent files, execute     * @param command     */    protected void addFilesAndExecute(NetCommand command, boolean ignoreTimestamps) {        long outputTimestamp = getOutputFileTimestamp();        Hashtable filesToBuild = new Hashtable();        int filesOutOfDate = buildFileList(command, filesToBuild, outputTimestamp);        //now run the command of exe + settings + files        if (filesOutOfDate > 0) {            //add the files to the command            addFilesToCommand(filesToBuild, command);            command.runCommand();        } else {            log("output file is up to date", Project.MSG_VERBOSE);        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap:Cream+Live+2001+CD+2 */// place in the optional ant tasks package// but in its own dotnet grouppackage org.apache.ant.dotnet.compile;// importsimport java.io.File;import java.util.Vector;import java.util.Enumeration;import java.util.Hashtable;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.Path;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.types.EnumeratedAttribute;/** *  Abstract superclass for dotnet compiler tasks. * *  History *  <table> *    <tr> *      <td> *        0.1 *      </td> *      <td> *        First creation *      </td> *      <td> *        Most of the code here was copied verbatim from v0.3 of *        Steve Loughran's CSharp optional task. Abstracted functionality *        to allow subclassing of other dotnet compiler types. *      </td> *    </tr> * *  </table> * * * @version     0.1 */public abstract class DotnetCompile         extends DotnetBaseMatchingTask {    /**     *  list of reference classes. (pretty much a classpath equivalent)     */    private String references;    /**     *  flag to enable automatic reference inclusion     */    private boolean includeDefaultReferences = true;    /**     *  icon for incorporation into apps     */    private File win32icon;    /**     *  icon for incorporation into apps     */    private File win32res;    /**     *  flag to control action on execution trouble     */    private boolean failOnError;    /**     *  using the path approach didn't work as it could not handle the implicit     *  execution path. Perhaps that could be extracted from the runtime and     *  then the path approach would be viable     */    private Path referenceFiles;    /**     *  optimise flag     */    private boolean optimize;    /**     * a list of definitions to support;     */    protected Vector definitionList = new Vector();    /**     * our resources     */    protected Vector resources = new Vector();    /**     *  executable     */    protected String executable;    protected static final String REFERENCE_OPTION = "/reference:";    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  warning level: 0-4, with 4 being most verbose     */    private int warnLevel;    /**     *  main class (or null for automatic choice)     */    protected String mainClass;    /**     *  any extra command options?     */    protected String extraOptions;    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  utf out flag     */    protected boolean utf8output = false;    /**     *  list of extra modules to refer to     */    protected String additionalModules;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    private static final int AUTOMATIC_RESPONSE_FILE_THRESHOLD = 64;    /**     *  constructor inits everything and set up the search pattern     */    public DotnetCompile() {        clear();        setIncludes(getFilePattern());    }    /**     *  reset all contents.     */    public void clear() {        targetType = null;        win32icon = null;        srcDir = null;        mainClass = null;        warnLevel = 3;        optimize = false;        debug = true;        references = null;        failOnError = true;        additionalModules = null;        includeDefaultReferences = true;        extraOptions = null;    }    /**     * Semicolon separated list of DLLs to refer to.     *     *@param  s  The new References value     */    public void setReferences(String s) {        references = s;    }    /**     *  get the reference string or null for no argument needed     *     *@return    The References Parameter to CSC     */    protected String getReferencesParameter() {        //bail on no references        if (notEmpty(references)) {            if (isWindows) {                return '\"' + REFERENCE_OPTION + references + '\"';            } else {                return REFERENCE_OPTION + references;            }        } else {            return null;        }    }    /**     * Path of references to include.     * Wildcards should work.     *     *@param  path  another path to append     */    public void setReferenceFiles(Path path) {        //demand create pathlist        if (referenceFiles == null) {            referenceFiles = new Path(this.getProject());        }        referenceFiles.append(path);    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     *  turn the path list into a list of files and a /references argument     *     *@return    null or a string of references.     */    protected String getReferenceFilesParameter() {        //bail on no references        if (references == null) {            return null;        }        //iterate through the ref list & generate an entry for each        //or just rely on the fact that the toString operator does this, but        //noting that the separator is ';' on windows, ':' on unix        //bail on no references listed        if (references.length() == 0) {            return null;        }        StringBuffer s = new StringBuffer(REFERENCE_OPTION);        if (isWindows) {            s.append('\"');        }        s.append(references);        if (isWindows) {            s.append('\"');        }        return s.toString();    }    /**     * If true, automatically includes the common assemblies     * in dotnet, and tells the compiler to link in mscore.dll.     *     *  set the automatic reference inclusion flag on or off this flag controls     *  the /nostdlib option in CSC     *     *@param  f  on/off flag     */    public void setIncludeDefaultReferences(boolean f) {        includeDefaultReferences = f;    }    /**     *  query automatic reference inclusion flag     *     *@return    true if flag is turned on     */    public boolean getIncludeDefaultReferences() {        return includeDefaultReferences;    }    /**     *  get the include default references flag or null for no argument needed     *     *@return    The Parameter to CSC     */    protected String getIncludeDefaultReferencesParameter() {        return "/nostdlib" + (includeDefaultReferences ? "-" : "+");    }    /**     * If true, enables optimization flag.     *     *@param  f  on/off flag     */    public void setOptimize(boolean f) {        optimize = f;    }    /**     *  query the optimise flag     *     *@return    true if optimise is turned on     */    public boolean getOptimize() {        return optimize;    }    /**     *  get the optimise flag or null for no argument needed     *     *@return    The Optimize Parameter to CSC     */    protected String getOptimizeParameter() {        return "/optimize" + (optimize ? "+" : "-");    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the debug switch argument     *     *@return    The Debug Parameter to CSC     */    protected String getDebugParameter() {        return "/debug" + (debug ? "+" : "-");    }    /**     * Level of warning currently between 1 and 4     * with 4 being the strictest.     *     *@param  warnLevel  warn level -see .net docs for valid range (probably     *      0-4)     */    public void setWarnLevel(int warnLevel) {        this.warnLevel = warnLevel;    }    /**     *  query warn level     *     *@return    current value     */    public int getWarnLevel() {        return warnLevel;    }    /**     *  get the warn level switch     *     *@return    The WarnLevel Parameter to CSC     */    protected String getWarnLevelParameter() {        return "/warn:" + warnLevel;    }    /**     *  Sets the name of main class for executables.     *     *@param  mainClass  The new MainClass value     */    public void setMainClass(String mainClass) {        this.mainClass = mainClass;    }    /**     *  Gets the MainClass attribute     *     *@return    The MainClass value     */    public String getMainClass() {        return this.mainClass;    }    /**     *  get the /main argument or null for no argument needed     *     *@return    The MainClass Parameter to CSC     */    protected String getMainClassParameter() {        if (mainClass != null && mainClass.length() != 0) {            return "/main:" + mainClass;        } else {            return null;        }    }    /**     * Any extra options which are not explicitly supported     * by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     *  get any extra options or null for no argument needed, split     *  them if they represent multiple options.     *     * @return    The ExtraOptions Parameter to CSC     */    protected String[] getExtraOptionsParameters() {        String extra = getExtraOptionsParameter();        return extra == null ? null : Commandline.translateCommandline(extra);    }    /**     * Set the destination directory of files to be compiled.     *     *@param  dirName  The new DestDir value     */    public void setDestDir(File dirName) {        log("DestDir currently unused", Project.MSG_WARN);    }    /**     * set the target type to one of exe|library|module|winexe     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Set the type of target.     *     *@param  ttype          The new TargetType value     *@exception  BuildException  if target is not one of     *      exe|library|module|winexe     */    public void setTargetType(String ttype)             throws BuildException {        ttype = ttype.toLowerCase();        if (ttype.equals("exe") || ttype.equals("library")            || ttype.equals("module") || ttype.equals("winexe")) {            targetType = ttype;        } else {            throw new BuildException("targetType " + ttype                    + " is not one of 'exe', 'module', 'winexe' or 'library'");        }    }    /**     *  Gets the TargetType attribute     *     *@return    The TargetType value     */    public String getTargetType() {        return targetType;    }    /**     *  get the argument or null for no argument needed     *     *@return    The TargetType Parameter to CSC     */    protected String getTargetTypeParameter() {        if (notEmpty(targetType)) {            return "/target:" + targetType;        } else {            return null;        }    }    /**     *  Set the filename of icon to include.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Icon(File fileName) {        win32icon = fileName;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Icon Parameter to CSC     */    protected String getWin32IconParameter() {        if (win32icon != null) {            return "/win32icon:" + win32icon.toString();        } else {            return null;        }    }    /**     * Sets the filename of a win32 resource (.RES) file to include.     * This is not a .NET resource, but what Windows is used to.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Res(File fileName) {        win32res = fileName;    }    /**     * Gets the file of the win32 .res file to include.     * @return path to the file.     */    public File getWin32Res() {        return win32res;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (win32res != null) {            return "/win32res:" + win32res.toString();        } else {            return null;        }    }    /**     * If true, require all compiler output to be in UTF8 format.     *     *@param  enabled  The new utf8Output value     */    public void setUtf8Output(boolean enabled) {        utf8output = enabled;    }    /**     *  Gets the utf8OutpuParameter attribute of the CSharp object     *     *@return    The utf8OutpuParameter value     */    protected String getUtf8OutputParameter() {        return utf8output ? "/utf8output" : null;    }    /**     * add a define to the list of definitions     * @param define     */    public void addDefine(DotnetDefine define) {        definitionList.addElement(define);    }    /**     * get a list of definitions or null     * @return a string beginning /D: or null for no definitions     */    protected String getDefinitionsParameter() throws BuildException {        StringBuffer defines = new StringBuffer();        Enumeration defEnum = definitionList.elements();        boolean firstDefinition = true;        while (defEnum.hasMoreElements()) {            //loop through all definitions            DotnetDefine define = (DotnetDefine) defEnum.nextElement();            if (define.isSet(this)) {                //add those that are set, and a delimiter                if (!firstDefinition) {                    defines.append(getDefinitionsDelimiter());                }                defines.append(define.getValue(this));                firstDefinition = false;            }        }        if (defines.length() == 0) {            return null;        } else {            return "/d:" + defines;        }    }    /**     * Semicolon separated list of modules to refer to.     *     *@param  params  The new additionalModules value     */    public void setAdditionalModules(String params) {        additionalModules = params;    }    /**     *  get the argument or null for no argument needed     *     *@return    The AdditionalModules Parameter to CSC     */    protected String getAdditionalModulesParameter() {        if (notEmpty(additionalModules)) {            return "/addmodule:" + additionalModules;        } else {            return null;        }    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getDestFileParameter() {        if (outputFile != null) {            return "/out:" + outputFile.toString();        } else {            return null;        }    }    /**     * If true, fail on compilation errors.     *     *@param  b  The new FailOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The FailFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     * link or embed a resource     * @param resource     */    public void addResource(DotnetResource resource) {        resources.add(resource);    }    /**     * This method gets the name of the executable.     * @return the name of the executable     */    protected String getExecutable() {        return executable;    }    /**     * set the name of the program, overriding the defaults.     * Can be used to set the full path to a program, or to switch     * to an alternate implementation of the command, such as the Mono or Rotor     * versions -provided they use the same command line arguments as the     * .NET framework edition     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     *  test for a string containing something useful     *     *@param  s  string in     *@return    true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (outputFile != null && outputFile.isDirectory()) {            throw new BuildException("destFile cannot be a directory");        }        if (getExecutable() == null) {            throw new BuildException("There is no executable defined for this task");        }    }    /**     * Get the pattern for files to compile.     * @return The compilation file pattern.     */    public String getFilePattern() {        return "**/*." + getFileExtension();    }    /**     * getter for flag     * @return The flag indicating whether the compilation is using a response file.     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * Flag to turn on response file use; default=false.     * When set the command params are saved to a file and     * this is passed in with @file. The task automatically switches     * to this mode with big commands; this option is here for     * testing and emergencies     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        validate();        NetCommand command = createNetCommand();        //set up response file options        command.setAutomaticResponseFileThreshold(AUTOMATIC_RESPONSE_FILE_THRESHOLD);        command.setUseResponseFile(useResponseFile);        //fill in args        fillInSharedParameters(command);        addResources(command);        addCompilerSpecificOptions(command);        int referencesOutOfDate            = addReferenceFilesets(command, getOutputFileTimestamp());        //if the refs are out of date, force a build.        boolean forceBuild = referencesOutOfDate > 0;        addFilesAndExecute(command, forceBuild);    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public abstract String getReferenceDelimiter();    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public abstract String getFileExtension();    /**     * fill in the common information     * @param command     */    protected void fillInSharedParameters(NetCommand command) {        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument("/nologo");        command.addArgument(getAdditionalModulesParameter());        command.addArgument(getDebugParameter());        command.addArgument(getDefinitionsParameter());        command.addArguments(getExtraOptionsParameters());        command.addArgument(getMainClassParameter());        command.addArgument(getOptimizeParameter());        command.addArgument(getDestFileParameter());        command.addArgument(getReferencesParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getUtf8OutputParameter());        command.addArgument(getWin32IconParameter());        command.addArgument(getWin32ResParameter());    }    /**     * for every resource declared, we get the (language specific)     * resource setting     */    protected void addResources(NetCommand command) {        Enumeration e = resources.elements();        while (e.hasMoreElements()) {            DotnetResource resource = (DotnetResource) e.nextElement();            createResourceParameter(command, resource);        }    }    /* XXX Javadoc makes little sense, rewrite     * from a resource, get the     * @param resource     * @return a string containing the resource param, or a null string     * to conditionally exclude a resource.     */    protected abstract void createResourceParameter(NetCommand command, DotnetResource resource);    /**     * run through the list of reference files and add them to the command     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int addReferenceFilesets(NetCommand command, long outputTimestamp) {        int filesOutOfDate = 0;        Hashtable filesToBuild = new Hashtable();        for (int i = 0; i < referenceFilesets.size(); i++) {            FileSet fs = (FileSet) referenceFilesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        //bail out early if there were no files        if (filesToBuild.size() == 0) {            return 0;        }        //now scan the hashtable and add the files        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            if (isFileManagedBinary(file)) {                if (isWindows) command.addArgument('"'+REFERENCE_OPTION+file.toString()+'"');                else command.addArgument(REFERENCE_OPTION+file.toString());            } else {                log("ignoring " + file + " as it is not a managed executable",                        Project.MSG_VERBOSE);            }        }        return filesOutOfDate;    }    /**     * create our helper command     * @return a command prefilled with the exe name and task name     */    protected NetCommand createNetCommand() {        NetCommand command = new NetCommand(this, getTaskName(), getExecutable());        return command;    }    /**     * add any compiler specifics     * @param command     */    protected abstract void addCompilerSpecificOptions(NetCommand command);    /**     * override point for delimiting definitions.     * @return The definitions limiter, i.e., ";"     */    public String getDefinitionsDelimiter() {        return ";";    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[] {                "exe",                "library",                "module",                "winexe"            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;/** * definitions can be conditional. What .NET conditions can not be * is in any state other than defined and undefined; you cannot give * a definition a value. */public class DotnetDefine {    private String name;    private String ifCond;    private String unlessCond;    /**     * the name of a property which must be defined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setIf(String condition) {        this.ifCond = condition;    }    /**     * the name of a property which must be undefined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setUnless(String condition) {        this.unlessCond = condition;    }    public String getName() {        return name;    }    /**     * the name of the definition. Required.     * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * This method gets the value of this definition. Will be null if a condition     * was declared and not met     * @param owner owning task     * @return The value of the definition.     * @throws BuildException     */    public String getValue(Task owner) throws BuildException {        if (name == null) {            throw new BuildException("No name provided for the define element",                owner.getLocation());        }        if (!isSet(owner)) {            return null;        }        return name;    }    /**     * logic taken from patternset     * @param owner     * @return true if the condition is valid     */    public boolean isSet(Task owner) {        Project p = owner.getProject();        if (ifCond != null && p.getProperty(ifCond) == null) {            return false;        } else if (unlessCond != null && p.getProperty(unlessCond) != null) {            return false;        }        return true;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import java.io.File;import java.util.ArrayList;import org.apache.tools.ant.types.FileSet;import java.util.Iterator;import org.apache.tools.ant.*;/** * Used by {@link DotnetCompile} to name resources. * Could be upgraded to a datatype in the distant future. * A resource maps to /res:file,name */public class DotnetResource {    /**     * name of resource     */    private File file;    /**     * embed (default) or link the resource     */    private boolean embed = true;    /**     * this is used in VBC and JSC     */    private Boolean isPublic = null;    /**     * name of the object     */    private String name = null;    /**     * A list of filesets with resources.     */    private ArrayList fileSets = new ArrayList();    /**     * a namespace to be used with <filesets>     */    private String namespace = null;    public boolean isEmbed() {        return embed;    }    /**     * embed the resource in the assembly (default, true) or just link to it.     *      * @param embed     */    public void setEmbed(boolean embed) {        this.embed = embed;    }    public File getFile() {        return file;    }    /**     * name the resource     *      * @param file     */    public void setFile(File file) {        this.file = file;    }    public Boolean getPublic() {        return isPublic;    }    /**     * VB and J# only: is a resource public or not?     *      * @param aPublic     */    public void setPublic(Boolean aPublic) {        isPublic = aPublic;    }    public String getName() {        return name;    }    /**     * should the resource have a name?     *      * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * Filesets root namespace. The value always ends with '.' .     *      * @return String namespace name     */    public String getNamespace() {        return namespace;    }    /**     * Sets filesets root namespace.     *      * @param namespace     *            String root namespace     */    public void setNamespace(String namespace) {        if (namespace == null) {            this.namespace = null;        } else {            this.namespace = (namespace.length() == 0 || namespace.endsWith(".") ? namespace                    : namespace + '.');        }    }    private void checkParameters() {        if (hasFilesets()) {            if (getName() != null)                throw new BuildException(                        "Cannot use <resource name=\"...\"> attribute with filesets");            if (getFile() != null)                throw new BuildException(                        "Cannot use <resource file=\"...\"> attribute with filesets");        } else {            if (getNamespace() != null)                throw new BuildException(                        "Cannot use <resource namespace=\"...\"> attribute without filesets");        }    }    /**     * build the C# style parameter (which has no public/private option)     */    public void getParameters(Project p, NetCommand command, boolean csharpStyle) {        checkParameters();        if (hasFilesets()) {            for (Iterator listIter = fileSets.iterator(); listIter.hasNext();) {                FileSet fs = (FileSet) listIter.next();                String baseDirectory = fs.getDir(p).toString();                String namespace = getNamespace(); // ends with '.' or null                DirectoryScanner ds = fs.getDirectoryScanner(p);                String[] files = ds.getIncludedFiles();                for (int i = 0; i < files.length; i++) {                    String file = files[i];                    command.addArgument(getParameter(baseDirectory + File.separatorChar + file,                            (namespace == null ? null : namespace                                    + file.replace(File.separatorChar, '.')), csharpStyle));                }            }        } else {            command.addArgument(getParameter(getFile().toString(), getName(), csharpStyle));        }    }    private String getParameter(String fileName, String name, boolean csharpStyle) {        StringBuffer buffer = new StringBuffer();        buffer.append(isEmbed() ? "/resource" : "/linkresource");        buffer.append(':');        buffer.append(fileName);        if (name != null) {            buffer.append(',');            buffer.append(name);            if (csharpStyle) {                if (getPublic() != null) {                    throw new BuildException("This compiler does not support the "                            + "public/private option.");                } else {                    if (getPublic() != null) {                        buffer.append(',');                        buffer.append(getPublic().booleanValue() ? "public" : "private");                    }                }            } else if (getPublic() != null) {                throw new BuildException("You cannot have a public or private "                        + "option without naming the resource");            }        }        return buffer.toString();    }    /**     * Adds a resource file set.     *      * @param fileset     *            FileSet     */    public void addFileset(FileSet fileset) {        fileSets.add(fileset);    }    /**     * Checks that <resource> node has embedded <filesets>     *      * @return boolean     */    public boolean hasFilesets() {        return fileSets.size() > 0;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;/** * Assembles .NET Intermediate Language files. * ilasm.exe must be on the execute path, unless another executable * or the full path to that executable is specified in the <tt>executable</tt> * parameter *  <p> * *  <p> * *  All parameters are optional: &lt;il/&gt; should suffice to produce a debug *  build of all *.il files. The option set is roughly compatible with the *  CSharp class; even though the command line options are only vaguely *  equivalent. [The low level commands take things like /OUT=file, csc wants *  /out:file ... /verbose is used some places; /quiet here in ildasm... etc.] *  It would be nice if someone made all the command line tools consistent (and *  not as brittle as the java cmdline tools) <p> *  <p> *  The task is a directory based task, so attributes like <b>includes="*.il" *  </b> and <b>excludes="broken.il"</b> can be used to control the files pulled *  in. You can also use nested &lt;src&gt filesets to refer to source. * <p> * * @ant.task    name="ilasm" category="dotnet" */public class Ilasm         extends DotnetBaseMatchingTask {    /**     *  Name of the executable. The .exe suffix is deliberately not included in     *  anticipation of the unix version     */    protected static final String exe_name = "ilasm";    /**     *  what is the file extension we search on?     */    protected static final String file_ext = "il";    /**     *  and now derive the search pattern from the extension     */    protected static final String file_pattern = "**/*." + file_ext;    /**     *  title of task for external presentation     */    protected static final String exe_title = "ilasm";    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  verbose flag     */    protected boolean verbose;    /**     *  listing flag     */    protected boolean listing;    /**     *  resource file (.res format) to include in the app.     */    protected File resourceFile;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  file containing private key     */    private File keyfile;    /**     *  any extra command options?     */    protected String extraOptions;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * @since Ant 1.7     */    private boolean isMono = !Os.isFamily("windows");    /**     *  constructor inits everything and set up the search pattern     */    public Ilasm() {        Clear();        setIncludes(file_pattern);    }    /**     *  reset all contents.     */    public void Clear() {        targetType = null;        srcDir = null;        listing = false;        verbose = false;        debug = true;        outputFile = null;        failOnError = true;        resourceFile = null;        extraOptions = null;    }    /**     * Sets the type of target, either "exe" or "library".     *     *@param  targetType          one of exe|library|     *@exception  BuildException  if target is not one of     *      exe|library     */    public void setTargetType(String targetType)             throws BuildException {        this.targetType = targetType.toLowerCase();        if (!targetType.equals("exe") && !targetType.equals("library")) {            throw new BuildException("targetType " + targetType + " is not a valid type");        }    }    /**     *  accessor method for target type     *     *@return    the current target option     */    public String getTargetType() {        return targetType;    }    /**     *  g get the target type or null for no argument needed     *     *@return    The TargetTypeParameter value     */    protected String getTargetTypeParameter() {        if (!notEmpty(targetType)) {            return null;        }        if (targetType.equals("exe")) {            return "/exe";        } else if (targetType.equals("library")) {            return "/dll";        } else {            return null;        }    }    /**     * Sets the Owner attribute.     *     * @param  s  The new Owner value     * @ant.attribute ignore="true"     */    public void setOwner(String s) {        log("This option is not supported by ILASM as of Beta-2, "            + "and will be ignored", Project.MSG_WARN);    }    /**     *  test for a string containing something useful     *     *@param  s       any string     *@return         true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     *  If true, enable verbose ILASM output.     *     *@param  b  flag set to true for verbose on     */    public void setVerbose(boolean b) {        verbose = b;    }    /**     *  turn the verbose flag into a parameter for ILASM     *     *@return    null or the appropriate command line string     */    protected String getVerboseParameter() {        return verbose ? null : "/quiet";    }    /**     * If true, produce a listing (off by default).     *     *@param  b  flag set to true for listing on     */    public void setListing(boolean b) {        listing = b;    }    /**     *  turn the listing flag into a parameter for ILASM     *     *@return    the appropriate string from the state of the listing flag     */    protected String getListingParameter() {        if (!isMono) {            return listing ? "/listing" : "/nolisting";        }        return null;    }    /**     * Set the output file; identical to setDestFile     * @see DotnetBaseMatchingTask#setDestFile     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        outputFile = params;    }    /**     *  get the output file     *     *@return    the argument string or null for no argument     */    protected String getOutputFileParameter() {        if (outputFile == null) {            return null;        }        return "/output=" + outputFile.toString();    }    /**     * name of resource file to include.     *     * @param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setResourceFile(File fileName) {        resourceFile = fileName;    }    /**     *  Gets the resourceFileParameter attribute of the Ilasm task     *     *@return    The resourceFileParameter value     */    protected String getResourceFileParameter() {        if (resourceFile != null) {            return "/resource=" + resourceFile.toString();        } else {            return null;        }    }    /**     * If true, fails if ilasm tool fails.     *     *@param  b  The new failOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the argument or null for no argument needed     *     *@return    The debugParameter value     */    protected String getDebugParameter() {        return debug ? "/debug" : null;    }    /**     * the name of a file containing a private key.     *     *@param  keyfile  The new keyfile value     */    public void setKeyfile(File keyfile) {        this.keyfile = keyfile;    }    /**     *  get the argument or null for no argument needed     *     *@return    The keyfileParameter value     */    protected String getKeyfileParameter() {        if (keyfile != null) {            return "/keyfile:" + keyfile.toString();        } else {            return null;        }    }    /**     * Any extra options which are not explicitly     * supported by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     * set the target type to one of exe|library     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Explicitly override the Mono auto-detection.     *     * <p>Defaults to false on Windows and true on any other platform.</p>     *     * @since Ant 1.7     */    public void setMono(boolean b) {        isMono = b;    }    /**     *  This is the execution entry point. Build a list of files and call ilasm     *  on each of them.     *     *@throws  BuildException  if the assembly failed and FailOnError is true     */    public void execute()             throws BuildException {        NetCommand command = buildIlasmCommand();        addFilesAndExecute(command, false);    }    // end execute    /**     * build up our ilasm command     * @return     */    private NetCommand buildIlasmCommand() {        NetCommand command = new NetCommand(this, exe_title, exe_name);        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument(getDebugParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getListingParameter());        command.addArgument(getOutputFileParameter());        command.addArgument(getResourceFileParameter());        command.addArgument(getVerboseParameter());        command.addArgument(getKeyfileParameter());        command.addArgument(getExtraOptionsParameter());        /*         *  space for more argumentativeness         *  command.addArgument();         *  command.addArgument();         */        return command;    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "exe",                "library",            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * Compile J# source down to a managed .NET application. * <p> * J# is not Java. But it is the language closest to Java in the .NET framework. * This task compiles jsharp source (.java files), and * generates a .NET managed exe or dll. * <p> * * <p>For historical reasons the pattern * <code>**</code><code>/*.java</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * @see <A=ref="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_vjsharp/html/vjoriMicrosoftVisualJ.asp"> * Visual J++ online documentation</a> * * @since ant1.6 * @ant.task category="dotnet" name="jsharpc" */public class JSharp extends DotnetCompile {    /**     * hex base address     */    String baseAddress;    /** /x option to disable J++ and J# lang extensions     *     */    boolean pureJava = true;    /**     * whether to make package scoped stuff public or assembly scoped     */    boolean secureScoping = false;    public JSharp() {        setExecutable("vjc");    }    public void setBaseAddress(String baseAddress) {        this.baseAddress = baseAddress;    }    /**     * do we want pure java (default, true) or corrupted J#?     * @param pureJava     */    public void setPureJava(boolean pureJava) {        this.pureJava = pureJava;    }    /**     * Make package scoped code visible to the current assembly only (default: false)     * .NET does not have package scoping. Instead it has assembly, private and public.     * By default, package content is public to all.     * @param secureScoping     */    public void setSecureScoping(boolean secureScoping) {        this.secureScoping = secureScoping;    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return ".java";    }    /**     * add jvc specific commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        if (pureJava) {            command.addArgument("/x:all");        }        if (secureScoping) {            command.addArgument("/securescoping");        }    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }    /**     * validation code     * @throws  org.apache.tools.ant.BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * This task compiles Visual Basic.NET source into executables or modules. * The task requires vbc.exe on the execute path, unless it or an equivalent * program is specified in the <tt>executable</tt> parameter * * <p> * All parameters are optional: &lt;vbc/&gt; should suffice to produce a debug * build of all *.vb files. * * <p> * The task is a directory based task, so attributes like * <tt>includes=&quot;**\/*.vb&quot;</tt> and * <tt>excludes=&quot;broken.vb&quot;</tt> can be used to control * the files pulled in. By default, * all *.vb files from the project folder down are included in the command. * When this happens the destFile -if not specified- * is taken as the first file in the list, which may be somewhat hard to control.   Specifying the output file with <tt>destfile</tt> is prudent. </p> <p> * Also, dependency checking only works if destfile is set. * * <p>For historical reasons the pattern * <code>**</code><code>/*.vb</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * As with &lt;csc&gt; nested <tt>src</tt> filesets of source, * reference filesets, definitions and resources can be provided. * * <p> * Example * </p> * <pre>&lt;vbc *   optimize=&quot;true&quot; *   debug=&quot;false&quot; *   warnLevel=&quot;4&quot; *   targetType=&quot;exe&quot; *   definitions=&quot;RELEASE&quot; *   excludes=&quot;src/unicode_class.vb&quot; *   mainClass = &quot;MainApp&quot; *   destFile=&quot;NetApp.exe&quot; *   optionExplicit=&quot;true&quot; *   optionCompare=&quot;text&quot; *   references="System.Xml,System.Web.Xml" *   &gt; *          &lt;reference file="${testCSC.dll}" /&gt; *          &lt;define name="RELEASE" /&gt; *          &lt;define name="DEBUG" if="debug.property"/&gt; *          &lt;define name="def3" unless="def2.property"/&gt; *   &lt;/vbc&gt; </pre> * @ant.task    name="vbc" category="dotnet" */public class VisualBasicCompile extends DotnetCompile {    /**     * Compiler option to remove integer checks. Default: false.     */    private boolean removeIntChecks = false;    /**     * Require explicit declaration of variables? Default: false.     */    private boolean optionExplicit = false;    /**     * Enforce strict language semantics? Default: false.     */    private boolean optionStrict = false;    /**     * Whether to compare strings as "text" or "binary". Default: "binary".     */    private String optionCompare;    /**     * Root namespace for all type declarations.     */    private String rootNamespace;    /**     * Declare global imports fornamespaces in referenced metadata files.     */    private String imports;    /**     * Constructor for VisualBasicCompile.     */    public VisualBasicCompile() {        clear();    }    /**     *  reset all contents.     */    public void clear() {        super.clear();        imports = null;        rootNamespace = null;        optionCompare = null;        optionExplicit = false;        optionStrict = false;        removeIntChecks = false;        setExecutable("vbc");    }    /**     *  get the argument or null for no argument needed     *  This is overridden from DotnetCompile.java because VBC uses     *  "/win32resource:" rather than "/win32res:"     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (getWin32Res() != null) {            return "/win32resource:" + getWin32Res().toString();        } else {            return null;        }    }    /**     * Whether to remove integer checks. Default false.     * @param  flag  on/off flag     */    public void setRemoveIntChecks(boolean flag) {        removeIntChecks = flag;    }    /**     * Get the flag for removing integer checks.     * @return    true if flag is turned on     */    public boolean getRemoveIntChecks() {        return removeIntChecks;    }    /**     * Form the option string for removeIntChecks.     * @return The parameter string.     */    public String getRemoveIntChecksParameter() {        return "/removeintchecks" + (removeIntChecks ? "+" : "-");    }    /**     * Whether to require explicit declaration of variables.     * @param  flag  on/off flag     */    public void setOptionExplicit(boolean flag) {        optionExplicit = flag;    }    /**     * Get the flag for whether to require explicit declaration of variables.     *@return    true if flag is turned on     */    public boolean getOptionExplicit() {        return optionExplicit;    }    /**     * Form the option string for optionExplicit..     * @return The parameter string.     */    public String getOptionExplicitParameter() {        return "/optionexplicit" + (optionExplicit ? "+" : "-");    }    /**     * Enforce strict language semantics.     * @param  flag  on/off flag     */    public void setOptionStrict(boolean flag) {        optionStrict = flag;    }    /**     * Get the flag for whether to enforce strict language semantics.     * @return    true if flag is turned on     */    public boolean getOptionStrict() {        return optionStrict;    }    /**     * For the option string for optionStrict.     * @return The parameter string.     */    public String getOptionStrictParameter() {        return "/optionstrict" + (optionStrict ? "+" : "-");    }    /**     * Specifies the root namespace for all type declarations.     * @param rootNamespace a root namespace.     */    public void setRootNamespace(String rootNamespace) {        this.rootNamespace = rootNamespace;    }    /**     * Get the root namespace.     * @return  the root namespace.     */    public String getRootNamespace() {        return this.rootNamespace;    }    /**     * Form the option string for rootNamespace.     * @return  the root namespace option string.     */    protected String getRootNamespaceParameter() {        if (rootNamespace != null && rootNamespace.length() != 0) {            return "/rootnamespace:" + rootNamespace;        } else {            return null;        }    }    /**     * Declare global imports for namespaces in referenced metadata files.     * @param imports the imports string     */    public void setImports(String imports) {        this.imports = imports;    }    /**     * Get global imports for namespaces in referenced metadata files.     * @return  the imports string.     */    public String getImports() {        return this.imports;    }    /**     * Format the option for imports.     * @return  the formatted import option.     */    protected String getImportsParameter() {        if (imports != null && imports.length() != 0) {            return "/imports:" + imports;        } else {            return null;        }    }    /**     * Specify binary- or text-style string comparisons. Defaults     * to "binary"     * @param optionCompare the option compare style. "text" | "binary".     */    public void setOptionCompare(String optionCompare) {        if ("text".equalsIgnoreCase(optionCompare)) {            this.optionCompare = "text";        } else {            this.optionCompare = "binary";        }    }    /**     * "binary" or "text" for the string-comparison style.     * @return  the option compare style.     */    public String getOptionCompare() {        return this.optionCompare;    }    /**     * Format the option for string comparison style.     * @return  The formatted option.     */    protected String getOptionCompareParameter() {        if (optionCompare != null && "text".equalsIgnoreCase(optionCompare)) {            return "/optioncompare:text";        } else {            return "/optioncompare:binary";        }    }    /**     * implement VBC commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getRemoveIntChecksParameter());        command.addArgument(getImportsParameter());        command.addArgument(getOptionExplicitParameter());        command.addArgument(getOptionStrictParameter());        command.addArgument(getRootNamespaceParameter());        command.addArgument(getOptionCompareParameter());    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ",";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return "vb";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, false);    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import java.util.Iterator;import java.net.MalformedURLException;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.util.FileUtils;/** * Converts a WSDL file or URL resource into a .NET language. * * Why add a wrapper to the MS WSDL tool? * So that you can verify that your web services, be they written with Axis or *anyone else's SOAP toolkit, work with .NET clients. * *This task is dependency aware when using a file as a source and destination; *so if you &lt;get&gt; the file (with <code>usetimestamp="true"</code>) then *you only rebuild stuff when the WSDL file is changed. Of course, *if the server generates a new timestamp every time you ask for the WSDL, *this is not enough...use the &lt;filesmatch&gt; &lt;condition&gt; to *to byte for byte comparison against a cached WSDL file then make *the target conditional on that test failing. * See "Creating an XML Web Service Proxy", "wsdl.exe" docs in * the framework SDK documentation * @version     0.5 * @ant.task    category="dotnet" * @since       Ant 1.5 */public class WsdlToDotnet extends Task  {    /**     * used for timestamp checking     */    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * name of output file (required)     */    private File destFile = null;    /**     * language; defaults to C#     */    private String language = "CS";    /**     * flag set to true to generate server side skeleton     */    private boolean server = false;    /**     * namespace     */    private String namespace = null;    /**     *  flag to control action on execution trouble     */    private boolean failOnError = true;    /**     *  any extra command options?     */    protected String extraOptions = null;    /**     * protocol string. Exact value set depends on SOAP stack version.     * @since Ant 1.7     */    private String protocol = null;    /**     * should errors come in an IDE format. This     * is WSE only.     * @since Ant 1.7     */    private boolean ideErrors = false;    /**     * filesets of file to compile     * @since Ant 1.7     */    private Vector schemas = new Vector();    /**     * our WSDL file.     * @since ant1.7     */    private Schema wsdl = new Schema();    /**     * compiler     * @since ant1.7     */    private Compiler compiler = null;    /**     * error message: dest file is a directory     */    public static final String ERROR_DEST_FILE_IS_DIR = "destination file is a directory";    /**     * error message: no dest file     */    public static final String ERROR_NO_DEST_FILE = "destination file must be specified";    /**     * Name of the file to generate. Required     * @param destFile filename     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * Sets the URL to fetch. Fetching is by wsdl.exe; Ant proxy settings     * are ignored; either url or srcFile is required.     * @param url url to save     */    public void setUrl(String url) {        wsdl.setUrl(url);    }    /**     * The local WSDL file to parse; either url or srcFile is required.     * @param srcFile WSDL file     */    public void setSrcFile(File srcFile) {        wsdl.setFile(srcFile);    }    /**     * set the language; one of "CS", "JS", or "VB"     * optional, default is CS for C# source     * @param language language to generate     */    public void setLanguage(String language) {        this.language = language;    }    /**     * flag to enable server side code generation;     * optional, default=false     * @param server server-side flag     */    public void setServer(boolean server) {        this.server = server;    }    /**     * namespace to place  the source in.     * optional; default ""     * @param namespace new namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * Whether or not a failure should halt the build.     * Optional - default is <code>true</code>.     * @param failOnError new failure option     */    public void setFailOnError(boolean failOnError) {        this.failOnError = failOnError;    }    /**     *  Any extra WSDL.EXE options which aren't explicitly     *  supported by the ant wrapper task; optional     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * Defines wether errors are machine parseable.     * Optional, default=true     *     * @since Ant 1.7     * @param ideErrors     */    public void setIdeErrors(boolean ideErrors) {        this.ideErrors = ideErrors;    }    /**     * what protocol to use. SOAP, SOAP1.2, HttpPost and HttpGet     * are the base options. Different version and implementations may.     * offer different options.     * @since Ant 1.7     *     * @param protocol     */    public void setProtocol(String protocol) {        this.protocol = protocol;    }    /**     * add a new source schema to the compilation     * @since Ant 1.7     *     * @param source     */    public void addSchema(Schema source) {        schemas.add(source);    }    /**     * flag to trigger turning a filename into a file:url     * ignored for the mono compiler.     * @param b     */    public void setMakeURL(boolean b) {        wsdl.setMakeURL(b);    }    /**     * identify the compiler     * @since Ant 1.7     * @param compiler     */    public void setCompiler(Compiler compiler) {        this.compiler = compiler;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException(ERROR_NO_DEST_FILE);        }        if (destFile.isDirectory()) {            throw new BuildException(                    ERROR_DEST_FILE_IS_DIR);        }        wsdl.validate();    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        if ("WsdlToDotnet".equals(getTaskType())) {            log("Warning: the task name <WsdlToDotnet> is deprecated. Use <wsdltodotnet> (all lowercase) instead.", Project.MSG_WARN);        }        if (compiler == null) {            compiler = Compiler.createDefaultCompiler();        }        validate();        NetCommand command = new NetCommand(this,                "WSDL",                compiler.getCommand());        command.setFailOnError(failOnError);        //fill in args        compiler.applyExtraArgs(command);        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/language:", language);        if (server) {            command.addArgument("/server");        }        command.addArgument("/namespace:", namespace);        if (protocol != null) {            command.addArgument("/protocol:" + protocol);        }        if (ideErrors) {            command.addArgument("/parsableErrors");        }        command.addArgument(extraOptions);        //set source and rebuild options        boolean rebuild = true;        long destLastModified = -1;        //rebuild unless the dest file is newer than the source file        if (destFile.exists()) {            destLastModified = destFile.lastModified();            rebuild = isRebuildNeeded(wsdl, destLastModified);        }        String path;        //mark for a rebuild if the dest file is newer        path = wsdl.evaluate();        if (!compiler.supportsAbsoluteFiles() && wsdl.getFile() != null) {            // Mono 1.0's wsdl doesn't deal with absolute paths            File f = wsdl.getFile();            command.setDirectory(f.getParentFile());            path = f.getName();        }        command.addArgument(path);        //add in any extra files.        //this is an error in mono, but we do not warn on it as they may fix that outside        //the ant build cycle.        Iterator it = schemas.iterator();        while (it.hasNext()) {            Schema schema = (Schema) it.next();            //mark for a rebuild if we are newer            rebuild |= isRebuildNeeded(schema, destLastModified);            command.addArgument(schema.evaluate());        }        //conditionally compile        if (rebuild) {            command.runCommand();        }    }    /**     * checks for a schema being out of data     * @param schema url/file     * @param destLastModified timestamp, -1 for no dest     * @return true if a rebuild is needed.     */    private boolean isRebuildNeeded(Schema schema, long destLastModified) {        if (destLastModified == -1) {            return true;        }        return !FILE_UTILS.isUpToDate(schema.getTimestamp(), destLastModified);    }    /**     * nested schema class     * Only supported on NET until mono add multi-URL handling on the command line     */    public static class Schema {        private File file;        private String url;        private boolean makeURL = false;        public static final String ERROR_NONE_DECLARED = "One of file and url must be set";        public static final String ERROR_BOTH_DECLARED = "Only one of file or url can be set";        public static final String ERROR_FILE_NOT_FOUND = "Not found: ";        public static final String ERROR_FILE_IS_DIR = "File is a directory: ";        public static final String ERROR_NO_URL_CONVERT = "Could not URL convert ";        /**         * validate the schema         */        public  void validate() {            if (file != null) {                if (!file.exists()) {                    throw new BuildException(ERROR_FILE_NOT_FOUND + file.toString());                }                if (file.isDirectory()) {                    throw new BuildException(ERROR_FILE_IS_DIR + file.toString());                }            }            if (file != null && url != null) {                throw new BuildException(ERROR_BOTH_DECLARED);            }            if (file == null && url == null) {                throw new BuildException(ERROR_NONE_DECLARED);            }        }        /**         * Validate our settings.         * @return either the URL or the full file path         */        public String evaluate() {            validate();            if (url != null) {                return getUrl();            }            if (makeURL) {                try {                    return file.toURL().toExternalForm();                } catch (MalformedURLException e) {                    throw new BuildException(ERROR_NO_URL_CONVERT + file);                }            }            return file.toString();        }        public File getFile() {            return file;        }        /**         * name of a file to use as a source of WSDL or XSD data         * @param file         */        public void setFile(File file) {            this.file = file;        }        public String getUrl() {            return url;        }        /**         * url of a resource.         * URLs have no timestamp checking, and are not validated         * @param url         */        public void setUrl(String url) {            this.url = url;        }        public boolean isMakeURL() {            return makeURL;        }        /**         * flag to request that a file is turned into an absolute file: URL         * before being passed to the WSDL compiler         * @param makeURL         */        public void setMakeURL(boolean makeURL) {            this.makeURL = makeURL;        }        /**         * Gets the file timestamp.         * @return the timestamp of a file, or -1 for a URL (meaning we do not know its age)         */        public long getTimestamp() {            if (file != null) {                return file.lastModified();            } else {                return -1;            }        }    }    /**     * The enumerated values for our compiler     */    public static class Compiler extends EnumeratedAttribute {        public static final String COMPILER_MS = "microsoft";        public static final String COMPILER_MONO = "mono";        public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono";        String[] compilers = {            COMPILER_MS,            COMPILER_MONO,            COMPILER_MS_ON_MONO        };        public static final String EXE_WSDL = "wsdl";        public static final String EXE_MONO = "mono";        /**         * programs to run         */        String[] compilerExecutables = {            EXE_WSDL,            EXE_WSDL,            EXE_MONO        };        /**         * extra things         */        String[][] extraCompilerArgs = {            {},            {},            {EXE_WSDL + ".exe"}        };        boolean[] absoluteFiles = {            true,            false,            true        };        /**         * This is the only method a subclass needs to implement.         *         * @return an array holding all possible values of the enumeration.         *         The order of elements must be fixed so that <tt>indexOfValue(String)</tt>         *         always return the same index for the same value.         */        public String[] getValues() {            return compilers;        }        /**         * Create the default compiler for this platform.         * @return the default compiler         */        public static Compiler createDefaultCompiler() {            Compiler c = new Compiler();            String compilerName;            compilerName = Os.isFamily("windows") ? COMPILER_MS : COMPILER_MONO;            c.setValue(compilerName);            return c;        }        /**         * return the command to run         * @return the command         */        public String getCommand() {            return compilerExecutables[getIndex()];        }        /**         * return any extra arguments for the compiler         * @return extra compiler arguments         */        public String[] getExtraArgs() {            return extraCompilerArgs[getIndex()];        }        public boolean supportsAbsoluteFiles() {            return absoluteFiles[getIndex()];        }        /**         * apply any extra arguments of this class         * @param command         */        public void applyExtraArgs(NetCommand command) {            String[] args = getExtraArgs();            for (int i = 0; i < args.length; i++) {               command.addArgument(args[i]);            }        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.wix;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.ant.dotnet.build.AbstractBuildTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;import java.io.File;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;/** * Task to run the WiX utility to create MSI files from an XML description. * * @see http://sf.net/projects/wix */public class WixTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source files.     */    private ArrayList sources = new ArrayList();    /**     * Additional source files (include files in the case of candle,     * or media/files/whatever in the case of light).     */    private ArrayList moreSources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * What to do.     */    private Mode mode;    /**     * Where is WiX installed?     */    private File wixHome = null;    /**     * Where to place the generated .wixobj files.     */    private File wixobjDestDir = null;    /**     * list of parameters for the preprocessor.     */    private ArrayList parameters = new ArrayList();    public WixTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>candle</code> may include more files than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * The main target file.     *     * @param File object of the main target file.     */    public void setTarget(File f) {        target = f;    }    /**     * A set of source files.     */    public void addSources(FileSet fs) {        sources.add(fs);    }    /**     * A set of additional source files (include files in the case of     * candle, or media/files/whatever in the case of light).     *     * <p>Unlike the files specified as sources, these will not be     * passed on the command line, they only help Ant to determine     * whether the target is out-of-date.</p>     */    public void addMoreSources(FileSet fs) {        moreSources.add(fs);    }    /**     * Sets the installation directory of WiX.     *     * <p>If omitted, Ant will assume that WiX's executables can be     * found on the PATH.</p>     */    public void setWixHome(File f) {        wixHome = f;    }    /**     * Whether to run candle, light or both.     */    public void setMode(Mode m) {        mode = m;    }    /**     * Sets the destination directory for wixobj files generated by candle.     *     * <p>Let's candle decide and assumes they'll be created in the     * current working directory.</p>     */    public void setWixobjDestDir(File f) {        wixobjDestDir = f;    }    /**     * A parameter to pass to candle.exe.     */    public final void addCandleParameter(AbstractBuildTask.Property t) {        parameters.add(t);    }    public void execute() {        if (source == null && sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        }        if (source != null && !source.exists()) {            throw new BuildException("Source file " + source                                     + " doesn't exist.");        }        String m = Mode.BOTH;        if (mode != null) {            m = mode.getValue();        }        if (target == null && !m.equals(Mode.CANDLE)) {            throw new BuildException("You must specify the target if you want"                                     + " to run light.");        }        Collection lightSources = null;        if (!m.equals(Mode.LIGHT)) {            lightSources = doCandle();        } else {            lightSources = new HashSet();            if (source != null) {                lightSources.add(source);            }            if (sources.size() > 0) {                lightSources.addAll(grabFiles(sources));            }        }        if (!m.equals(Mode.CANDLE)) {            Collection moreLightSources = Collections.EMPTY_SET;            if (moreSources.size() > 0) {                moreLightSources = grabFiles(moreSources);            }            doLight(lightSources, moreLightSources);        }    }    /**     * Invoke candle on all sources that are newer than their targets.     *     * @return a set of File objects pointing to the generated files.     */    private Collection doCandle() {        Set s = new HashSet();        if (source != null) {            s.add(source);        }        if (sources != null) {            s.addAll(grabFiles(sources));        }        Set ms = new HashSet();        if (moreSources != null) {            ms.addAll(grabFiles(moreSources));        }        Set toProcess = new HashSet();        Set generatedTargets = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            File thisSource = (File) iter.next();            File t = getTarget(thisSource);            generatedTargets.add(t);            if (isOutOfDate(t, thisSource, ms)) {                toProcess.add(thisSource);            }        }        if (toProcess.size() != 0) {            runCandle(toProcess);            return generatedTargets;        }        return Collections.EMPTY_SET;    }    /**     * Invoke light on all sources that are newer than their targets.     */    private void doLight(Collection lightSources,                         Collection moreLightSources) {        Set tmp = new HashSet(lightSources);        tmp.addAll(moreLightSources);        if (isOutOfDate(target, tmp)) {            runLight(lightSources);        }    }    /**     * Run candle passing all files of the collection on the command line.     */    private void runCandle(Collection s) {        run(wixExecutable("candle.exe"), s, null, wixobjDestDir, parameters);    }    /**     * Run light passing all files of the collection on the command line.     */    private void runLight(Collection s) {        run(wixExecutable("light.exe"), s, target, null, Collections.EMPTY_LIST);    }    /**     * returns an absolute path for the given executable if wixHome     * has been specified, the given name otherwise.     */    private String wixExecutable(String name) {        return wixHome == null ? name            : new File(wixHome, name).getAbsolutePath();    }    /**     * Runs the specified command passing all files of the collection     * on the command line - potentially adding an /out parameter.     */    private void run(String executable, Collection s, File target,                     File runInDir, Collection params) {        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      executable, null);        if (runInDir != null) {            exec.setDir(runInDir);        }        exec.setFailonerror(true);        exec.setTaskType("wix");        exec.createArg().setValue("/nologo");        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue(f.getAbsolutePath());        }        if (target != null) {            exec.createArg().setValue("/out");            exec.createArg().setValue(target.getAbsolutePath());        }                iter = params.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                (AbstractBuildTask.Property) iter.next();            exec.createArg().setValue("-d" + p.getName() + "=" + p.getValue());        }        exec.execute();    }    /**     * Is t older than s or any of the files in list?     */    private boolean isOutOfDate(File t, File s, Collection l) {        return t.lastModified() < s.lastModified() || isOutOfDate(t, l);    }    /**     * Is t older than any of the files in list?     */    private boolean isOutOfDate(File t, Collection l) {        Iterator iter = l.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            if (t.lastModified() < f.lastModified()) {                return true;            }        }        return false;    }    /**     * Turn the fileset collection into a list of Files.     */    private Collection grabFiles(Collection s) {        Set r = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            FileSet fs = (FileSet) iter.next();            DirectoryScanner ds = fs.getDirectoryScanner(getProject());            String[] f = ds.getIncludedFiles();            File base = fs.getDir(getProject());            for (int i = 0; i < f.length; i++) {                r.add(new File(base, f[i]));            }        }        return r;    }    /**     * Generates the name of a candle target from the source file.     *     * <p>Simply chops of the extension, adds .wixobj and calculates     * the absolute path based on wixobjDestDir.</p>     */    private File getTarget(File s) {        String name = s.getName();        int dot = name.lastIndexOf(".");        if (dot > -1) {            name = name.substring(0, dot) + ".wixobj";        } else {            name = name + ".wixobj";        }        return wixobjDestDir == null            ? new File(name) : new File(wixobjDestDir, name);    }    public static class Mode extends EnumeratedAttribute {        private final static String CANDLE = "candle";        private final static String LIGHT = "light";        private final static String BOTH = "both";        public Mode() {            super();        }        public String[] getValues() {            return new String[] {CANDLE, LIGHT, BOTH,};        }    }}
Apache .NET Ant Library/*  *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. *  */ /** * this is a j# class, not a java one. */public class jsharp {        public static void main(String args[]) {		System.out.println("hello, I look like Java, but I'm really J#");    }    }
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the DotNetExecTask task, based off Ant's DotnetTest. * */public class DotNetExecTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public DotNetExecTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "dotnetexec.xml");    }    /**     * The teardown method for JUnit     */    public void tearDown() {        executeTarget("teardown");    }    /**     * A unit test for JUnit     */    public void testCSC() throws Exception {        executeTarget("testCSC");    }}
Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the MSBuildTask task. */public class MSBuildTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public MSBuildTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "msbuild.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }    public void testNestedTask() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("nested-task", "foo is bar");        }    }}
Apache .NET Ant Library/* * Copyright 2003-2005 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the NAntTask task. */public class NAntTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public NAntTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "nant.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }    public void testNestedTask() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-task", "foo is bar");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the NUnitTask task. */public class NUnitTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public NUnitTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "nunit.xml");    }    /**     * The teardown method for JUnit     */    public void tearDown() {        executeTarget("teardown");    }    public void testNoAssembly() {        expectSpecificBuildException("no-assembly", "no assembly",                                      "You must specify at least one test assembly.");    }    public void testPass() {        if (getProject().getProperty("nunit.found") != null) {            expectLogContaining("passing-test",                                 "Tests run: 1, Failures: 0, Not run: 0");        }    }    public void testFail() {        if (getProject().getProperty("nunit.found") != null) {            expectLogContaining("failing-test",                                 "Tests run: 1, Failures: 1, Not run: 0");        }    }    public void testFailOnFail() {        if (getProject().getProperty("nunit.found") != null) {            expectBuildException("failing-test-with-fail", "test should fail");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import org.apache.tools.ant.BuildFileTest;/** * Tests the MSBuildTask task. */public class MSBuildTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public MSBuildTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "msbuild.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }    public void testNestedTask() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("nested-task", "foo is bar");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import org.apache.tools.ant.BuildFileTest;/** * Tests the NAntTask task. */public class NAntTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public NAntTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "nant.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }    public void testNestedTask() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-task", "foo is bar");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.tools.ant.BuildFileTest;/** * Tests the WsdlToDotnet task. * * @since Ant 1.5 */public class WsdlToDotnetTest extends BuildFileTest {    /**     * dir for taskdefs     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * message from exec     */    private static final String WSDL_FAILED = "WSDL returned:";    /**     * Constructor     *     * @param name testname     */    public WsdlToDotnetTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "WsdlToDotnet.xml");    }    /**     * The teardown method for JUnit     */    public void tearDown() {        executeTarget("teardown");    }    /**     * A unit test for JUnit     */    public void testNoParams() throws Exception {        expectBuildExceptionContaining("testNoParams",                "expected failure",                WsdlToDotnet.ERROR_NO_DEST_FILE);    }    /**     * A unit test for JUnit     */    public void testNoSrc() throws Exception {        expectBuildExceptionContaining("testNoSrc",                "expected failure",                WsdlToDotnet.Schema.ERROR_NONE_DECLARED);    }    /**     * A unit test for JUnit     */    public void testDestIsDir() throws Exception {        expectBuildExceptionContaining("testDestIsDir",                "expected failure",                WsdlToDotnet.ERROR_DEST_FILE_IS_DIR);    }    /**     * A unit test for JUnit     */    public void testBothSrc() throws Exception {        expectBuildExceptionContaining("testBothSrc",                "expected failure",                WsdlToDotnet.Schema.ERROR_BOTH_DECLARED);    }     /**     * A unit test for JUnit     */    public void testSrcIsDir() throws Exception {        expectBuildExceptionContaining("testSrcIsDir",                "expected failure",                WsdlToDotnet.Schema.ERROR_FILE_IS_DIR);    }    /**     * A unit test for JUnit     */    public void testSrcIsMissing() throws Exception {        expectBuildExceptionContaining("testSrcIsMissing",                "expected failure",                WsdlToDotnet.Schema.ERROR_FILE_NOT_FOUND);    }    /**     * A unit test for JUnit     */    public void testLocalWsdl() throws Exception {        executeTarget("testLocalWsdl");    }    /**     * A unit test for JUnit     */    public void testLocalWsdlServer() throws Exception {        executeTarget("testLocalWsdlServer");    }     /**     * A unit test for JUnit     */    public void testInvalidExtraOps() throws Exception {        expectBuildExceptionContaining("testInvalidExtraOps",                "expected failure",                WSDL_FAILED);    }    /**     * A unit test for JUnit     */    public void testLocalWsdlVB() throws Exception {        executeTarget("testLocalWsdlVB");    }    /**     * A unit test for JUnit     */    public void testLocalWsdlServerVB() throws Exception {        executeTarget("testLocalWsdlServerVB");    }     /**     * A unit test for JUnit     */    public void testInvalidExtraOpsVB() throws Exception {        expectBuildExceptionContaining("testInvalidExtraOpsVB",                "expected failure",                WSDL_FAILED);    }    /**     * as if parseable errors were not ignored, mono and WSE1.0 would     * crash and burn. So here we verify the property exists,     * and that it is not passed to the app when false     */    public void testParseableErrorsIgnoredWhenFalse() throws Exception {        executeTarget("testLocalWsdl");    }    /**     * A unit test for JUnit     */    public void testSchemaFileMustExist() throws Exception {        expectBuildExceptionContaining("testSchemaFileMustExist",                "expected failure",                WsdlToDotnet.Schema.ERROR_FILE_NOT_FOUND);    }    /**     * A unit test for JUnit     */    public void testSchemaFileMustHaveOneOptionOnly() throws Exception {        expectBuildExceptionContaining("testSchemaFileMustHaveOneOptionOnly",                "expected failure",                WsdlToDotnet.Schema.ERROR_BOTH_DECLARED);    }    /**     * A unit test for JUnit     */    public void testSchemaMustBeSet() throws Exception {        expectBuildExceptionContaining("testSchemaMustBeSet",                "expected failure",                WsdlToDotnet.Schema.ERROR_NONE_DECLARED);    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.taskdefs.Execute;import org.apache.tools.ant.taskdefs.ExecTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.Environment;/** * Specialized <exec> that knows how to deal with Mono vs. Microsoft's * VM - and maybe Rotor at some point. */public class DotNetExecTask extends ExecTask {    /**     * "Magic" VM argument for Microsoft's VM.     */    private static final String MS_VM = "microsoft";    /**     * The user supplied executable attribute.     */    private String executable;    /**     * The .NET VM to use.     *     * <p>Defaults to Microsoft's on Windows and mono on any other     * platform.</p>     */    private String vm = Os.isFamily("windows") ? MS_VM : "mono";    /**     * Name of property to set if execution fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Empty Constructor.     */    public DotNetExecTask() {        super();    }    /**     * Set the name of the executable program.     * @param value the name of the executable program     */    public void setExecutable(String value) {        this.executable = value;    }    /**     * Set the name of the executable for the virtual machine or the     * magic name "microsoft" which implies that we can invoke the     * executable directly.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the property to set if execution fails.     *     * <p>Not exposed as an attribute of the task, it just supports     * tasks like &lt;nunit&gt; which delegate to instances of this     * class.</p>     *     * @since 1.0 Beta 2     */    public void internalSetErrorProperty(String name) {        errorProperty = name;    }    /**     * Do the work.     *     * @throws BuildException if executable is empty or &lt;exec&gt;     * throws an exception.     */    public void execute() throws BuildException {        if (executable == null) {            throw new BuildException("The executable attribute is required");        }        setupCommandline();        super.execute();    }    /**     * Overridden to support the error-property handling required by     * NUnit, NAnt and friends.     *     * @since 1.0 Beta 2     */    protected void maybeSetResultPropertyValue(int result) {        if (errorProperty != null && Execute.isFailure(result)) {            getProject().setNewProperty(errorProperty, String.valueOf(true));        }        super.maybeSetResultPropertyValue(result);    }    /**     * If the inherited Commandline doesn't know about the executable     * yet, set it and deal with the vm attribute.     *     * <p>The inherited Commandline may know the executable already if     * this task instance is getting reused.</p>     */    protected void setupCommandline() {        if (cmdl.getExecutable() == null) {            if (vm.equals(MS_VM)) {                // can invoke executable directly                super.setExecutable(executable);            } else {                boolean b = getResolveExecutable();                // Mono wants the absolte path of the assembly                setResolveExecutable(b || isMono(vm));                super.setExecutable(vm);                cmdl.createArgument(true)                    .setValue(resolveExecutable(executable, isMono(vm)));                setResolveExecutable(b);            }        }    }    /**     * Whether the given vm looks like the Mono executable.     */    protected final static boolean isMono(String vm) {        return "mono".equals(vm) || "mint".equals(vm);    }    /**     * Creates an instance of this task based on a different tasks settings.     */    public static DotNetExecTask getTask(Task t, String vm,                                          String executable,                                         Environment env) {        DotNetExecTask exec = new DotNetExecTask();        if (vm != null) {            exec.setVm(vm);        }        exec.setProject(t.getProject());        exec.setExecutable(executable);        exec.setTaskName(t.getTaskName());        if (env != null) {            String[] environment = env.getVariables();            if (environment != null) {                for (int i = 0; i < environment.length; i++) {                    int idx = environment[i].indexOf("=");                    Environment.Variable v = new Environment.Variable();                    v.setKey(environment[i].substring(0, idx));                    v.setValue(environment[i].substring(idx + 1));                    exec.addEnv(v);                }            }        }                return exec;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Task to take a .NET or Mono -generated managed executable and turn it * into ILASM assembly code. Useful when converting imported typelibs into * assembler before patching and recompiling, as one has to do when doing * advanced typelib work. * <p> * As well as generating the named output file, the ildasm program * will also generate resource files <code>Icons.resources</code> * <code>Message.resources</code> and a .res file whose filename stub is derived * from the source in ways to obscure to determine. * There is no way to control whether or not these files are created, or where they are created * (they are created in the current directory; their names come from inside the * executable and may be those used by the original developer). This task * creates the resources in the directory specified by <code>resourceDir</code> if * set, else in the same directory as the <code>destFile</code>. * * <p> * This task requires the .NET SDK installed and ildasm on the path. * To disassemble using alternate CLR systems, set the executable attribute * to the name/path of the alternate implementation -one that must * support all the classic ildasm commands. * * <p> * Dependency logic: the task executes the command if the output file is missing * or older than the source file. It does not take into account changes * in the options of the task, or timestamp differences in resource files. * When the underlying ildasm executable fails for some reason, it leaves the * .il file in place with some error message. To prevent this from confusing * the dependency logic, the file specified by the <code>dest</code> * attribute is <i>always</i> deleted after an unsuccessful build. * @ant.task category="dotnet" */public class Ildasm extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();        /**     * source file (mandatory)     */    private File sourceFile;    /**     * dest file (mandatory)     */    private File destFile;    /**     * progress bar switch     */    private boolean progressBar = false;    /**     * what is our encoding     */    private String encoding;    /**     * /bytes flag for byte markup     */    private boolean bytes = false;    /**     * line numbers? /linenum     */    private boolean linenumbers = false;    /**     * /raweh flag for raw exception handling     */    private boolean rawExceptionHandling = false;    /**     * show the source; /source     */    private boolean showSource = false;    /**     * /quoteallnames to quote all names     */    private boolean quoteallnames = false;    /**     * /header for header information     */    private boolean header = false;    /**     * when false, sets the /noil attribute     * to suppress assembly info     */    private boolean assembler = true;    /**     * include metadata     * /tokens     */    private boolean metadata = false;    /**     * what visibility do we want.     *     */    private String visibility;    /**     * specific item to disassemble     */    private String item;    /**     * override for the executable     */    private String executable = "ildasm";    /**     *  name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    private File resourceDir;    /**     * Set the name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    public void setResourceDir(File resourceDir) {        this.resourceDir = resourceDir;    }    /**     * override the name of the executable (normally ildasm) or set     * its full path. Do not set a relative path, as the ugly hacks     * needed to create resource files in the dest directory     * force us to change to this directory before running the application.     * i.e use &lt;property location&gt to create an absolute path from a     * relative one before setting this value.     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     * Select the output encoding: ascii, utf8 or unicode     * @param encoding     */    public void setEncoding(EncodingTypes encoding) {        this.encoding = encoding.getValue();    }    /**     * enable (default) or disable assembly language in the output     * @param assembler     */    public void setAssembler(boolean assembler) {        this.assembler = assembler;    }    /**     * enable or disable (default) the original bytes as comments     * @param bytes     */    public void setBytes(boolean bytes) {        this.bytes = bytes;    }    /**     * the output file (required)     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * include header information; default false.     * @param header     */    public void setHeader(boolean header) {        this.header = header;    }    /**     * name a single item to decode; a class or a method     * e.g item="Myclass::method" or item="namespace1::namespace2::Myclass:method(void(int32))     * @param item     */    public void setItem(String item) {        this.item = item;    }    /**     * include line number information; default=false     * @param linenumbers     */    public void setLinenumbers(boolean linenumbers) {        this.linenumbers = linenumbers;    }    /**     * include metadata information     * @param metadata     */    public void setMetadata(boolean metadata) {        this.metadata = metadata;    }    /**     * show a graphical progress bar in a window during the process; off by default     * @param progressBar     */    public void setProgressBar(boolean progressBar) {        this.progressBar = progressBar;    }    /**     * quote all names.     * @param quoteallnames     */    public void setQuoteallnames(boolean quoteallnames) {        this.quoteallnames = quoteallnames;    }    /**     * enable raw exception handling (default = false)     * @param rawExceptionHandling     */    public void setRawExceptionHandling(boolean rawExceptionHandling) {        this.rawExceptionHandling = rawExceptionHandling;    }    /**     * include the source as comments (default=false)     */    public void setShowSource(boolean showSource) {        this.showSource = showSource;    }    /**     * the file to disassemble -required     * @param sourceFile     */    public void setSourceFile(File sourceFile) {        this.sourceFile = sourceFile;    }    /**     * alternate name for sourceFile     * @param sourceFile     */    public void setSrcFile(File sourceFile) {        setSourceFile(sourceFile);    }    /**     * This method sets the visibility options. It chooses one or more of the following, with + signs to     * concatenate them:     * <pre>     * pub : Public     * pri : Private     * fam : Family     * asm : Assembly     * faa : Family and Assembly     * foa : Family or Assembly     * psc : Private Scope     *</pre>     * e.g. visibility="pub+pri".     * Family means <code>protected</code> in C#;     * @param visibility     */    public void setVisibility(String visibility) {        this.visibility = visibility;    }    /**     *  verify that source and dest are ok     */    private void validate() {        if (sourceFile == null || !sourceFile.exists() || !sourceFile.isFile()) {            throw new BuildException("invalid source");        }        if (destFile == null || destFile.isDirectory()) {            throw new BuildException("invalid dest");        }        if (resourceDir != null                && (!resourceDir.exists() || !resourceDir.isDirectory())) {            throw new BuildException("invalid resource directory");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isDisassemblyNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = sourceFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The .il file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * do the work     * @throws BuildException     */    public void execute() throws BuildException {        validate();        if (!isDisassemblyNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ildasm", executable);        command.setFailOnError(true);        //fill in args        command.addArgument("/text");        command.addArgument("/out=" + destFile.toString());        if (!progressBar) {            command.addArgument("/nobar");        }        if (linenumbers) {            command.addArgument("/linenum");        }        if (showSource) {            command.addArgument("/source");        }        if (quoteallnames) {            command.addArgument("/quoteallnames");        }        if (header) {            command.addArgument("/header");        }        if (!assembler) {            command.addArgument("/noil");        }        if (metadata) {            command.addArgument("/tokens");        }        command.addArgument("/item:", item);        if (rawExceptionHandling) {            command.addArgument("/raweh");        }        command.addArgument(EncodingTypes.getEncodingOption(encoding));        if (bytes) {            command.addArgument("/bytes");        }        command.addArgument("/vis:", visibility);        //add the source file        command.addArgument(sourceFile.getAbsolutePath());        //determine directory: resourceDir if set,        //the dir of the destFile if not        File execDir = resourceDir;        if (execDir == null) {            execDir = destFile.getParentFile();        }        command.setDirectory(execDir);        //now run        try {            command.runCommand();        } catch (BuildException e) {            //forcibly delete the output file in case of trouble            if (destFile.exists()) {                log("Deleting destination file as it may be corrupt");                destFile.delete();            }            //then rethrow the exception            throw e;        }    }    /**     * encoding options; the default is ascii     */    public static class EncodingTypes extends EnumeratedAttribute {        public final static String UNICODE = "unicode";        public final static String UTF8 = "utf8";        public final static String ASCII = "ascii";        public String[] getValues() {            return new String[]{                ASCII,                UTF8,                UNICODE,            };        }        /**         * This method maps from an encoding enum to an encoding option.         * @param enumValue         * @return The encoding option indicated by the enum value.         */        public static String getEncodingOption(String enumValue) {            if (UNICODE.equals(enumValue)) {                return "/unicode";            }            if (UTF8.equals(enumValue)) {                return "/utf8";            }            return null;        }    }    /**     * visibility options for decoding     */    public static class VisibilityOptions extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "pub", //Public                "pri", //Private                "fam", //Family                "asm", //Assembly                "faa", //Family and Assembly                "foa", //Family or Assembly                "psc", //Private Scope            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.Task;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Import a COM type library into the .NET framework. * <p> * * This task is a wrapper to .NET's tlbimport; it imports a tlb file to a NET assembly * by generating a binary assembly (.dll) that contains all the binding * metadata. It uses date timestamps to minimise rebuilds. * <p> * Example * <pre> *     &lt;importtypelib *       srcfile="xerces.tlb" *       destfile="xerces.dll" *       namespace="Apache.Xerces"/&gt; * </pre> * @since Ant 1.6 * @ant.task category="dotnet" */public class ImportTypelib extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * input file; precedes options     */    private File srcFile;    /**     * /out:file     */    private File destFile;    /**     *  /namespace:[string]     */    private String namespace;    /**     * /sysarray     */    private boolean useSysArray = false;    /**     * /unsafe     */    private boolean unsafe = false;    /**     * extra commands?     */    private String extraOptions = null;    /**     * This method names the output file.     *     * This is an operation which is required to have been performed.     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * This method sets what namespace the typelib is to be in.     * This is an operation which is required to have been performed.     * @param namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * This method sets which is the source .tlb file.     * This is an operation which is required to have been performed.     * @param srcFile     */    public void setSrcFile(File srcFile) {        this.srcFile = srcFile;    }    /**     * do you want unsafe code.     * @param unsafe     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     * set this to map a COM SafeArray to the System.Array class     * @param useSysArray     */    public void setUseSysArray(boolean useSysArray) {        this.useSysArray = useSysArray;    }    /**     * set any extra options that are not yet supported by this task.     * @param extraOptions     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException("destination file must be specified");        }        if (destFile.isDirectory()) {            throw new BuildException(                    "destination file is a directory");        }        if (srcFile == null || !srcFile.exists()) {            throw new BuildException(                    "source file does not exist");        }        if (srcFile.isDirectory()) {            throw new BuildException(                    "source file is a directory");        }        if (namespace == null) {            throw new BuildException("No namespace");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isExecuteNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = srcFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The output file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * Create a typelib command     * @exception BuildException if something goes wrong with the build     */    public void execute() throws BuildException {        validate();        log("Importing typelib " + srcFile            + " to assembly " + destFile            + " in namespace " + namespace, Project.MSG_VERBOSE);        //rebuild unless the dest file is newer than the source file        if (!isExecuteNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ImportTypelib", "tlbimp");        command.setFailOnError(true);        command.addArgument(srcFile.toString());        //fill in args        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/namespace:", namespace);        if (useSysArray) {            command.addArgument("/sysarray");        }        if (unsafe) {            command.addArgument("/unsafe");        }        command.addArgument(extraOptions);        command.runCommand();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  The reference CD to listen to while editing this file is *  Underworld Everything, Everything *  variable naming policy from Fowler's refactoring book. */// place below the optional ant tasks packagepackage org.apache.ant.dotnet;// importsimport java.io.File;import java.io.IOException;import java.io.FileOutputStream;import java.io.PrintWriter;import java.io.BufferedOutputStream;import java.util.ArrayList;import java.util.Hashtable;import java.util.List;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.taskdefs.Execute;import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;import org.apache.tools.ant.taskdefs.LogStreamHandler;import org.apache.tools.ant.types.Commandline;/** *  This is a helper class to spawn net commands out. In its initial form it *  contains no .net specifics, just contains all the command line/exe *  construction stuff. However, it may be handy in future to have a means of *  setting the path to point to the dotnet bin directory; in which case the *  shared code should go in here. * */public class NetCommand {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     *  owner project     */    protected Task owner;    /**     *  executable     */    protected Execute executable;    /**     *  what is the command line     */    protected Commandline commandLine;    /**     *  title of the command     */    protected String title;    /**     *  actual program to invoke     */    protected String program;    /**     *  trace flag     */    protected boolean traceCommandLine = false;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     * the directory to execute the command in. When null, the current     * directory is used.     */    private File directory;    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    /**     * name of a temp file; may be null     */    private File temporaryCommandFile;    /**     * internal threshold for auto-switch     */    private int automaticResponseFileThreshold = 64;    /**     * List of command line arguments that must appear on the command     * line and must not go into a response file.     * @since .NET Antlib 1.1     */    private List argsOnCommandLine = new ArrayList();    /**     *  constructor     *     *@param  title        (for logging/errors)     *@param  owner        owner task     *@param  program      app we are to run     */    public NetCommand(Task owner, String title, String program) {        this.owner = owner;        this.title = title;        this.program = program;        commandLine = new Commandline();        commandLine.setExecutable(program);    }    /**     *  turn tracing on or off     *     *@param  b  trace flag     */    public void setTraceCommandLine(boolean b) {        traceCommandLine = b;    }    /**     *  set fail on error flag     *     *@param  b  fail flag -set to true to cause an exception to be raised if     *      the return value != 0     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailFailOnError() {        return failOnError;    }    /**     * set the directory to run from, if the default is inadequate     * @param directory     */    public void setDirectory(File directory) {        this.directory = directory;    }    /**     *  verbose text log     *     *@param  msg  string to add to log if verbose is defined for the build     */    protected void logVerbose(String msg) {        owner.getProject().log(msg, Project.MSG_VERBOSE);    }    /**     *  error text log     *     *@param  msg  message to display as an error     */    protected void logError(String msg) {        owner.getProject().log(msg, Project.MSG_ERR);    }    /**     *  add an argument to a command line; do nothing if the arg is null or     *  empty string     *     * <p>The given argument may be added to a response file.</p>     *     * @param  argument  The feature to be added to the Argument attribute     */    public void addArgument(String argument) {        addArgument(argument, true);    }    /**     * add an argument to a command line; do nothing if the arg is     * null or empty string     *     * @param argument  The feature to be added to the Argument attribute     * @param mayBeInResponseFile whether the argument is allowed     * inside a response file.     *     * @since .NET Antlib 1.1     */    public void addArgument(String argument, boolean mayBeInResponseFile) {        if (argument != null && argument.length() != 0) {            commandLine.createArgument().setValue(argument);            if (!mayBeInResponseFile) {                argsOnCommandLine.add(argument);            }        }    }    /**     * Add multiple arguments to a command line; do nothing for args     * that are is null or empty strings     *     * <p>The given arguments may be added to a response file.</p>     *     * @param  arguments  The features to be added to the Argument attribute     */    public void addArguments(String[] arguments) {        if (arguments != null && arguments.length != 0) {            for (int i = 0; i < arguments.length; i++) {                addArgument(arguments[i], true);            }        }    }    /**     *  concatenate two strings together and add them as a single argument,     *  but only if argument2 is non-null and non-zero length     *     * <p>The resulting argument may be added to a response file.</p>     *     *@param  argument1  The first argument     *@param  argument2  The second argument     */    public void addArgument(String argument1, String argument2) {        if (argument2 != null && argument2.length() != 0) {            addArgument(argument1 + argument2, true);        }    }    /**     * getter     * @return response file state     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * set this to true to always use the response file     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     * getter for threshold     * @return 0 for disabled, or a threshold for enabling response files     */    public int getAutomaticResponseFileThreshold() {        return automaticResponseFileThreshold;    }    /**     * set threshold for automatically using response files -use 0 for off     * @param automaticResponseFileThreshold     */    public void setAutomaticResponseFileThreshold(int automaticResponseFileThreshold) {        this.automaticResponseFileThreshold = automaticResponseFileThreshold;    }    /**     *  set up the command sequence..     */    protected void prepareExecutor() {        // default directory to the project's base directory        if (owner == null) {            throw new RuntimeException("no owner");        }        if (owner.getProject() == null) {            throw new RuntimeException("Owner has no project");        }        File dir = owner.getProject().getBaseDir();        if (directory != null) {            dir = directory;        }        ExecuteStreamHandler handler = new LogStreamHandler(owner,                Project.MSG_INFO, Project.MSG_WARN);        executable = new Execute(handler, null);        executable.setAntRun(owner.getProject());        executable.setWorkingDirectory(dir);    }    /**     *  Run the command using the given Execute instance.     *     *@exception  BuildException  if something goes wrong and the     *      failOnError flag is true     */    public void runCommand()             throws BuildException {        prepareExecutor();        int err = -1;        // assume the worst        try {            if (traceCommandLine) {                owner.log("In directory " + executable.getWorkingDirectory());                owner.log(commandLine.describeCommand());            } else {                //in verbose mode we always log stuff                logVerbose("In directory " + executable.getWorkingDirectory());                logVerbose(commandLine.describeCommand());            }            setExecutableCommandLine();            err = executable.execute();            if (Execute.isFailure(err)) {                if (failOnError) {                    throw new BuildException(title + " returned: " + err, owner.getLocation());                } else {                    owner.log(title + "  Result: " + err, Project.MSG_ERR);                }            }        } catch (IOException e) {            throw new BuildException(title + " failed: " + e, e, owner.getLocation());        } finally {            if (temporaryCommandFile != null) {                temporaryCommandFile.delete();            }        }    }    /**     * set the executable command line     */    private void setExecutableCommandLine() {        String[] commands = commandLine.getCommandline();        //always trigger file mode if commands are big enough        if (automaticResponseFileThreshold > 0            && commands.length > automaticResponseFileThreshold) {            useResponseFile = true;        }        if (!useResponseFile || commands.length <= 1) {            //the simple action is to send the command line in as is            executable.setCommandline(commands);        } else {            //but for big operations, we save all the params to a temp file            //and set @tmpfile as the command -then we remember to delete the tempfile            //afterwards            FileOutputStream fos = null;            temporaryCommandFile = FILE_UTILS.createTempFile("cmd", ".txt", null);            owner.log("Using response file " + temporaryCommandFile, Project.MSG_VERBOSE);            try {                fos = new FileOutputStream(temporaryCommandFile);                PrintWriter out = new PrintWriter(new BufferedOutputStream(fos));                //start at 1 because element 0 is the executable name                for (int i = 1; i < commands.length; ++i) {                    if (argsOnCommandLine.contains(commands[i])) {                        continue;                    }                    if (commands[i].indexOf(" ") > -1) {                        String q = commands[i].indexOf("\"") > -1 ? "'" : "\"";                        out.print(q);                        out.print(commands[i]);                        out.println(q);                    } else {                        out.println(commands[i]);                    }                }                out.flush();                out.close();            } catch (IOException ex) {                throw new BuildException("saving command stream to " + temporaryCommandFile, ex);            }            String newCommandLine[] = new String[2 + argsOnCommandLine.size()];            newCommandLine[0] = commands[0];            if (argsOnCommandLine.size() > 0) {                System.arraycopy(argsOnCommandLine.toArray(), 0,                                 newCommandLine, 1, argsOnCommandLine.size());            }            newCommandLine[newCommandLine.length - 1] =                "@" + temporaryCommandFile.getAbsolutePath();            logVerbose(Commandline.describeCommand(newCommandLine));            executable.setCommandline(newCommandLine);        }    }    /**     * scan through one fileset for files to include     * @param scanner     * @param filesToBuild     * @param outputTimestamp timestamp to compare against     * @return #of files out of date     * @todo: should FAT granularity be included here?     */    public int scanOneFileset(DirectoryScanner scanner, Hashtable filesToBuild,                                        long outputTimestamp) {        int filesOutOfDate = 0;        String[] dependencies = scanner.getIncludedFiles();        File base = scanner.getBasedir();        //add to the list        for (int i = 0; i < dependencies.length; i++) {            File targetFile = new File(base, dependencies[i]);            if (filesToBuild.get(targetFile) == null) {                filesToBuild.put(targetFile, targetFile);                if (targetFile.lastModified() > outputTimestamp) {                    filesOutOfDate++;                    owner.log(targetFile.toString() + " is out of date",                              Project.MSG_VERBOSE);                } else {                    owner.log(targetFile.toString(),                              Project.MSG_VERBOSE);                }            }        }        return filesOutOfDate;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.ant.dotnet.util.CollectionUtils;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Environment;import org.apache.tools.ant.types.RedirectorElement;import java.io.File;import java.util.ArrayList;import java.util.Iterator;/** * Task to run the NUnit Console test runner. * * @see http://www.nunit.org/ */public class NUnitTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * Test assemblies.     */    private ArrayList testAssemblies = new ArrayList();    /**     * The /config argument.     */    private File configFile;    /**     * The /output argument.     */    private File out;    /**     * The /err argument.     */    private File err;    /**     * The /xml argument.     */    private File xmlOut;    /**     * The /transform argument.     */    private File transform;    /**     * The /thread argument.     */    private boolean thread = false;    /**     * The /fixture argument.     */    private String fixture;    /**     * Categories to include.     */    private ArrayList includes = new ArrayList();    /**     * Categories to exclude.     */    private ArrayList excludes = new ArrayList();    /**     * The /noshadow argument.     */    private boolean noshadow = false;    /**     * The /labels argument.     */    private boolean labels = false;    /**     * Redirects everything that NUnit wants to send to the console.     */    private RedirectorElement redirectorElement;    /**     * Whether a failure should stop the build.     */    private boolean failOnError = false;    /**     * Name of property to set if a test fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Support for nested environment variables.     */    private Environment env = new Environment();    public NUnitTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the config file.     */    public void setConfig(File c) {        configFile = c;    }    /**     * The /output argument.     */    public void setOut(File out) {        this.out = out;    }    /**     * The /err argument.     */    public void setError(File err) {        this.err = err;    }    /**     * The /xml argument.     */    public void setXmlOut(File out) {        this.xmlOut = out;    }    /**     * The /transform argument.     */    public void setTransform(File transform) {        this.transform = transform;    }    /**     * The /thread argument.     */    public void setThread(boolean thread) {        this.thread = thread;    }    /**     * The /fixture argument.     */    public void setFixture(String fixture) {        this.fixture = fixture;    }    /**     * The /noshadow argument.     */    public void setNoshadow(boolean noshadow) {        this.noshadow = noshadow;    }    /**     * The /labels argument.     */    public void setLabels(boolean labels) {        this.labels = labels;    }    /**     * Whether a failure should stop the build.     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Name of property to set if a test fails.     *     * @since 1.0 Beta 2     */    public void setErrorProperty(String name) {        errorProperty = name;    }    /**     * Adds a test assembly by name.     */    public void addTestAssembly(NamedElement a) {        testAssemblies.add(a);    }    /**     * Adds a category to the include list.     */    public void addInclude(NamedElement a) {        includes.add(a);    }    /**     * Adds a category to the exclude list.     */    public void addExclude(NamedElement a) {        excludes.add(a);    }    /**     * Add an environment variable to the launched process.     *     * @param var new environment variable     */    public void addEnv(Environment.Variable var) {        env.addVariable(var);    }    /**     * Add a <code>RedirectorElement</code> to this task.     *     * <p>This does not use the <code>out</code> and     * <code>error</code> attributes, it only captures NUnits output     * that has not been redirected by those attributes.</p>     */    public void addConfiguredRedirector(RedirectorElement redirectorElement) {        if (this.redirectorElement != null) {            throw new BuildException("cannot have > 1 nested <redirector>s");        } else {            this.redirectorElement = redirectorElement;        }    }    public void execute() {        if (testAssemblies.size() == 0) {            throw new BuildException("You must specify at least one test "                                     + "assembly.");        }                DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      "nunit-console.exe",                                                     env);        Iterator iter = testAssemblies.iterator();        while (iter.hasNext()) {            NamedElement a = (NamedElement) iter.next();            exec.createArg().setValue(a.getName());        }        if (configFile != null) {            exec.createArg().setValue("/config="                                       + configFile.getAbsolutePath());        }        exec.createArg().setValue("/nologo");        if (out != null) {            exec.createArg().setValue("/output=" + out.getAbsolutePath());        }        if (err != null) {            exec.createArg().setValue("/err=" + err.getAbsolutePath());        }        if (xmlOut != null) {            exec.createArg().setValue("/xml=" + xmlOut.getAbsolutePath());        }        if (transform != null) {            exec.createArg().setValue("/transform="                                       + transform.getAbsolutePath());        }        if (thread) {            exec.createArg().setValue("/thread");        }        if (noshadow) {            exec.createArg().setValue("/noshadow");        }        if (labels) {            exec.createArg().setValue("/labels");        }        if (fixture != null) {            exec.createArg().setValue("/fixture=" + fixture);        }                if (includes.size() > 0) {            StringBuffer sb = new StringBuffer("/include=");            sb.append(CollectionUtils.flattenToString(includes));            exec.createArg().setValue(sb.toString());        }        if (excludes.size() > 0) {            StringBuffer sb = new StringBuffer("/exclude=");            sb.append(CollectionUtils.flattenToString(excludes));            exec.createArg().setValue(sb.toString());        }        if (redirectorElement != null) {            exec.addConfiguredRedirector(redirectorElement);        }        exec.setFailonerror(failOnError);        exec.internalSetErrorProperty(errorProperty);        exec.execute();    }    public static class NamedElement {        private String name;        public String getName() {return name;}        public void setName(String s) {name = s;}        public String toString() {return getName();}    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.util.DOMElementWriter;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.XMLFragment;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Base class for NAntTask and MSBuildTask. */public abstract class AbstractBuildTask extends Task {    /**     * The buildfile to invoke the build tool for.     */    private File buildFile;    /**     * The targets to execute.     */    private List targets = new ArrayList();    /**     * Properties to set.     */    private List properties = new ArrayList(1);    /**     * Nested build file fragment.     */    private XMLFragment buildSnippet;    /**     * The vm attribute - if given.     */    private String vm;    /**     * Whether a failure should stop the build.     *     * @since 1.0 Beta 2     */    private boolean failOnError = true;    /**     * Name of property to set if a build fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Empty constructor.     */    protected AbstractBuildTask() {    }    /**     * Sets the name of the build file.     */    public final void setBuildfile(File f) {        buildFile = f;    }    /**     * Adds a build file fragment.     */    public void addBuild(XMLFragment f) {        if (buildSnippet == null) {            buildSnippet = f;        } else {            throw new BuildException("You must not specify more than one "                                     + "build element");        }    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * A target.     */    public static class Target {        private String name;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public String toString() {            return getName();        }    }    /**     * A target to execute.     */    public final void addTarget(Target t) {        targets.add(t);    }    /**     * A property.     */    // XXX, could have reused Property or Environment.Variable     //      - not decided so far    public static class Property {        private String name;        private String value;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public void setValue(String value) {            this.value = value;        }        public String getValue() {            return value;        }        public String toString() {            return getName() + "=" + getValue();        }    }    /**     * A target to execute.     */    public final void addProperty(Property t) {        properties.add(t);    }    /**     * Whether a failure should stop the build.     *     * @since 1.0 Beta 2     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Name of property to set if a build fails.     *     * @since 1.0 Beta 2     */    public void setErrorProperty(String name) {        errorProperty = name;    }    /**     * Must return the executable.     *     * @return must not return null     */    protected abstract String getExecutable();    /**     * Must return buildfile argument(s).     *     * @param buildFile the absolute File for the buildfile or null if     * the user didn't specify a buildfile.     *     * @return must not return null     */    protected abstract String[] getBuildfileArguments(File buildFile);    /**     * Must return target argument(s).     *     * @return must not return null     */    protected abstract String[] getTargetArguments(List targets);    /**     * Must return property argument(s).     *     * @return must not return null     */    protected abstract String[] getPropertyArguments(List properties);    /**     * Turn the DoucmentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>Must throw a BuildException if the snippet can not be turned     * into a build file.</p>     */    protected abstract Element makeTree(DocumentFragment f);    /**     * Perform the build.     */    public void execute() {        if (buildFile != null && buildSnippet != null) {            throw new BuildException("You must not specify the build file"                                     + " attribute and a nested build at the"                                     + " same time");        }        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      getExecutable(), null);        String[] args = getPropertyArguments(properties);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        args = getTargetArguments(targets);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        File generatedFile = null;        if (buildSnippet != null) {            try {                generatedFile = getBuildFile();            } catch (IOException e) {                throw new BuildException(e);            }            args = getBuildfileArguments(generatedFile);        } else {            args = getBuildfileArguments(buildFile);        }                for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        exec.setFailonerror(failOnError);        exec.internalSetErrorProperty(errorProperty);        try {            exec.execute();        } finally {            if (generatedFile != null) {                generatedFile.delete();            }        }    }    private File getBuildFile() throws IOException {        File f = null;        if (buildSnippet != null) {            Element e = makeTree(buildSnippet.getFragment());            f = FileUtils.getFileUtils().createTempFile("build", ".xml", null);            f.deleteOnExit();            FileOutputStream out = null;            try {                out = new FileOutputStream(f);                DOMElementWriter w =                    new DOMElementWriter(true,                                         DOMElementWriter.XmlNamespacePolicy                                         .ONLY_QUALIFY_ELEMENTS);                w.write(e, out);            } finally {                if (out != null) {                    out.close();                }            }        }        return f;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.List;import org.apache.ant.dotnet.util.CollectionUtils;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a MSBuild build process. */public class MSBuildTask extends AbstractBuildTask {    private static final String TARGET = "generated-by-ant";    private static final String ROOT = "Project";    private static final String MSBUILD_NS =	"http://schemas.microsoft.com/developer/msbuild/2003";    public MSBuildTask() {        super();    }    protected String getExecutable() {        return "MSBuild.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        if (targets.size() > 0) {            StringBuffer sb = new StringBuffer("/target:");            sb.append(CollectionUtils.flattenToString(targets, ";"));            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    protected String[] getPropertyArguments(List properties) {        if (properties.size() > 0) {            StringBuffer sb = new StringBuffer("/property:");            sb.append(CollectionUtils.flattenToString(properties, ";"));            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <Project> child, return that.     * Otherwise if we have only <Task> children, wrap them into a     * <Target> which in turn gets wrapped into a <Project>.     * Otherwise, fail.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals(ROOT)) {            return (Element) nl.item(0);        } else {            Element p = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     ROOT);            p.setAttribute("DefaultTargets", TARGET);            Element t = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     "Target");            t.setAttribute("Name", TARGET);            p.appendChild(t);            t.appendChild(f);            return p;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a NAnt build process. */public class NAntTask extends AbstractBuildTask {    public NAntTask() {        super();    }    protected String getExecutable() {        return "NAnt.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                "-buildfile:" + buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        ArrayList al = new ArrayList(targets.size());        Iterator iter = targets.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Target t = (AbstractBuildTask.Target) iter.next();            al.add(t.getName());        }        return (String[]) al.toArray(new String[al.size()]);    }    protected String[] getPropertyArguments(List properties) {        ArrayList al = new ArrayList(properties.size());        Iterator iter = properties.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                 (AbstractBuildTask.Property) iter.next();            al.add("-D:" + p.getName() + "=" + p.getValue());        }        return (String[]) al.toArray(new String[al.size()]);    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <project> child, return that.     * Otherwise assume that this is a valid build file snippet that     * just needs an empty project wrapped around it.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals("project")) {            return (Element) nl.item(0);        } else {            Element e = f.getOwnerDocument().createElement("project");            e.appendChild(f);            return e;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */// ====================================================================// place in the optional ant tasks package// but in its own dotnet group// ====================================================================package org.apache.ant.dotnet.compile;// ====================================================================// imports// ====================================================================import org.apache.ant.dotnet.NetCommand;import java.io.File;// ====================================================================/** *  Compiles C# source into executables or modules. * * csc.exe on Windows or gmcs on other platforms must be on the execute * path, unless another executable or the full path to that executable * is specified in the <tt>executable</tt> parameter * <p> * All parameters are optional: &lt;csc/&gt; should suffice to produce a debug * build of all *.cs files. However, naming an <tt>destFile</tt>stops the * csc compiler from choosing an output name from random, and * allows the dependency checker to determine if the file is out of date. * <p> *  The task is a directory based task, so attributes like <b>includes="*.cs" *  </b> and <b>excludes="broken.cs"</b> can be used to control the files pulled *  in. By default, all *.cs files from the project folder down are included in *  the command. When this happens the output file -if not specified- is taken *  as the first file in the list, which may be somewhat hard to control. *  Specifying the output file with <tt>destFile</tt> seems prudent. <p> * * <p> * For more complex source trees, nested <tt>src</tt> elemements can be * supplied. When such an element is present, the implicit fileset is ignored. * This makes sense, when you think about it :) * * <p>For historical reasons the pattern * <code>**</code><code>/*.cs</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * <p> * References to external files can be made through the references attribute, * or (since Ant1.6), via nested &lt;reference&gt; filesets. With the latter, * the timestamps of the references are also used in the dependency * checking algorithm. * <p> * * Example * * <pre>&lt;csc *       optimize=&quot;true&quot; *       debug=&quot;false&quot; *       docFile=&quot;documentation.xml&quot; *       warnLevel=&quot;4&quot; *       unsafe=&quot;false&quot; *       targetType=&quot;exe&quot; *       incremental=&quot;false&quot; *       mainClass = &quot;MainApp&quot; *       destFile=&quot;NetApp.exe&quot; *       &gt; *           &lt;src dir="src" includes="*.cs" /&gt; *       &lt;reference file="${testCSC.dll}" /&gt; *       &lt;define name="RELEASE" /&gt; *       &lt;define name="DEBUG" if="debug.property"/&gt; *       &lt;define name="def3" unless="def3.property"/&gt; *    &lt;/csc&gt; * </pre> * * * @ant.task    name="csc" category="dotnet" * @since Ant 1.3 */public class CSharp extends DotnetCompile {    private static final String MONO_CS_COMPILER = "gmcs";    /**     *  defines list: RELEASE;WIN32;NO_SANITY_CHECKS;;SOMETHING_ELSE'     */    String definitions;    /**     *  output XML documentation flag     */    private File docFile;    /**     *  file alignment; 0 means let the compiler decide     */    private int fileAlign = 0;    /**     *  use full paths to things     */    private boolean fullpaths = false;    /**     *  incremental build flag     */    private boolean incremental;    /**     *  enable unsafe code flag. Clearly set to false by default     */    protected boolean unsafe;    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     */    private boolean noconfig = false;    /**     *  constructor inits everything and set up the search pattern     */    public CSharp() {        clear();    }    /**     * full cleanup     */    public void clear() {        super.clear();        docFile = null;        fileAlign = 0;        fullpaths = true;        incremental = false;        unsafe = false;        noconfig = false;        definitions = null;        setExecutable(isWindows ? "csc" : MONO_CS_COMPILER);    }    /**     *  file for generated XML documentation     *     *@param  f  output file     */    public void setDocFile(File f) {        docFile = f;    }    /**     *  get the argument or null for no argument needed     *     *@return    The DocFile Parameter to CSC     */    protected String getDocFileParameter() {        if (docFile != null) {            return "/doc:" + docFile.toString();        } else {            return null;        }    }    /**     * Set the file alignment.     * Valid values are 0,512, 1024, 2048, 4096, 8192,     * and 16384, 0 means 'leave to the compiler'     */    public void setFileAlign(int fileAlign) {        this.fileAlign = fileAlign;    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getFileAlignParameter() {        if (fileAlign != 0 && !MONO_CS_COMPILER.equals(getExecutable())) {            return "/filealign:" + fileAlign;        } else {            return null;        }    }    /**     * If true, print the full path of files on errors.     *     *@param  enabled  The new fullPaths value     */    public void setFullPaths(boolean enabled) {        fullpaths = enabled;    }    /**     *  Gets the fullPathsParameter attribute of the CSharp object     *     *@return    The fullPathsParameter value or null if unset     */    protected String getFullPathsParameter() {        return fullpaths ? "/fullpaths" : null;    }    /**     *  set the incremental compilation flag on or off.     *     *@param  incremental  on/off flag     */    public void setIncremental(boolean incremental) {        this.incremental = incremental;    }    /**     *  query the incrementalflag     *     *@return    true if incremental compilation is turned on     */    public boolean getIncremental() {        return incremental;    }    /**     *  get the incremental build argument     *     *@return    The Incremental Parameter to CSC     */    protected String getIncrementalParameter() {        return "/incremental" + (incremental ? "+" : "-");    }    /**     *  The output file. This is identical to the destFile attribute.     *     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        setDestFile(params);    }    /**     * If true, enables the unsafe keyword.     *     *@param  unsafe  The new Unsafe value     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     *  query the Unsafe attribute     *     *@return    The Unsafe value     */    public boolean getUnsafe() {        return this.unsafe;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Unsafe Parameter to CSC     */    protected String getUnsafeParameter() {        return unsafe ? "/unsafe" : null;    }    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     *     *@param  enabled  The new noConfig value     */    public void setNoConfig(boolean enabled) {        noconfig = enabled;    }    /**     *  Gets the noConfigParameter attribute of the CSharp object     *     *@return    The noConfigParameter value     */    protected String getNoConfigParameter() {        return noconfig ? "/noconfig" : null;    }    /**     *  Semicolon separated list of defined constants.     *     *@param  params  The new definitions value     */    public void setDefinitions(String params) {        definitions = params;    }    /**     * override the superclasses version of this method (which we call)     * with a check for a definitions attribute, the contents of which     * are appended to the list.     *@return    The Definitions Parameter to CSC     */    protected String getDefinitionsParameter() {        String predecessors = super.getDefinitionsParameter();        if (notEmpty(definitions)) {            if (predecessors == null) {                predecessors = "/define:";            }            return  predecessors + definitions;        } else {            return predecessors;        }    }    /**     * add Commands unique to C#.     * @param command ongoing command     */    public void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getIncludeDefaultReferencesParameter());        command.addArgument(getWarnLevelParameter());        command.addArgument(getDocFileParameter());        command.addArgument(getFullPathsParameter());        command.addArgument(getFileAlignParameter());        if (getIncremental()) {            command.addArgument(getIncrementalParameter());        }        command.addArgument(getNoConfigParameter(), false);        command.addArgument(getUnsafeParameter());    }    // end execute    /**     * Returns the delimiter which C# uses to separate references, i.e., a semi colon.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * This method indicates the filename extension for C# files.     * @return the file extension for C#, i.e., "cs" (without the dot).     */    public String getFileExtension() {        return "cs";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.taskdefs.MatchingTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.Project;import org.apache.tools.ant.DirectoryScanner;import java.io.File;import java.util.Vector;import java.util.Hashtable;import java.util.Enumeration;/** * refactoring of some stuff so that different things (like ILASM) * can use shared code. */public class DotnetBaseMatchingTask extends MatchingTask {    /**     *  output file. If not supplied this is derived from the source file     */    protected File outputFile;    /**     * filesets of file to compile     */    protected Vector filesets = new Vector();    /**     *  source directory upon which the search pattern is applied     */    protected File srcDir;    /**     * Are we running on Windows?     *     * @since Ant 1.6.3     */    protected static final boolean isWindows = Os.isFamily("windows");    /**    * Overridden because we need to be able to set the srcDir.    */    public File getSrcDir() {        return this.srcDir;    }    /**     *  Set the source directory of the files to be compiled.     *     *@param  srcDirName  The new SrcDir value     */    public void setSrcDir(File srcDirName) {        this.srcDir = srcDirName;    }    /**     *  Set the name of exe/library to create.     *     *@param  file  The new outputFile value     */    public void setDestFile(File file) {        outputFile = file;    }    /**     * add a new source directory to the compile     * @param src     */    public void addSrc(FileSet src) {        filesets.add(src);    }    /**     * get the destination file     * @return the dest file or null for not assigned     */    public File getDestFile() {        return outputFile;    }    /**     * create the list of files     * @param filesToBuild vector to add files to     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int buildFileList(NetCommand command, Hashtable filesToBuild, long outputTimestamp) {        int filesOutOfDate = 0;        boolean scanImplicitFileset            = getSrcDir() != null || filesets.size() == 0;        if (scanImplicitFileset) {            //scan for an implicit fileset if there was a srcdir set            //or there was no srcDir set but there was no contained classes            if (getSrcDir() == null) {                //if there is no src dir here, set it                setSrcDir(getProject().resolveFile("."));            }            log("working from source directory " + getSrcDir(),                    Project.MSG_VERBOSE);            //get dependencies list.            DirectoryScanner scanner = getDirectoryScanner(getSrcDir());            filesOutOfDate = command.scanOneFileset(scanner,                    filesToBuild, outputTimestamp);        }        //get any included source directories        for (int i = 0; i < filesets.size(); i++) {            FileSet fs = (FileSet) filesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        return filesOutOfDate;    }    /**     * add the list of files to a command     * @param filesToBuild vector of files     * @param command the command to append to     */    protected void addFilesToCommand(Hashtable filesToBuild, NetCommand command) {        int count = filesToBuild.size();        log("compiling " + count + " file" + ((count == 1) ? "" : "s"),                Project.MSG_VERBOSE);        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            command.addArgument(file.toString());        }    }    /**     * determine the timestamp of the output file     * @return a timestamp or 0 for no output file known/exists     */    protected long getOutputFileTimestamp() {        long outputTimestamp;        if (getDestFile() != null && getDestFile().exists()) {            outputTimestamp = getDestFile().lastModified();        } else {            outputTimestamp = 0;        }        return outputTimestamp;    }    /**     * finish off the command by adding all dependent files, execute     * @param command     */    protected void addFilesAndExecute(NetCommand command, boolean ignoreTimestamps) {        long outputTimestamp = getOutputFileTimestamp();        Hashtable filesToBuild = new Hashtable();        int filesOutOfDate = buildFileList(command, filesToBuild, outputTimestamp);        //now run the command of exe + settings + files        if (filesOutOfDate > 0) {            //add the files to the command            addFilesToCommand(filesToBuild, command);            command.runCommand();        } else {            log("output file is up to date", Project.MSG_VERBOSE);        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap:Cream+Live+2001+CD+2 */// place in the optional ant tasks package// but in its own dotnet grouppackage org.apache.ant.dotnet.compile;// importsimport java.io.File;import java.util.Vector;import java.util.Enumeration;import java.util.Hashtable;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.Path;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.types.EnumeratedAttribute;/** *  Abstract superclass for dotnet compiler tasks. * *  History *  <table> *    <tr> *      <td> *        0.1 *      </td> *      <td> *        First creation *      </td> *      <td> *        Most of the code here was copied verbatim from v0.3 of *        Steve Loughran's CSharp optional task. Abstracted functionality *        to allow subclassing of other dotnet compiler types. *      </td> *    </tr> * *  </table> * * * @version     0.1 */public abstract class DotnetCompile         extends DotnetBaseMatchingTask {    /**     *  list of reference classes. (pretty much a classpath equivalent)     */    private String references;    /**     *  flag to enable automatic reference inclusion     */    private boolean includeDefaultReferences = true;    /**     *  icon for incorporation into apps     */    private File win32icon;    /**     *  icon for incorporation into apps     */    private File win32res;    /**     *  flag to control action on execution trouble     */    private boolean failOnError;    /**     *  using the path approach didn't work as it could not handle the implicit     *  execution path. Perhaps that could be extracted from the runtime and     *  then the path approach would be viable     */    private Path referenceFiles;    /**     *  optimise flag     */    private boolean optimize;    /**     * a list of definitions to support;     */    protected Vector definitionList = new Vector();    /**     * our resources     */    protected Vector resources = new Vector();    /**     *  executable     */    protected String executable;    protected static final String REFERENCE_OPTION = "/reference:";    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  warning level: 0-4, with 4 being most verbose     */    private int warnLevel;    /**     *  main class (or null for automatic choice)     */    protected String mainClass;    /**     *  any extra command options?     */    protected String extraOptions;    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  utf out flag     */    protected boolean utf8output = false;    /**     *  list of extra modules to refer to     */    protected String additionalModules;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    private static final int AUTOMATIC_RESPONSE_FILE_THRESHOLD = 64;    /**     *  constructor inits everything and set up the search pattern     */    public DotnetCompile() {        clear();        setIncludes(getFilePattern());    }    /**     *  reset all contents.     */    public void clear() {        targetType = null;        win32icon = null;        srcDir = null;        mainClass = null;        warnLevel = 3;        optimize = false;        debug = true;        references = null;        failOnError = true;        additionalModules = null;        includeDefaultReferences = true;        extraOptions = null;    }    /**     * Semicolon separated list of DLLs to refer to.     *     *@param  s  The new References value     */    public void setReferences(String s) {        references = s;    }    /**     *  get the reference string or null for no argument needed     *     *@return    The References Parameter to CSC     */    protected String getReferencesParameter() {        //bail on no references        if (notEmpty(references)) {            if (isWindows) {                return '\"' + REFERENCE_OPTION + references + '\"';            } else {                return REFERENCE_OPTION + references;            }        } else {            return null;        }    }    /**     * Path of references to include.     * Wildcards should work.     *     *@param  path  another path to append     */    public void setReferenceFiles(Path path) {        //demand create pathlist        if (referenceFiles == null) {            referenceFiles = new Path(this.getProject());        }        referenceFiles.append(path);    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     *  turn the path list into a list of files and a /references argument     *     *@return    null or a string of references.     */    protected String getReferenceFilesParameter() {        //bail on no references        if (references == null) {            return null;        }        //iterate through the ref list & generate an entry for each        //or just rely on the fact that the toString operator does this, but        //noting that the separator is ';' on windows, ':' on unix        //bail on no references listed        if (references.length() == 0) {            return null;        }        StringBuffer s = new StringBuffer(REFERENCE_OPTION);        if (isWindows) {            s.append('\"');        }        s.append(references);        if (isWindows) {            s.append('\"');        }        return s.toString();    }    /**     * If true, automatically includes the common assemblies     * in dotnet, and tells the compiler to link in mscore.dll.     *     *  set the automatic reference inclusion flag on or off this flag controls     *  the /nostdlib option in CSC     *     *@param  f  on/off flag     */    public void setIncludeDefaultReferences(boolean f) {        includeDefaultReferences = f;    }    /**     *  query automatic reference inclusion flag     *     *@return    true if flag is turned on     */    public boolean getIncludeDefaultReferences() {        return includeDefaultReferences;    }    /**     *  get the include default references flag or null for no argument needed     *     *@return    The Parameter to CSC     */    protected String getIncludeDefaultReferencesParameter() {        return "/nostdlib" + (includeDefaultReferences ? "-" : "+");    }    /**     * If true, enables optimization flag.     *     *@param  f  on/off flag     */    public void setOptimize(boolean f) {        optimize = f;    }    /**     *  query the optimise flag     *     *@return    true if optimise is turned on     */    public boolean getOptimize() {        return optimize;    }    /**     *  get the optimise flag or null for no argument needed     *     *@return    The Optimize Parameter to CSC     */    protected String getOptimizeParameter() {        return "/optimize" + (optimize ? "+" : "-");    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the debug switch argument     *     *@return    The Debug Parameter to CSC     */    protected String getDebugParameter() {        return "/debug" + (debug ? "+" : "-");    }    /**     * Level of warning currently between 1 and 4     * with 4 being the strictest.     *     *@param  warnLevel  warn level -see .net docs for valid range (probably     *      0-4)     */    public void setWarnLevel(int warnLevel) {        this.warnLevel = warnLevel;    }    /**     *  query warn level     *     *@return    current value     */    public int getWarnLevel() {        return warnLevel;    }    /**     *  get the warn level switch     *     *@return    The WarnLevel Parameter to CSC     */    protected String getWarnLevelParameter() {        return "/warn:" + warnLevel;    }    /**     *  Sets the name of main class for executables.     *     *@param  mainClass  The new MainClass value     */    public void setMainClass(String mainClass) {        this.mainClass = mainClass;    }    /**     *  Gets the MainClass attribute     *     *@return    The MainClass value     */    public String getMainClass() {        return this.mainClass;    }    /**     *  get the /main argument or null for no argument needed     *     *@return    The MainClass Parameter to CSC     */    protected String getMainClassParameter() {        if (mainClass != null && mainClass.length() != 0) {            return "/main:" + mainClass;        } else {            return null;        }    }    /**     * Any extra options which are not explicitly supported     * by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     *  get any extra options or null for no argument needed, split     *  them if they represent multiple options.     *     * @return    The ExtraOptions Parameter to CSC     */    protected String[] getExtraOptionsParameters() {        String extra = getExtraOptionsParameter();        return extra == null ? null : Commandline.translateCommandline(extra);    }    /**     * Set the destination directory of files to be compiled.     *     *@param  dirName  The new DestDir value     */    public void setDestDir(File dirName) {        log("DestDir currently unused", Project.MSG_WARN);    }    /**     * set the target type to one of exe|library|module|winexe     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Set the type of target.     *     *@param  ttype          The new TargetType value     *@exception  BuildException  if target is not one of     *      exe|library|module|winexe     */    public void setTargetType(String ttype)             throws BuildException {        ttype = ttype.toLowerCase();        if (ttype.equals("exe") || ttype.equals("library")            || ttype.equals("module") || ttype.equals("winexe")) {            targetType = ttype;        } else {            throw new BuildException("targetType " + ttype                    + " is not one of 'exe', 'module', 'winexe' or 'library'");        }    }    /**     *  Gets the TargetType attribute     *     *@return    The TargetType value     */    public String getTargetType() {        return targetType;    }    /**     *  get the argument or null for no argument needed     *     *@return    The TargetType Parameter to CSC     */    protected String getTargetTypeParameter() {        if (notEmpty(targetType)) {            return "/target:" + targetType;        } else {            return null;        }    }    /**     *  Set the filename of icon to include.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Icon(File fileName) {        win32icon = fileName;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Icon Parameter to CSC     */    protected String getWin32IconParameter() {        if (win32icon != null) {            return "/win32icon:" + win32icon.toString();        } else {            return null;        }    }    /**     * Sets the filename of a win32 resource (.RES) file to include.     * This is not a .NET resource, but what Windows is used to.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Res(File fileName) {        win32res = fileName;    }    /**     * Gets the file of the win32 .res file to include.     * @return path to the file.     */    public File getWin32Res() {        return win32res;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (win32res != null) {            return "/win32res:" + win32res.toString();        } else {            return null;        }    }    /**     * If true, require all compiler output to be in UTF8 format.     *     *@param  enabled  The new utf8Output value     */    public void setUtf8Output(boolean enabled) {        utf8output = enabled;    }    /**     *  Gets the utf8OutpuParameter attribute of the CSharp object     *     *@return    The utf8OutpuParameter value     */    protected String getUtf8OutputParameter() {        return utf8output ? "/utf8output" : null;    }    /**     * add a define to the list of definitions     * @param define     */    public void addDefine(DotnetDefine define) {        definitionList.addElement(define);    }    /**     * get a list of definitions or null     * @return a string beginning /D: or null for no definitions     */    protected String getDefinitionsParameter() throws BuildException {        StringBuffer defines = new StringBuffer();        Enumeration defEnum = definitionList.elements();        boolean firstDefinition = true;        while (defEnum.hasMoreElements()) {            //loop through all definitions            DotnetDefine define = (DotnetDefine) defEnum.nextElement();            if (define.isSet(this)) {                //add those that are set, and a delimiter                if (!firstDefinition) {                    defines.append(getDefinitionsDelimiter());                }                defines.append(define.getValue(this));                firstDefinition = false;            }        }        if (defines.length() == 0) {            return null;        } else {            return "/d:" + defines;        }    }    /**     * Semicolon separated list of modules to refer to.     *     *@param  params  The new additionalModules value     */    public void setAdditionalModules(String params) {        additionalModules = params;    }    /**     *  get the argument or null for no argument needed     *     *@return    The AdditionalModules Parameter to CSC     */    protected String getAdditionalModulesParameter() {        if (notEmpty(additionalModules)) {            return "/addmodule:" + additionalModules;        } else {            return null;        }    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getDestFileParameter() {        if (outputFile != null) {            return "/out:" + outputFile.toString();        } else {            return null;        }    }    /**     * If true, fail on compilation errors.     *     *@param  b  The new FailOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The FailFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     * link or embed a resource     * @param resource     */    public void addResource(DotnetResource resource) {        resources.add(resource);    }    /**     * This method gets the name of the executable.     * @return the name of the executable     */    protected String getExecutable() {        return executable;    }    /**     * set the name of the program, overriding the defaults.     * Can be used to set the full path to a program, or to switch     * to an alternate implementation of the command, such as the Mono or Rotor     * versions -provided they use the same command line arguments as the     * .NET framework edition     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     *  test for a string containing something useful     *     *@param  s  string in     *@return    true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (outputFile != null && outputFile.isDirectory()) {            throw new BuildException("destFile cannot be a directory");        }        if (getExecutable() == null) {            throw new BuildException("There is no executable defined for this task");        }    }    /**     * Get the pattern for files to compile.     * @return The compilation file pattern.     */    public String getFilePattern() {        return "**/*." + getFileExtension();    }    /**     * getter for flag     * @return The flag indicating whether the compilation is using a response file.     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * Flag to turn on response file use; default=false.     * When set the command params are saved to a file and     * this is passed in with @file. The task automatically switches     * to this mode with big commands; this option is here for     * testing and emergencies     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        validate();        NetCommand command = createNetCommand();        //set up response file options        command.setAutomaticResponseFileThreshold(AUTOMATIC_RESPONSE_FILE_THRESHOLD);        command.setUseResponseFile(useResponseFile);        //fill in args        fillInSharedParameters(command);        addResources(command);        addCompilerSpecificOptions(command);        int referencesOutOfDate            = addReferenceFilesets(command, getOutputFileTimestamp());        //if the refs are out of date, force a build.        boolean forceBuild = referencesOutOfDate > 0;        addFilesAndExecute(command, forceBuild);    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public abstract String getReferenceDelimiter();    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public abstract String getFileExtension();    /**     * fill in the common information     * @param command     */    protected void fillInSharedParameters(NetCommand command) {        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument("/nologo");        command.addArgument(getAdditionalModulesParameter());        command.addArgument(getDebugParameter());        command.addArgument(getDefinitionsParameter());        command.addArguments(getExtraOptionsParameters());        command.addArgument(getMainClassParameter());        command.addArgument(getOptimizeParameter());        command.addArgument(getDestFileParameter());        command.addArgument(getReferencesParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getUtf8OutputParameter());        command.addArgument(getWin32IconParameter());        command.addArgument(getWin32ResParameter());    }    /**     * for every resource declared, we get the (language specific)     * resource setting     */    protected void addResources(NetCommand command) {        Enumeration e = resources.elements();        while (e.hasMoreElements()) {            DotnetResource resource = (DotnetResource) e.nextElement();            createResourceParameter(command, resource);        }    }    /* XXX Javadoc makes little sense, rewrite     * from a resource, get the     * @param resource     * @return a string containing the resource param, or a null string     * to conditionally exclude a resource.     */    protected abstract void createResourceParameter(NetCommand command, DotnetResource resource);    /**     * run through the list of reference files and add them to the command     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int addReferenceFilesets(NetCommand command, long outputTimestamp) {        int filesOutOfDate = 0;        Hashtable filesToBuild = new Hashtable();        for (int i = 0; i < referenceFilesets.size(); i++) {            FileSet fs = (FileSet) referenceFilesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        //bail out early if there were no files        if (filesToBuild.size() == 0) {            return 0;        }        //now scan the hashtable and add the files        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            if (isFileManagedBinary(file)) {                if (isWindows) command.addArgument('"'+REFERENCE_OPTION+file.toString()+'"');                else command.addArgument(REFERENCE_OPTION+file.toString());            } else {                log("ignoring " + file + " as it is not a managed executable",                        Project.MSG_VERBOSE);            }        }        return filesOutOfDate;    }    /**     * create our helper command     * @return a command prefilled with the exe name and task name     */    protected NetCommand createNetCommand() {        NetCommand command = new NetCommand(this, getTaskName(), getExecutable());        return command;    }    /**     * add any compiler specifics     * @param command     */    protected abstract void addCompilerSpecificOptions(NetCommand command);    /**     * override point for delimiting definitions.     * @return The definitions limiter, i.e., ";"     */    public String getDefinitionsDelimiter() {        return ";";    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[] {                "exe",                "library",                "module",                "winexe"            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;/** * definitions can be conditional. What .NET conditions can not be * is in any state other than defined and undefined; you cannot give * a definition a value. */public class DotnetDefine {    private String name;    private String ifCond;    private String unlessCond;    /**     * the name of a property which must be defined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setIf(String condition) {        this.ifCond = condition;    }    /**     * the name of a property which must be undefined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setUnless(String condition) {        this.unlessCond = condition;    }    public String getName() {        return name;    }    /**     * the name of the definition. Required.     * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * This method gets the value of this definition. Will be null if a condition     * was declared and not met     * @param owner owning task     * @return The value of the definition.     * @throws BuildException     */    public String getValue(Task owner) throws BuildException {        if (name == null) {            throw new BuildException("No name provided for the define element",                owner.getLocation());        }        if (!isSet(owner)) {            return null;        }        return name;    }    /**     * logic taken from patternset     * @param owner     * @return true if the condition is valid     */    public boolean isSet(Task owner) {        Project p = owner.getProject();        if (ifCond != null && p.getProperty(ifCond) == null) {            return false;        } else if (unlessCond != null && p.getProperty(unlessCond) != null) {            return false;        }        return true;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import java.io.File;import java.util.ArrayList;import org.apache.tools.ant.types.FileSet;import java.util.Iterator;import org.apache.tools.ant.*;/** * Used by {@link DotnetCompile} to name resources. * Could be upgraded to a datatype in the distant future. * A resource maps to /res:file,name */public class DotnetResource {    /**     * name of resource     */    private File file;    /**     * embed (default) or link the resource     */    private boolean embed = true;    /**     * this is used in VBC and JSC     */    private Boolean isPublic = null;    /**     * name of the object     */    private String name = null;    /**     * A list of filesets with resources.     */    private ArrayList fileSets = new ArrayList();    /**     * a namespace to be used with <filesets>     */    private String namespace = null;    public boolean isEmbed() {        return embed;    }    /**     * embed the resource in the assembly (default, true) or just link to it.     *      * @param embed     */    public void setEmbed(boolean embed) {        this.embed = embed;    }    public File getFile() {        return file;    }    /**     * name the resource     *      * @param file     */    public void setFile(File file) {        this.file = file;    }    public Boolean getPublic() {        return isPublic;    }    /**     * VB and J# only: is a resource public or not?     *      * @param aPublic     */    public void setPublic(Boolean aPublic) {        isPublic = aPublic;    }    public String getName() {        return name;    }    /**     * should the resource have a name?     *      * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * Filesets root namespace. The value always ends with '.' .     *      * @return String namespace name     */    public String getNamespace() {        return namespace;    }    /**     * Sets filesets root namespace.     *      * @param namespace     *            String root namespace     */    public void setNamespace(String namespace) {        if (namespace == null) {            this.namespace = null;        } else {            this.namespace = (namespace.length() == 0 || namespace.endsWith(".") ? namespace                    : namespace + '.');        }    }    private void checkParameters() {        if (hasFilesets()) {            if (getName() != null)                throw new BuildException(                        "Cannot use <resource name=\"...\"> attribute with filesets");            if (getFile() != null)                throw new BuildException(                        "Cannot use <resource file=\"...\"> attribute with filesets");        } else {            if (getNamespace() != null)                throw new BuildException(                        "Cannot use <resource namespace=\"...\"> attribute without filesets");        }    }    /**     * build the C# style parameter (which has no public/private option)     */    public void getParameters(Project p, NetCommand command, boolean csharpStyle) {        checkParameters();        if (hasFilesets()) {            for (Iterator listIter = fileSets.iterator(); listIter.hasNext();) {                FileSet fs = (FileSet) listIter.next();                String baseDirectory = fs.getDir(p).toString();                String namespace = getNamespace(); // ends with '.' or null                DirectoryScanner ds = fs.getDirectoryScanner(p);                String[] files = ds.getIncludedFiles();                for (int i = 0; i < files.length; i++) {                    String file = files[i];                    command.addArgument(getParameter(baseDirectory + File.separatorChar + file,                            (namespace == null ? null : namespace                                    + file.replace(File.separatorChar, '.')), csharpStyle));                }            }        } else {            command.addArgument(getParameter(getFile().toString(), getName(), csharpStyle));        }    }    private String getParameter(String fileName, String name, boolean csharpStyle) {        StringBuffer buffer = new StringBuffer();        buffer.append(isEmbed() ? "/resource" : "/linkresource");        buffer.append(':');        buffer.append(fileName);        if (name != null) {            buffer.append(',');            buffer.append(name);            if (csharpStyle) {                if (getPublic() != null) {                    throw new BuildException("This compiler does not support the "                            + "public/private option.");                } else {                    if (getPublic() != null) {                        buffer.append(',');                        buffer.append(getPublic().booleanValue() ? "public" : "private");                    }                }            } else if (getPublic() != null) {                throw new BuildException("You cannot have a public or private "                        + "option without naming the resource");            }        }        return buffer.toString();    }    /**     * Adds a resource file set.     *      * @param fileset     *            FileSet     */    public void addFileset(FileSet fileset) {        fileSets.add(fileset);    }    /**     * Checks that <resource> node has embedded <filesets>     *      * @return boolean     */    public boolean hasFilesets() {        return fileSets.size() > 0;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * This task compiles F# source into executables or modules. * The task requires fsc.exe on the execute path, unless it or an equivalent * program is specified in the <tt>executable</tt> parameter * * <p> * All parameters are optional: &lt;fsc/&gt; should suffice to produce a debug * build of all *.fs files. * * <p> * The task is a directory based task, so attributes like * <tt>includes=&quot;**\/*.fs&quot;</tt> and * <tt>excludes=&quot;broken.fs&quot;</tt> can be used to control * the files pulled in. By default, * all *.fs files from the project folder down are included in the command. * When this happens the destFile -if not specified- * is taken as the first file in the list, which may be somewhat hard to control.   Specifying the output file with <tt>destfile</tt> is prudent. </p> <p> * Also, dependency checking only works if destfile is set. * * <p>For historical reasons the pattern * <code>**</code><code>/*.fs</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * As with &lt;csc&gt; nested <tt>src</tt> filesets of source, * reference filesets, definitions and resources can be provided. * * <p> * Example * </p> * <pre>&lt;fsc *   optimize=&quot;true&quot; *   debug=&quot;false&quot; *   warnLevel=&quot;4&quot; *   targetType=&quot;exe&quot; *   definitions=&quot;RELEASE&quot; *   excludes=&quot;src/unicode_class.fs&quot; *   destFile=&quot;NetApp.exe&quot; *   tailcalls=&quot;true&quot; *   references="System.Xml,System.Web.Xml" *   &gt; *          &lt;reference file="${testCSC.dll}" /&gt; *          &lt;define name="RELEASE" /&gt; *          &lt;define name="DEBUG" if="debug.property"/&gt; *          &lt;define name="def3" unless="def2.property"/&gt; *   &lt;/fsc&gt; </pre> * @ant.task    name="fsc" category="dotnet" */public class FSharp extends DotnetCompile {    /**     * Compiler option to enable tailcalls.     */    private boolean tailcalls = true;    /**     * Compiler option to enable cross-module optimizations.     */    private boolean crossoptimize = false;    /**     * Compiler option to statically link the F# library and all     * referenced DLLs into the assembly.     */    private boolean standalone = false;    public FSharp() {        clear();    }    /**     *  reset all contents.     */    public void clear() {        super.clear();        tailcalls = true;        crossoptimize = false;        standalone = false;        setExecutable("fsc");    }    /**     * Whether to enable tailcalls.     */    public void setTailcalls(boolean b) {        tailcalls = b;    }    /**     * Whether to enable tailcalls.     * @return    true if flag is turned on     */    public boolean getTailcalls() {        return tailcalls;    }    /**     * Form the option string for tailcalls.     * @return The parameter string.     */    public String getTailcallsParameter() {        return "/tailcalls" + (tailcalls ? "+" : "-");    }    /**     * Whether to enable cross-module optimizations.     */    public void setCrossoptimize(boolean b) {        crossoptimize = b;    }    /**     * Whether to enable cross-module optimizations.     * @return    true if flag is turned on     */    public boolean getCrossoptimize() {        return crossoptimize;    }    /**     * Form the option string for cross-module optimizations.     * @return The parameter string.     */    public String getCrossoptimizeParameter() {        return "/crossoptimize" + (crossoptimize ? "+" : "-");    }    /**     * Whether to create a standalone assembly.     */    public void setStandalone(boolean b) {        standalone = b;    }    /**     * Whether to create a standalone assembly.     * @return    true if flag is turned on     */    public boolean getStandalone() {        return standalone;    }    /**     * Form the option string for standalone.     * @return The parameter string.     */    public String getStandaloneParameter() {        return standalone ? "/standalone" : null;    }    /**     * implement FSC commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getTailcallsParameter());        command.addArgument(getCrossoptimizeParameter());        String s = getStandaloneParameter();        if (s != null) {            command.addArgument(s);        }    }    /**     * Get the delimiter that the compiler uses between references.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return "fs";    }    protected void createResourceParameter(NetCommand command,                                           DotnetResource resource) {        resource.getParameters(getProject(), command, false);    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;/** * Assembles .NET Intermediate Language files. * ilasm.exe must be on the execute path, unless another executable * or the full path to that executable is specified in the <tt>executable</tt> * parameter *  <p> * *  <p> * *  All parameters are optional: &lt;il/&gt; should suffice to produce a debug *  build of all *.il files. The option set is roughly compatible with the *  CSharp class; even though the command line options are only vaguely *  equivalent. [The low level commands take things like /OUT=file, csc wants *  /out:file ... /verbose is used some places; /quiet here in ildasm... etc.] *  It would be nice if someone made all the command line tools consistent (and *  not as brittle as the java cmdline tools) <p> *  <p> *  The task is a directory based task, so attributes like <b>includes="*.il" *  </b> and <b>excludes="broken.il"</b> can be used to control the files pulled *  in. You can also use nested &lt;src&gt filesets to refer to source. * <p> * * @ant.task    name="ilasm" category="dotnet" */public class Ilasm         extends DotnetBaseMatchingTask {    /**     *  Name of the executable. The .exe suffix is deliberately not included in     *  anticipation of the unix version     */    protected static final String exe_name = "ilasm";    /**     *  what is the file extension we search on?     */    protected static final String file_ext = "il";    /**     *  and now derive the search pattern from the extension     */    protected static final String file_pattern = "**/*." + file_ext;    /**     *  title of task for external presentation     */    protected static final String exe_title = "ilasm";    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  verbose flag     */    protected boolean verbose;    /**     *  listing flag     */    protected boolean listing;    /**     *  resource file (.res format) to include in the app.     */    protected File resourceFile;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  file containing private key     */    private File keyfile;    /**     *  any extra command options?     */    protected String extraOptions;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * @since Ant 1.7     */    private boolean isMono = !Os.isFamily("windows");    /**     *  constructor inits everything and set up the search pattern     */    public Ilasm() {        Clear();        setIncludes(file_pattern);    }    /**     *  reset all contents.     */    public void Clear() {        targetType = null;        srcDir = null;        listing = false;        verbose = false;        debug = true;        outputFile = null;        failOnError = true;        resourceFile = null;        extraOptions = null;    }    /**     * Sets the type of target, either "exe" or "library".     *     *@param  targetType          one of exe|library|     *@exception  BuildException  if target is not one of     *      exe|library     */    public void setTargetType(String targetType)             throws BuildException {        this.targetType = targetType.toLowerCase();        if (!targetType.equals("exe") && !targetType.equals("library")) {            throw new BuildException("targetType " + targetType + " is not a valid type");        }    }    /**     *  accessor method for target type     *     *@return    the current target option     */    public String getTargetType() {        return targetType;    }    /**     *  g get the target type or null for no argument needed     *     *@return    The TargetTypeParameter value     */    protected String getTargetTypeParameter() {        if (!notEmpty(targetType)) {            return null;        }        if (targetType.equals("exe")) {            return "/exe";        } else if (targetType.equals("library")) {            return "/dll";        } else {            return null;        }    }    /**     * Sets the Owner attribute.     *     * @param  s  The new Owner value     * @ant.attribute ignore="true"     */    public void setOwner(String s) {        log("This option is not supported by ILASM as of Beta-2, "            + "and will be ignored", Project.MSG_WARN);    }    /**     *  test for a string containing something useful     *     *@param  s       any string     *@return         true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     *  If true, enable verbose ILASM output.     *     *@param  b  flag set to true for verbose on     */    public void setVerbose(boolean b) {        verbose = b;    }    /**     *  turn the verbose flag into a parameter for ILASM     *     *@return    null or the appropriate command line string     */    protected String getVerboseParameter() {        return verbose ? null : "/quiet";    }    /**     * If true, produce a listing (off by default).     *     *@param  b  flag set to true for listing on     */    public void setListing(boolean b) {        listing = b;    }    /**     *  turn the listing flag into a parameter for ILASM     *     *@return    the appropriate string from the state of the listing flag     */    protected String getListingParameter() {        if (!isMono) {            return listing ? "/listing" : "/nolisting";        }        return null;    }    /**     * Set the output file; identical to setDestFile     * @see DotnetBaseMatchingTask#setDestFile     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        outputFile = params;    }    /**     *  get the output file     *     *@return    the argument string or null for no argument     */    protected String getOutputFileParameter() {        if (outputFile == null) {            return null;        }        return "/output=" + outputFile.toString();    }    /**     * name of resource file to include.     *     * @param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setResourceFile(File fileName) {        resourceFile = fileName;    }    /**     *  Gets the resourceFileParameter attribute of the Ilasm task     *     *@return    The resourceFileParameter value     */    protected String getResourceFileParameter() {        if (resourceFile != null) {            return "/resource=" + resourceFile.toString();        } else {            return null;        }    }    /**     * If true, fails if ilasm tool fails.     *     *@param  b  The new failOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the argument or null for no argument needed     *     *@return    The debugParameter value     */    protected String getDebugParameter() {        return debug ? "/debug" : null;    }    /**     * the name of a file containing a private key.     *     *@param  keyfile  The new keyfile value     */    public void setKeyfile(File keyfile) {        this.keyfile = keyfile;    }    /**     *  get the argument or null for no argument needed     *     *@return    The keyfileParameter value     */    protected String getKeyfileParameter() {        if (keyfile != null) {            return "/keyfile:" + keyfile.toString();        } else {            return null;        }    }    /**     * Any extra options which are not explicitly     * supported by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     * set the target type to one of exe|library     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Explicitly override the Mono auto-detection.     *     * <p>Defaults to false on Windows and true on any other platform.</p>     *     * @since Ant 1.7     */    public void setMono(boolean b) {        isMono = b;    }    /**     *  This is the execution entry point. Build a list of files and call ilasm     *  on each of them.     *     *@throws  BuildException  if the assembly failed and FailOnError is true     */    public void execute()             throws BuildException {        NetCommand command = buildIlasmCommand();        addFilesAndExecute(command, false);    }    // end execute    /**     * build up our ilasm command     * @return     */    private NetCommand buildIlasmCommand() {        NetCommand command = new NetCommand(this, exe_title, exe_name);        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument(getDebugParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getListingParameter());        command.addArgument(getOutputFileParameter());        command.addArgument(getResourceFileParameter());        command.addArgument(getVerboseParameter());        command.addArgument(getKeyfileParameter());        command.addArgument(getExtraOptionsParameter());        /*         *  space for more argumentativeness         *  command.addArgument();         *  command.addArgument();         */        return command;    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "exe",                "library",            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * Compile J# source down to a managed .NET application. * <p> * J# is not Java. But it is the language closest to Java in the .NET framework. * This task compiles jsharp source (.java files), and * generates a .NET managed exe or dll. * <p> * * <p>For historical reasons the pattern * <code>**</code><code>/*.java</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * @see <A=ref="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_vjsharp/html/vjoriMicrosoftVisualJ.asp"> * Visual J++ online documentation</a> * * @since ant1.6 * @ant.task category="dotnet" name="jsharpc" */public class JSharp extends DotnetCompile {    /**     * hex base address     */    String baseAddress;    /** /x option to disable J++ and J# lang extensions     *     */    boolean pureJava = true;    /**     * whether to make package scoped stuff public or assembly scoped     */    boolean secureScoping = false;    public JSharp() {        setExecutable("vjc");    }    public void setBaseAddress(String baseAddress) {        this.baseAddress = baseAddress;    }    /**     * do we want pure java (default, true) or corrupted J#?     * @param pureJava     */    public void setPureJava(boolean pureJava) {        this.pureJava = pureJava;    }    /**     * Make package scoped code visible to the current assembly only (default: false)     * .NET does not have package scoping. Instead it has assembly, private and public.     * By default, package content is public to all.     * @param secureScoping     */    public void setSecureScoping(boolean secureScoping) {        this.secureScoping = secureScoping;    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return ".java";    }    /**     * add jvc specific commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        if (pureJava) {            command.addArgument("/x:all");        }        if (secureScoping) {            command.addArgument("/securescoping");        }    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }    /**     * validation code     * @throws  org.apache.tools.ant.BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * This task compiles Visual Basic.NET source into executables or modules. * The task requires vbc.exe on the execute path, unless it or an equivalent * program is specified in the <tt>executable</tt> parameter * * <p> * All parameters are optional: &lt;vbc/&gt; should suffice to produce a debug * build of all *.vb files. * * <p> * The task is a directory based task, so attributes like * <tt>includes=&quot;**\/*.vb&quot;</tt> and * <tt>excludes=&quot;broken.vb&quot;</tt> can be used to control * the files pulled in. By default, * all *.vb files from the project folder down are included in the command. * When this happens the destFile -if not specified- * is taken as the first file in the list, which may be somewhat hard to control.   Specifying the output file with <tt>destfile</tt> is prudent. </p> <p> * Also, dependency checking only works if destfile is set. * * <p>For historical reasons the pattern * <code>**</code><code>/*.vb</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * As with &lt;csc&gt; nested <tt>src</tt> filesets of source, * reference filesets, definitions and resources can be provided. * * <p> * Example * </p> * <pre>&lt;vbc *   optimize=&quot;true&quot; *   debug=&quot;false&quot; *   warnLevel=&quot;4&quot; *   targetType=&quot;exe&quot; *   definitions=&quot;RELEASE&quot; *   excludes=&quot;src/unicode_class.vb&quot; *   mainClass = &quot;MainApp&quot; *   destFile=&quot;NetApp.exe&quot; *   optionExplicit=&quot;true&quot; *   optionCompare=&quot;text&quot; *   references="System.Xml,System.Web.Xml" *   &gt; *          &lt;reference file="${testCSC.dll}" /&gt; *          &lt;define name="RELEASE" /&gt; *          &lt;define name="DEBUG" if="debug.property"/&gt; *          &lt;define name="def3" unless="def2.property"/&gt; *   &lt;/vbc&gt; </pre> * @ant.task    name="vbc" category="dotnet" */public class VisualBasicCompile extends DotnetCompile {    /**     * Compiler option to remove integer checks. Default: false.     */    private boolean removeIntChecks = false;    /**     * Require explicit declaration of variables? Default: false.     */    private boolean optionExplicit = false;    /**     * Enforce strict language semantics? Default: false.     */    private boolean optionStrict = false;    /**     * Whether to compare strings as "text" or "binary". Default: "binary".     */    private String optionCompare;    /**     * Root namespace for all type declarations.     */    private String rootNamespace;    /**     * Declare global imports fornamespaces in referenced metadata files.     */    private String imports;    /**     * Constructor for VisualBasicCompile.     */    public VisualBasicCompile() {        clear();    }    /**     *  reset all contents.     */    public void clear() {        super.clear();        imports = null;        rootNamespace = null;        optionCompare = null;        optionExplicit = false;        optionStrict = false;        removeIntChecks = false;        setExecutable("vbc");    }    /**     *  get the argument or null for no argument needed     *  This is overridden from DotnetCompile.java because VBC uses     *  "/win32resource:" rather than "/win32res:"     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (getWin32Res() != null) {            return "/win32resource:" + getWin32Res().toString();        } else {            return null;        }    }    /**     * Whether to remove integer checks. Default false.     * @param  flag  on/off flag     */    public void setRemoveIntChecks(boolean flag) {        removeIntChecks = flag;    }    /**     * Get the flag for removing integer checks.     * @return    true if flag is turned on     */    public boolean getRemoveIntChecks() {        return removeIntChecks;    }    /**     * Form the option string for removeIntChecks.     * @return The parameter string.     */    public String getRemoveIntChecksParameter() {        return "/removeintchecks" + (removeIntChecks ? "+" : "-");    }    /**     * Whether to require explicit declaration of variables.     * @param  flag  on/off flag     */    public void setOptionExplicit(boolean flag) {        optionExplicit = flag;    }    /**     * Get the flag for whether to require explicit declaration of variables.     *@return    true if flag is turned on     */    public boolean getOptionExplicit() {        return optionExplicit;    }    /**     * Form the option string for optionExplicit..     * @return The parameter string.     */    public String getOptionExplicitParameter() {        return "/optionexplicit" + (optionExplicit ? "+" : "-");    }    /**     * Enforce strict language semantics.     * @param  flag  on/off flag     */    public void setOptionStrict(boolean flag) {        optionStrict = flag;    }    /**     * Get the flag for whether to enforce strict language semantics.     * @return    true if flag is turned on     */    public boolean getOptionStrict() {        return optionStrict;    }    /**     * For the option string for optionStrict.     * @return The parameter string.     */    public String getOptionStrictParameter() {        return "/optionstrict" + (optionStrict ? "+" : "-");    }    /**     * Specifies the root namespace for all type declarations.     * @param rootNamespace a root namespace.     */    public void setRootNamespace(String rootNamespace) {        this.rootNamespace = rootNamespace;    }    /**     * Get the root namespace.     * @return  the root namespace.     */    public String getRootNamespace() {        return this.rootNamespace;    }    /**     * Form the option string for rootNamespace.     * @return  the root namespace option string.     */    protected String getRootNamespaceParameter() {        if (rootNamespace != null && rootNamespace.length() != 0) {            return "/rootnamespace:" + rootNamespace;        } else {            return null;        }    }    /**     * Declare global imports for namespaces in referenced metadata files.     * @param imports the imports string     */    public void setImports(String imports) {        this.imports = imports;    }    /**     * Get global imports for namespaces in referenced metadata files.     * @return  the imports string.     */    public String getImports() {        return this.imports;    }    /**     * Format the option for imports.     * @return  the formatted import option.     */    protected String getImportsParameter() {        if (imports != null && imports.length() != 0) {            return "/imports:" + imports;        } else {            return null;        }    }    /**     * Specify binary- or text-style string comparisons. Defaults     * to "binary"     * @param optionCompare the option compare style. "text" | "binary".     */    public void setOptionCompare(String optionCompare) {        if ("text".equalsIgnoreCase(optionCompare)) {            this.optionCompare = "text";        } else {            this.optionCompare = "binary";        }    }    /**     * "binary" or "text" for the string-comparison style.     * @return  the option compare style.     */    public String getOptionCompare() {        return this.optionCompare;    }    /**     * Format the option for string comparison style.     * @return  The formatted option.     */    protected String getOptionCompareParameter() {        if (optionCompare != null && "text".equalsIgnoreCase(optionCompare)) {            return "/optioncompare:text";        } else {            return "/optioncompare:binary";        }    }    /**     * implement VBC commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getRemoveIntChecksParameter());        command.addArgument(getImportsParameter());        command.addArgument(getOptionExplicitParameter());        command.addArgument(getOptionStrictParameter());        command.addArgument(getRootNamespaceParameter());        command.addArgument(getOptionCompareParameter());    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ",";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return "vb";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, false);    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import java.util.Iterator;import java.net.MalformedURLException;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.util.FileUtils;/** * Converts a WSDL file or URL resource into a .NET language. * * Why add a wrapper to the MS WSDL tool? * So that you can verify that your web services, be they written with Axis or *anyone else's SOAP toolkit, work with .NET clients. * *This task is dependency aware when using a file as a source and destination; *so if you &lt;get&gt; the file (with <code>usetimestamp="true"</code>) then *you only rebuild stuff when the WSDL file is changed. Of course, *if the server generates a new timestamp every time you ask for the WSDL, *this is not enough...use the &lt;filesmatch&gt; &lt;condition&gt; to *to byte for byte comparison against a cached WSDL file then make *the target conditional on that test failing. * See "Creating an XML Web Service Proxy", "wsdl.exe" docs in * the framework SDK documentation * @version     0.5 * @ant.task    category="dotnet" * @since       Ant 1.5 */public class WsdlToDotnet extends Task  {    /**     * used for timestamp checking     */    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * name of output file (required)     */    private File destFile = null;    /**     * language; defaults to C#     */    private String language = "CS";    /**     * flag set to true to generate server side skeleton     */    private boolean server = false;    /**     * namespace     */    private String namespace = null;    /**     *  flag to control action on execution trouble     */    private boolean failOnError = true;    /**     *  any extra command options?     */    protected String extraOptions = null;    /**     * protocol string. Exact value set depends on SOAP stack version.     * @since Ant 1.7     */    private String protocol = null;    /**     * should errors come in an IDE format. This     * is WSE only.     * @since Ant 1.7     */    private boolean ideErrors = false;    /**     * filesets of file to compile     * @since Ant 1.7     */    private Vector schemas = new Vector();    /**     * our WSDL file.     * @since ant1.7     */    private Schema wsdl = new Schema();    /**     * compiler     * @since ant1.7     */    private Compiler compiler = null;    /**     * error message: dest file is a directory     */    public static final String ERROR_DEST_FILE_IS_DIR = "destination file is a directory";    /**     * error message: no dest file     */    public static final String ERROR_NO_DEST_FILE = "destination file must be specified";    /**     * Name of the file to generate. Required     * @param destFile filename     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * Sets the URL to fetch. Fetching is by wsdl.exe; Ant proxy settings     * are ignored; either url or srcFile is required.     * @param url url to save     */    public void setUrl(String url) {        wsdl.setUrl(url);    }    /**     * The local WSDL file to parse; either url or srcFile is required.     * @param srcFile WSDL file     */    public void setSrcFile(File srcFile) {        wsdl.setFile(srcFile);    }    /**     * set the language; one of "CS", "JS", or "VB"     * optional, default is CS for C# source     * @param language language to generate     */    public void setLanguage(String language) {        this.language = language;    }    /**     * flag to enable server side code generation;     * optional, default=false     * @param server server-side flag     */    public void setServer(boolean server) {        this.server = server;    }    /**     * namespace to place  the source in.     * optional; default ""     * @param namespace new namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * Whether or not a failure should halt the build.     * Optional - default is <code>true</code>.     * @param failOnError new failure option     */    public void setFailOnError(boolean failOnError) {        this.failOnError = failOnError;    }    /**     *  Any extra WSDL.EXE options which aren't explicitly     *  supported by the ant wrapper task; optional     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * Defines wether errors are machine parseable.     * Optional, default=true     *     * @since Ant 1.7     * @param ideErrors     */    public void setIdeErrors(boolean ideErrors) {        this.ideErrors = ideErrors;    }    /**     * what protocol to use. SOAP, SOAP1.2, HttpPost and HttpGet     * are the base options. Different version and implementations may.     * offer different options.     * @since Ant 1.7     *     * @param protocol     */    public void setProtocol(String protocol) {        this.protocol = protocol;    }    /**     * add a new source schema to the compilation     * @since Ant 1.7     *     * @param source     */    public void addSchema(Schema source) {        schemas.add(source);    }    /**     * flag to trigger turning a filename into a file:url     * ignored for the mono compiler.     * @param b     */    public void setMakeURL(boolean b) {        wsdl.setMakeURL(b);    }    /**     * identify the compiler     * @since Ant 1.7     * @param compiler     */    public void setCompiler(Compiler compiler) {        this.compiler = compiler;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException(ERROR_NO_DEST_FILE);        }        if (destFile.isDirectory()) {            throw new BuildException(                    ERROR_DEST_FILE_IS_DIR);        }        wsdl.validate();    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        if ("WsdlToDotnet".equals(getTaskType())) {            log("Warning: the task name <WsdlToDotnet> is deprecated. Use <wsdltodotnet> (all lowercase) instead.", Project.MSG_WARN);        }        if (compiler == null) {            compiler = Compiler.createDefaultCompiler();        }        validate();        NetCommand command = new NetCommand(this,                "WSDL",                compiler.getCommand());        command.setFailOnError(failOnError);        //fill in args        compiler.applyExtraArgs(command);        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/language:", language);        if (server) {            command.addArgument("/server");        }        command.addArgument("/namespace:", namespace);        if (protocol != null) {            command.addArgument("/protocol:" + protocol);        }        if (ideErrors) {            command.addArgument("/parsableErrors");        }        command.addArgument(extraOptions);        //set source and rebuild options        boolean rebuild = true;        long destLastModified = -1;        //rebuild unless the dest file is newer than the source file        if (destFile.exists()) {            destLastModified = destFile.lastModified();            rebuild = isRebuildNeeded(wsdl, destLastModified);        }        String path;        //mark for a rebuild if the dest file is newer        path = wsdl.evaluate();        if (!compiler.supportsAbsoluteFiles() && wsdl.getFile() != null) {            // Mono 1.0's wsdl doesn't deal with absolute paths            File f = wsdl.getFile();            command.setDirectory(f.getParentFile());            path = f.getName();        }        command.addArgument(path);        //add in any extra files.        //this is an error in mono, but we do not warn on it as they may fix that outside        //the ant build cycle.        Iterator it = schemas.iterator();        while (it.hasNext()) {            Schema schema = (Schema) it.next();            //mark for a rebuild if we are newer            rebuild |= isRebuildNeeded(schema, destLastModified);            command.addArgument(schema.evaluate());        }        //conditionally compile        if (rebuild) {            command.runCommand();        }    }    /**     * checks for a schema being out of data     * @param schema url/file     * @param destLastModified timestamp, -1 for no dest     * @return true if a rebuild is needed.     */    private boolean isRebuildNeeded(Schema schema, long destLastModified) {        if (destLastModified == -1) {            return true;        }        return !FILE_UTILS.isUpToDate(schema.getTimestamp(), destLastModified);    }    /**     * nested schema class     * Only supported on NET until mono add multi-URL handling on the command line     */    public static class Schema {        private File file;        private String url;        private boolean makeURL = false;        public static final String ERROR_NONE_DECLARED = "One of file and url must be set";        public static final String ERROR_BOTH_DECLARED = "Only one of file or url can be set";        public static final String ERROR_FILE_NOT_FOUND = "Not found: ";        public static final String ERROR_FILE_IS_DIR = "File is a directory: ";        public static final String ERROR_NO_URL_CONVERT = "Could not URL convert ";        /**         * validate the schema         */        public  void validate() {            if (file != null) {                if (!file.exists()) {                    throw new BuildException(ERROR_FILE_NOT_FOUND + file.toString());                }                if (file.isDirectory()) {                    throw new BuildException(ERROR_FILE_IS_DIR + file.toString());                }            }            if (file != null && url != null) {                throw new BuildException(ERROR_BOTH_DECLARED);            }            if (file == null && url == null) {                throw new BuildException(ERROR_NONE_DECLARED);            }        }        /**         * Validate our settings.         * @return either the URL or the full file path         */        public String evaluate() {            validate();            if (url != null) {                return getUrl();            }            if (makeURL) {                try {                    return FILE_UTILS.getFileURL(file).toExternalForm();                } catch (MalformedURLException e) {                    throw new BuildException(ERROR_NO_URL_CONVERT + file);                }            }            return file.toString();        }        public File getFile() {            return file;        }        /**         * name of a file to use as a source of WSDL or XSD data         * @param file         */        public void setFile(File file) {            this.file = file;        }        public String getUrl() {            return url;        }        /**         * url of a resource.         * URLs have no timestamp checking, and are not validated         * @param url         */        public void setUrl(String url) {            this.url = url;        }        public boolean isMakeURL() {            return makeURL;        }        /**         * flag to request that a file is turned into an absolute file: URL         * before being passed to the WSDL compiler         * @param makeURL         */        public void setMakeURL(boolean makeURL) {            this.makeURL = makeURL;        }        /**         * Gets the file timestamp.         * @return the timestamp of a file, or -1 for a URL (meaning we do not know its age)         */        public long getTimestamp() {            if (file != null) {                return file.lastModified();            } else {                return -1;            }        }    }    /**     * The enumerated values for our compiler     */    public static class Compiler extends EnumeratedAttribute {        public static final String COMPILER_MS = "microsoft";        public static final String COMPILER_MONO = "mono";        public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono";        String[] compilers = {            COMPILER_MS,            COMPILER_MONO,            COMPILER_MS_ON_MONO        };        public static final String EXE_WSDL = "wsdl";        public static final String EXE_MONO = "mono";        /**         * programs to run         */        String[] compilerExecutables = {            EXE_WSDL,            EXE_WSDL,            EXE_MONO        };        /**         * extra things         */        String[][] extraCompilerArgs = {            {},            {},            {EXE_WSDL + ".exe"}        };        boolean[] absoluteFiles = {            true,            false,            true        };        /**         * This is the only method a subclass needs to implement.         *         * @return an array holding all possible values of the enumeration.         *         The order of elements must be fixed so that <tt>indexOfValue(String)</tt>         *         always return the same index for the same value.         */        public String[] getValues() {            return compilers;        }        /**         * Create the default compiler for this platform.         * @return the default compiler         */        public static Compiler createDefaultCompiler() {            Compiler c = new Compiler();            String compilerName;            compilerName = Os.isFamily("windows") ? COMPILER_MS : COMPILER_MONO;            c.setValue(compilerName);            return c;        }        /**         * return the command to run         * @return the command         */        public String getCommand() {            return compilerExecutables[getIndex()];        }        /**         * return any extra arguments for the compiler         * @return extra compiler arguments         */        public String[] getExtraArgs() {            return extraCompilerArgs[getIndex()];        }        public boolean supportsAbsoluteFiles() {            return absoluteFiles[getIndex()];        }        /**         * apply any extra arguments of this class         * @param command         */        public void applyExtraArgs(NetCommand command) {            String[] args = getExtraArgs();            for (int i = 0; i < args.length; i++) {               command.addArgument(args[i]);            }        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.util;import java.util.Collection;import java.util.Iterator;/** * Helper methods related to collection manipulation. * * <p>This is a stripped down copy of Ant 1.8.2's version so the .NET * Antlib can still be used with Ant 1.7.0.</p> * * @since .NET Antlib 1.1 */public class CollectionUtils {    /**     * Creates a comma separated list of all values held in the given     * collection.     *     * @since .NET Antlib 1.1     */    public static String flattenToString(Collection c) {        return flattenToString(c, ",");    }    /**     * Creates a list of all values held in the given collection     * separated by the given separator.     *     * @since .NET Antlib 1.1     */    public static String flattenToString(Collection c, String sep) {        Iterator iter = c.iterator();        boolean first = true;        StringBuffer sb = new StringBuffer();        while (iter.hasNext()) {            if (!first) {                sb.append(sep);            }            sb.append(String.valueOf(iter.next()));            first = false;        }        return sb.toString();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.wix;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.ant.dotnet.build.AbstractBuildTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.DirSet;import java.io.File;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.Set;/** * Task to run the tallow on packaging content to create a wxs file * * @see http://sf.net/projects/wix */public class TallowTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source dirs.     */    private ArrayList sources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * Where is WiX installed?     */    private File wixHome = null;    /**     * addtional command line arguments for tallow.     */    private Commandline cmdl = new Commandline();    public TallowTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>tallow</code> may include more directories than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * The main target file.     *     * @param File object of the main target file.     */    public void setTarget(File f) {        target = f;    }    /**     * A set of source files.     */    public void addSources(DirSet ds) {        sources.add(ds);    }    /**     * Sets the installation directory of WiX.     *     * <p>If omitted, Ant will assume that WiX's executables can be     * found on the PATH.</p>     */    public void setWixHome(File f) {        wixHome = f;    }    /**     * Adds a command-line argument for tallow.exe.     *     * @return new command line argument created.     */    public Commandline.Argument createArg() {        return cmdl.createArgument();    }    public void execute() {        Collection grabbedDirs = grabSources();        if (target == null) {            throw new BuildException("You must specify the target if you want"                                     + " to run tallow.");        }        runTallow(grabbedDirs);    }    private Collection grabSources() {        Set r = new HashSet();        if (source != null) {            if (!source.exists()) {                throw new BuildException("Source " + source                                         + " doesn't exist.");            } else if (!source.isDirectory()) {                throw new BuildException("Source " + source                                         + " is not directory.");            }            r.add(source);        } else if (sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        } else {            Iterator iter = sources.iterator();            while (iter.hasNext()) {                DirSet ds = (DirSet) iter.next();                DirectoryScanner scanner = ds.getDirectoryScanner(getProject());                String[] f = scanner.getIncludedDirectories();                File base = ds.getDir(getProject());                for (int i = 0; i < f.length; i++) {                    r.add(new File(base, f[i]));                }            }            if (r.isEmpty()) {                throw new BuildException("No sources found");            }        }        return r;    }    /**     * Run tallow passing all files of the collection on the command line.     */    private void runTallow(Collection s) {        run(wixExecutable("tallow.exe"), s, target, cmdl);    }    /**     * returns an absolute path for the given executable if wixHome     * has been specified, the given name otherwise.     */    private String wixExecutable(String name) {        return wixHome == null ? name            : new File(wixHome, name).getAbsolutePath();    }    /**     * Runs the specified command passing all files of the collection     * on the command line - potentially adding an /out parameter.     */    private void run(String executable, Collection s, File target,                     Commandline cmdl) {        DotNetExecTask exec =             DotNetExecTask.getTask(this, vm, executable, null);        exec.setFailonerror(true);        exec.setTaskType("wix");        exec.createArg().setValue("/nologo");        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue("-d");            exec.createArg().setValue(f.getAbsolutePath());        }        String[] extraArgs = cmdl.getArguments();        for (int i = 0; i < extraArgs.length; i++) {            exec.createArg().setValue(extraArgs[i]);        }        exec.setOutput (target);        exec.execute();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.wix;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.ant.dotnet.build.AbstractBuildTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;import java.io.File;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;/** * Task to run the WiX utility to create MSI files from an XML description. * * @see http://sf.net/projects/wix */public class WixTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source files.     */    private ArrayList sources = new ArrayList();    /**     * Additional source files (include files in the case of candle,     * or media/files/whatever in the case of light).     */    private ArrayList moreSources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * What to do.     */    private Mode mode;    /**     * Where is WiX installed?     */    private File wixHome = null;    /**     * Where to place the generated .wixobj files.     */    private File wixobjDestDir = null;    /**     * addtional command line arguments for candle.     */    private Commandline candleCmdl = new Commandline();    /**     * list of parameters for the preprocessor.     */    private ArrayList candleParameters = new ArrayList();    /**     * addtional command line arguments for light.     */    private Commandline lightCmdl = new Commandline();    /**     * list of parameters for the "compiler".     */    private ArrayList lightParameters = new ArrayList();    /**     * Whether to use lit.exe rather than light.exe.     */    private boolean useLit = false;    public WixTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>candle</code> may include more files than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * The main target file.     *     * @param File object of the main target file.     */    public void setTarget(File f) {        target = f;    }    /**     * A set of source files.     */    public void addSources(FileSet fs) {        sources.add(fs);    }    /**     * A set of additional source files (include files in the case of     * candle, or media/files/whatever in the case of light).     *     * <p>Unlike the files specified as sources, these will not be     * passed on the command line, they only help Ant to determine     * whether the target is out-of-date.</p>     */    public void addMoreSources(FileSet fs) {        moreSources.add(fs);    }    /**     * Sets the installation directory of WiX.     *     * <p>If omitted, Ant will assume that WiX's executables can be     * found on the PATH.</p>     */    public void setWixHome(File f) {        wixHome = f;    }    /**     * Whether to run candle, light or both.     */    public void setMode(Mode m) {        mode = m;    }    /**     * Sets the destination directory for wixobj files generated by candle.     *     * <p>Let's candle decide and assumes they'll be created in the     * current working directory.</p>     */    public void setWixobjDestDir(File f) {        wixobjDestDir = f;    }    /**     * A parameter to pass to candle.exe.     */    public final void addCandleParameter(AbstractBuildTask.Property t) {        candleParameters.add(t);    }    /**     * A parameter to pass to light.exe.     */    public final void addLightParameter(AbstractBuildTask.Property t) {        lightParameters.add(t);    }    /**     * Adds a command-line argument for light.exe.     *     * @return new command line argument created.     */    public Commandline.Argument createLightArg() {        return lightCmdl.createArgument();    }    /**     * Adds a command-line argument for candle.exe.     *     * @return new command line argument created.     */    public Commandline.Argument createCandleArg() {        return candleCmdl.createArgument();    }    /**     * Instructs the task to use lit.exe rather than light.exe as "compiler".     *     * @since .NET Antlib 1.1     */    public void setUseLit(boolean b) {        useLit = b;    }    public void execute() {        if (source == null && sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        }        if (source != null && !source.exists()) {            throw new BuildException("Source file " + source                                     + " doesn't exist.");        }        String m = Mode.BOTH;        if (mode != null) {            m = mode.getValue();        }        if (target == null && !m.equals(Mode.CANDLE)) {            throw new BuildException("You must specify the target if you want"                                     + " to run light.");        }        Collection lightSources = null;        if (!m.equals(Mode.LIGHT)) {            lightSources = doCandle();        } else {            lightSources = new HashSet();            if (source != null) {                lightSources.add(source);            }            if (sources.size() > 0) {                lightSources.addAll(grabFiles(sources));            }        }        if (!m.equals(Mode.CANDLE)) {            Collection moreLightSources = Collections.EMPTY_SET;            if (moreSources.size() > 0) {                moreLightSources = grabFiles(moreSources);            }            doLight(lightSources, moreLightSources);        }    }    /**     * Invoke candle on all sources that are newer than their targets.     *     * @return a set of File objects pointing to the generated files.     */    private Collection doCandle() {        Set s = new HashSet();        if (source != null) {            s.add(source);        }        if (sources != null) {            s.addAll(grabFiles(sources));        }        Set ms = new HashSet();        if (moreSources != null) {            ms.addAll(grabFiles(moreSources));        }        Set toProcess = new HashSet();        Set generatedTargets = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            File thisSource = (File) iter.next();            File t = getTarget(thisSource);            generatedTargets.add(t);            if (isOutOfDate(t, thisSource, ms)) {                toProcess.add(thisSource);            }        }        if (toProcess.size() != 0) {            runCandle(toProcess);            return generatedTargets;        }        return Collections.EMPTY_SET;    }    /**     * Invoke light on all sources that are newer than their targets.     */    private void doLight(Collection lightSources,                         Collection moreLightSources) {        Set tmp = new HashSet(lightSources);        tmp.addAll(moreLightSources);        if (isOutOfDate(target, tmp)) {            runLight(lightSources);        }    }    /**     * Run candle passing all files of the collection on the command line.     */    private void runCandle(Collection s) {        run(wixExecutable("candle.exe"), s, null, wixobjDestDir,            candleParameters, candleCmdl);    }    /**     * Run light passing all files of the collection on the command line.     */    private void runLight(Collection s) {        run(wixExecutable(useLit ? "lit.exe" : "light.exe"), s, target, null,            lightParameters, lightCmdl);    }    /**     * returns an absolute path for the given executable if wixHome     * has been specified, the given name otherwise.     */    private String wixExecutable(String name) {        return wixHome == null ? name            : new File(wixHome, name).getAbsolutePath();    }    /**     * Runs the specified command passing all files of the collection     * on the command line - potentially adding an /out parameter.     */    private void run(String executable, Collection s, File target,                     File runInDir, Collection params, Commandline cmdl) {        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      executable, null);        if (runInDir != null) {            exec.setDir(runInDir);        }        exec.setFailonerror(true);        exec.setTaskType("wix");        exec.createArg().setValue("/nologo");        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue(f.getAbsolutePath());        }        if (target != null) {            exec.createArg().setValue("/out");            exec.createArg().setValue(target.getAbsolutePath());        }        iter = params.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                (AbstractBuildTask.Property) iter.next();            exec.createArg().setValue("-d" + p.getName() + "=" + p.getValue());        }        String[] extraArgs = cmdl.getArguments();        for (int i = 0; i < extraArgs.length; i++) {            exec.createArg().setValue(extraArgs[i]);        }        exec.execute();    }    /**     * Is t older than s or any of the files in list?     */    private boolean isOutOfDate(File t, File s, Collection l) {        return t.lastModified() < s.lastModified() || isOutOfDate(t, l);    }    /**     * Is t older than any of the files in list?     */    private boolean isOutOfDate(File t, Collection l) {        Iterator iter = l.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            if (t.lastModified() < f.lastModified()) {                return true;            }        }        return false;    }    /**     * Turn the fileset collection into a list of Files.     */    private Collection grabFiles(Collection s) {        Set r = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            FileSet fs = (FileSet) iter.next();            DirectoryScanner ds = fs.getDirectoryScanner(getProject());            String[] f = ds.getIncludedFiles();            File base = fs.getDir(getProject());            for (int i = 0; i < f.length; i++) {                r.add(new File(base, f[i]));            }        }        return r;    }    /**     * Generates the name of a candle target from the source file.     *     * <p>Simply chops of the extension, adds .wixobj and calculates     * the absolute path based on wixobjDestDir.</p>     */    private File getTarget(File s) {        String name = s.getName();        int dot = name.lastIndexOf(".");        if (dot > -1) {            name = name.substring(0, dot) + ".wixobj";        } else {            name = name + ".wixobj";        }        return wixobjDestDir == null            ? new File(name) : new File(wixobjDestDir, name);    }    public static class Mode extends EnumeratedAttribute {        private final static String CANDLE = "candle";        private final static String LIGHT = "light";        private final static String BOTH = "both";        public Mode() {            super();        }        public String[] getValues() {            return new String[] {CANDLE, LIGHT, BOTH,};        }    }}
Apache .NET Ant Library/*  *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. *  */ /** * this is a j# class, not a java one. */public class jsharp {        public static void main(String args[]) {		System.out.println("hello, I look like Java, but I'm really J#");    }    }
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.util.DOMElementWriter;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.XMLFragment;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Base class for NAntTask and MSBuildTask. */public abstract class AbstractBuildTask extends Task {    /**     * The buildfile to invoke the build tool for.     */    private File buildFile;    /**     * The targets to execute.     */    private List targets = new ArrayList();    /**     * Properties to set.     */    private List properties = new ArrayList(1);    /**     * Nested build file fragment.     */    private XMLFragment buildSnippet;    /**     * The vm attribute - if given.     */    private String vm;    /**     * Empty constructor.     */    protected AbstractBuildTask() {    }    /**     * Sets the name of the build file.     */    public final void setBuildfile(File f) {        buildFile = f;    }    /**     * Adds a build file fragment.     */    public void addBuild(XMLFragment f) {        if (buildSnippet == null) {            buildSnippet = f;        } else {            throw new BuildException("You must not specify more than one "                                     + "build element");        }    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * A target.     */    public static class Target {        private String name;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }    }    /**     * A target to execute.     */    public final void addTarget(Target t) {        targets.add(t);    }    /**     * A property.     */    // XXX, could have reused Property or Environment.Variable     //      - not decided so far    public static class Property {        private String name;        private String value;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public void setValue(String value) {            this.value = value;        }        public String getValue() {            return value;        }    }    /**     * A target to execute.     */    public final void addProperty(Property t) {        properties.add(t);    }    /**     * Must return the executable.     *     * @return must not return null     */    protected abstract String getExecutable();    /**     * Must return buildfile argument(s).     *     * @param buildFile the absolute File for the buildfile or null if     * the user didn't specify a buildfile.     *     * @return must not return null     */    protected abstract String[] getBuildfileArguments(File buildFile);    /**     * Must return target argument(s).     *     * @return must not return null     */    protected abstract String[] getTargetArguments(List targets);    /**     * Must return property argument(s).     *     * @return must not return null     */    protected abstract String[] getPropertyArguments(List properties);    /**     * Turn the DoucmentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>Must throw a BuildException if the snippet can not be turned     * into a build file.</p>     */    protected abstract Element makeTree(DocumentFragment f);    /**     * Perform the build.     */    public void execute() {        if (buildFile != null && buildSnippet != null) {            throw new BuildException("You must not specify the build file"                                     + " attribute and a nested build at the"                                     + " same time");        }        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      getExecutable(), null);        String[] args = getPropertyArguments(properties);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        args = getTargetArguments(targets);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        File generatedFile = null;        if (buildSnippet != null) {            try {                generatedFile = getBuildFile();            } catch (IOException e) {                throw new BuildException(e);            }            args = getBuildfileArguments(generatedFile);        } else {            args = getBuildfileArguments(buildFile);        }                for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        try {            exec.execute();        } finally {            if (generatedFile != null) {                generatedFile.delete();            }        }    }    private File getBuildFile() throws IOException {        File f = null;        if (buildSnippet != null) {            Element e = makeTree(buildSnippet.getFragment());            f = FileUtils.newFileUtils().createTempFile("build", ".xml", null);            f.deleteOnExit();            FileOutputStream out = null;            try {                out = new FileOutputStream(f);                (new DOMElementWriter()).write(e, out);            } finally {                if (out != null) {                    out.close();                }            }        }        return f;    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.taskdefs.ExecTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.Environment;/** * Specialized <exec> that knows how to deal with Mono vs. Microsoft's * VM - and maybe Rotor at some point. */public class DotNetExecTask extends ExecTask {    /**     * "Magic" VM argument for Microsoft's VM.     */    private static final String MS_VM = "microsoft";    /**     * The user supplied executable attribute.     */    private String executable;    /**     * The .NET VM to use.     *     * <p>Defaults to Microsoft's on Windows and mono on any other     * platform.</p>     */    private String vm = Os.isFamily("windows") ? MS_VM : "mono";    /**     * Empty Constructor.     */    public DotNetExecTask() {        super();    }    /**     * Set the name of the executable program.     * @param value the name of the executable program     */    public void setExecutable(String value) {        this.executable = value;    }    /**     * Set the name of the executable for the virtual machine or the     * magic name "microsoft" which implies that we can invoke the     * executable directly.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Do the work.     *     * @throws BuildException if executable is empty or &lt;exec&gt;     * throws an exception.     */    public void execute() throws BuildException {        if (executable == null) {            throw new BuildException("The executable attribute is required");        }        setupCommandline();        super.execute();    }    /**     * If the inherited Commandline doesn't know about the executable     * yet, set it and deal with the vm attribute.     *     * <p>The inherited Commandline may know the executable already if     * this task instance is getting reused.</p>     */    protected void setupCommandline() {        if (cmdl.getExecutable() == null) {            if (vm.equals(MS_VM)) {                // can invoke executable directly                super.setExecutable(executable);            } else {                boolean b = getResolveExecutable();                // Mono wants the absolte path of the assembly                setResolveExecutable(b || isMono(vm));                super.setExecutable(vm);                cmdl.createArgument(true)                    .setValue(resolveExecutable(executable, isMono(vm)));                setResolveExecutable(b);            }        }    }    /**     * Whether the given vm looks like the Mono executable.     */    protected final static boolean isMono(String vm) {        return "mono".equals(vm) || "mint".equals(vm);    }    /**     * Creates an instance of this task based on a different tasks settings.     */    public static DotNetExecTask getTask(Task t, String vm,                                          String executable,                                         Environment env) {        DotNetExecTask exec = new DotNetExecTask();        if (vm != null) {            exec.setVm(vm);        }        exec.setProject(t.getProject());        exec.setExecutable(executable);        exec.setTaskName(t.getTaskName());        if (env != null) {            String[] environment = env.getVariables();            if (environment != null) {                for (int i = 0; i < environment.length; i++) {                    int idx = environment[i].indexOf("=");                    Environment.Variable v = new Environment.Variable();                    v.setKey(environment[i].substring(0, idx));                    v.setValue(environment[i].substring(idx + 1));                    exec.addEnv(v);                }            }        }                return exec;    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a MSBuild build process. */public class MSBuildTask extends AbstractBuildTask {    private static final String TARGET = "generated-by-ant";    public MSBuildTask() {        super();    }    protected String getExecutable() {        return "MSBuild.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        if (targets.size() > 0) {            StringBuffer sb = new StringBuffer("/targets:");            Iterator iter = targets.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Target t =                     (AbstractBuildTask.Target) iter.next();                if (!first) {                    sb.append(";");                }                sb.append(t.getName());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    protected String[] getPropertyArguments(List properties) {        if (properties.size() > 0) {            StringBuffer sb = new StringBuffer("/property:");            Iterator iter = properties.iterator();            boolean first = true;            while (iter.hasNext()) {                AbstractBuildTask.Property p =                     (AbstractBuildTask.Property) iter.next();                if (!first) {                    sb.append(";");                }                sb.append(p.getName()).append("=").append(p.getValue());            }            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <Project> child, return that.     * Otherwise if we have only <Task> children, wrap them into a     * <Target> which in turn gets wrapped into a <Project>.     * Otherwise, fail.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals("Project")) {            return (Element) nl.item(0);        } else {            Element p = f.getOwnerDocument().createElement("Project");            p.setAttribute("DefaultTargets", TARGET);            Element t = f.getOwnerDocument().createElement("Target");            t.setAttribute("Name", TARGET);            p.appendChild(t);            t.appendChild(f);            return p;        }    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a NAnt build process. */public class NAntTask extends AbstractBuildTask {    public NAntTask() {        super();    }    protected String getExecutable() {        return "NAnt.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                "-buildfile:" + buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        ArrayList al = new ArrayList(targets.size());        Iterator iter = targets.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Target t = (AbstractBuildTask.Target) iter.next();            al.add(t.getName());        }        return (String[]) al.toArray(new String[al.size()]);    }    protected String[] getPropertyArguments(List properties) {        ArrayList al = new ArrayList(properties.size());        Iterator iter = properties.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                 (AbstractBuildTask.Property) iter.next();            al.add("-D:" + p.getName() + "=" + p.getValue());        }        return (String[]) al.toArray(new String[al.size()]);    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <project> child, return that.     * Otherwise assume that this is a valid build file snippet that     * just needs an empty project wrapped around it.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals("project")) {            return (Element) nl.item(0);        } else {            Element e = f.getOwnerDocument().createElement("project");            e.appendChild(f);            return e;        }    }}
Apache .NET Ant Library/* * Copyright  2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Environment;import org.apache.tools.ant.types.RedirectorElement;import java.io.File;import java.util.ArrayList;import java.util.Iterator;/** * Task to run the NUnit Console test runner. * * @see http://www.nunit.org/ */public class NUnitTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * Test assemblies.     */    private ArrayList testAssemblies = new ArrayList();    /**     * The /config argument.     */    private File configFile;    /**     * The /output argument.     */    private File out;    /**     * The /err argument.     */    private File err;    /**     * The /xml argument.     */    private File xmlOut;    /**     * The /transform argument.     */    private File transform;    /**     * The /thread argument.     */    private boolean thread = false;    /**     * The /fixture argument.     */    private String fixture;    /**     * Categories to include.     */    private ArrayList includes = new ArrayList();    /**     * Categories to exclude.     */    private ArrayList excludes = new ArrayList();    /**     * The /noshadow argument.     */    private boolean noshadow = false;    /**     * The /labels argument.     */    private boolean labels = false;    /**     * Redirects everything that NUnit wants to send to the console.     */    private RedirectorElement redirectorElement;    /**     * Whether a failure should stop the build.     */    private boolean failOnError = false;    /**     * Support for nested environment variables.     */    private Environment env = new Environment();    public NUnitTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the config file.     */    public void setConfig(File c) {        configFile = c;    }    /**     * The /output argument.     */    public void setOut(File out) {        this.out = out;    }    /**     * The /err argument.     */    public void setError(File err) {        this.err = err;    }    /**     * The /xml argument.     */    public void setXmlOut(File out) {        this.xmlOut = out;    }    /**     * The /transform argument.     */    public void setTransform(File transform) {        this.transform = transform;    }    /**     * The /thread argument.     */    public void setThread(boolean thread) {        this.thread = thread;    }    /**     * The /fixture argument.     */    public void setFixture(String fixture) {        this.fixture = fixture;    }    /**     * The /noshadow argument.     */    public void setNoshadow(boolean noshadow) {        this.noshadow = noshadow;    }    /**     * The /labels argument.     */    public void setLabels(boolean labels) {        this.labels = labels;    }    /**     * Whether a failure should stop the build.     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Adds a test assembly by name.     */    public void addTestAssembly(NamedElement a) {        testAssemblies.add(a);    }    /**     * Adds a category to the include list.     */    public void addInclude(NamedElement a) {        includes.add(a);    }    /**     * Adds a category to the exclude list.     */    public void addExclude(NamedElement a) {        excludes.add(a);    }    /**     * Add an environment variable to the launched process.     *     * @param var new environment variable     */    public void addEnv(Environment.Variable var) {        env.addVariable(var);    }    /**     * Add a <code>RedirectorElement</code> to this task.     *     * <p>This does not use the <code>out</code> and     * <code>error</code> attributes, it only captures NUnits output     * that has not been redirected by those attributes.</p>     */    public void addConfiguredRedirector(RedirectorElement redirectorElement) {        if (this.redirectorElement != null) {            throw new BuildException("cannot have > 1 nested <redirector>s");        } else {            this.redirectorElement = redirectorElement;        }    }    public void execute() {        if (testAssemblies.size() == 0) {            throw new BuildException("You must specify at least one test "                                     + "assembly.");        }                DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      "nunit-console.exe",                                                     env);        Iterator iter = testAssemblies.iterator();        while (iter.hasNext()) {            NamedElement a = (NamedElement) iter.next();            exec.createArg().setValue(a.getName());        }        if (configFile != null) {            exec.createArg().setValue("/config="                                       + configFile.getAbsolutePath());        }        exec.createArg().setValue("/nologo");        if (out != null) {            exec.createArg().setValue("/output=" + out.getAbsolutePath());        }        if (err != null) {            exec.createArg().setValue("/err=" + err.getAbsolutePath());        }        if (xmlOut != null) {            exec.createArg().setValue("/xml=" + xmlOut.getAbsolutePath());        }        if (transform != null) {            exec.createArg().setValue("/transform="                                       + transform.getAbsolutePath());        }        if (thread) {            exec.createArg().setValue("/thread");        }        if (noshadow) {            exec.createArg().setValue("/noshadow");        }        if (labels) {            exec.createArg().setValue("/labels");        }        if (fixture != null) {            exec.createArg().setValue("/fixture=" + fixture);        }                if (includes.size() > 0) {            StringBuffer sb = new StringBuffer("/include=");            iter = includes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (excludes.size() > 0) {            StringBuffer sb = new StringBuffer("/exclude=");            iter = excludes.iterator();            boolean first = false;            while (iter.hasNext()) {                if (first) {                    first = false;                } else {                    sb.append(",");                }                NamedElement a = (NamedElement) iter.next();                sb.append(a.getName());            }            exec.createArg().setValue(sb.toString());        }        if (redirectorElement != null) {            exec.addConfiguredRedirector(redirectorElement);        }        exec.setFailonerror(failOnError);        exec.execute();    }    public static class NamedElement {        private String name;        public String getName() {return name;}        public void setName(String s) {name = s;}    }}
Apache .NET Ant Library/* * Copyright  2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;import java.io.File;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * Task to run the WiX utility to create MSI files from an XML description. * * @see http://sf.net/projects/wix */public class WixTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source files.     */    private ArrayList sources = new ArrayList();    /**     * Additional source files (include files in the case of candle,     * or media/files/whatever in the case of light).     */    private ArrayList moreSources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * What to do.     */    private Mode mode;    public WixTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>candle</code> may include more files than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * A set of source files.     */    public void addSources(FileSet fs) {        sources.add(fs);    }    /**     * A set of additional source files (include files in the case of     * candle, or media/files/whatever in the case of light).     *     * <p>Unlike the files specified as sources, these will not be     * passed on the command line, they only help Ant to determine     * whether the target is out-of-date.</p>     */    public void addMoreSources(FileSet fs) {        moreSources.add(fs);    }    public void execute() {        if (source == null && sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        }        String m = Mode.BOTH;        if (mode != null) {            m = mode.getValue();        }        if (target == null && !m.equals(Mode.CANDLE)) {            throw new BuildException("You must specify the target if you want"                                     + " to run light.");        }        List lightSources = new ArrayList();        if (!m.equals(Mode.LIGHT)) {            doCandle(lightSources);        } else {            if (source != null) {                lightSources.add(source);            }            if (sources.size() > 0) {                lightSources.addAll(grabFiles(sources));            }        }        List moreLightSources = new ArrayList();        if (moreSources.size() > 0) {            moreLightSources = grabFiles(moreSources);        }        if (!m.equals(Mode.CANDLE)) {            doLight(lightSources, moreLightSources);        }    }    /**     * Invoke candle on all sources that are newer than their targets.     *     * @param lightSources list that will be filled with File objects     * pointing to the generated object files.     */    private void doCandle(List lightSources) {        List s = new ArrayList();        if (source != null) {            s.add(source);        }        if (sources != null) {            s.addAll(grabFiles(sources));        }        List ms = new ArrayList();        if (moreSources != null) {            ms.addAll(grabFiles(moreSources));        }        Iterator iter = s.iterator();        List toProcess = new ArrayList();        while (iter.hasNext()) {            File thisSource = (File) iter.next();            File t = target;            if (t == null) {                t = getTarget(thisSource);            }            if (isOutOfDate(t, thisSource, ms)) {                toProcess.add(thisSource);                lightSources.add(t);            }        }        if (toProcess.size() != 0) {            runCandle(toProcess);        }    }    /**     * Invoke light on all sources that are newer than their targets.     */    private void doLight(List lightSources, List moreLightSources) {        List tmp = new ArrayList(lightSources);        tmp.addAll(moreLightSources);        if (isOutOfDate(target, tmp)) {            runLight(lightSources);        }    }    /**     * Run candle passing all files in list on the command line.     */    private void runCandle(List s) {        run("candle.exe", s, null);    }    /**     * Run light passing all files in list on the command line.     */    private void runLight(List s) {        run("light.exe", s, target);    }    /**     * Runs the specified command passing list on the command line an     * potentially adding an /out parameter.     */    private void run(String executable, List s, File target) {        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      executable, null);        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue(f.getAbsolutePath());        }        if (target != null) {            exec.createArg().setValue("/out");            exec.createArg().setValue(target.getAbsolutePath());        }                exec.execute();    }    /**     * Is t older than s or any of the files in list?     */    private boolean isOutOfDate(File t, File s, List l) {        return t.lastModified() < s.lastModified() || isOutOfDate(t, l);    }    /**     * Is t older than any of the files in list?     */    private boolean isOutOfDate(File t, List l) {        Iterator iter = l.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            if (t.lastModified() < f.lastModified()) {                return true;            }        }        return false;    }    /**     * Turn the fileset collection into a list of Files.     */    private List grabFiles(List s) {        List r = new ArrayList();        Iterator iter = s.iterator();        while (iter.hasNext()) {            FileSet fs = (FileSet) iter.next();            DirectoryScanner ds = fs.getDirectoryScanner(getProject());            String[] f = ds.getIncludedFiles();            File base = fs.getDir(getProject());            for (int i = 0; i < f.length; i++) {                r.add(new File(base, f[i]));            }        }        return r;    }    /**     * Generates the name of a candle target from the source file.     *     * <p>Simply chops of the extension and adds .wixobj.</p>     */    private File getTarget(File s) {        String name = s.getAbsolutePath();        int dot = name.lastIndexOf(".");        if (dot > -1) {            return new File(name.substring(0, dot) + ".wixobj");        } else {            return new File(name + ".wixobj");        }    }    public static class Mode extends EnumeratedAttribute {        private final static String CANDLE = "candle";        private final static String LIGHT = "light";        private final static String BOTH = "both";        public Mode() {            super();        }        public String[] getValues() {            return new String[] {CANDLE, LIGHT, BOTH,};        }    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.util;import org.w3c.dom.Document;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.Text;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DynamicConfiguratorNS;import org.apache.tools.ant.ProjectHelper;/** * Use this class as a nested element if you want to get a literal DOM * fragment of something nested into your task/type. * * <p>This is useful for tasks that want to deal with the "real" XML * from the build file instead of objects.</p> * * <p>Code heavily influenced by code written by Dominique Devienne.</p> * * @since Ant 1.7 */public class XMLFragment implements DynamicConfiguratorNS {    private Document doc;    private DocumentFragment fragment;    public XMLFragment() {        doc = JAXPUtils.getDocumentBuilder().newDocument();        fragment = doc.createDocumentFragment();    }    /**     * Return the DocumentFragment that corresponds to the nested     * structure.     */    public DocumentFragment getFragment() {        return fragment;    }    /**     * Add nested text.     */    public void addText(String s) {        addText(fragment, s);    }    /**     * No attributes for the wrapping element.     */    public void setDynamicAttribute(String uri, String name, String qName, String value)        throws BuildException {        throw new BuildException("Attribute " + name + " is not supported.");    }    /**     * Creates a nested element.     */    public Object createDynamicElement(String uri, String name, String qName) {        Element e = doc.createElementNS(uri, qName);        fragment.appendChild(e);        return new Child(e);    }    private void addText(Node n, String s) {        if (s != null && !s.trim().equals("")) {            Text t = doc.createTextNode(s);            n.appendChild(t);        }    }    public class Child implements DynamicConfiguratorNS {        private Element e;        Child(Element e) {            this.e = e;        }        /**         * Add nested text.         */        public void addText(String s) {            XMLFragment.this.addText(e, s);        }        /**         * Sets the attribute         */        public void setDynamicAttribute(            String uri, String name, String qName, String value) {            if (uri.equals("")) {                e.setAttribute(name, value);            } else {                e.setAttributeNS(uri, qName, value);            }        }        /**         * Creates a nested element.         */        public Object createDynamicElement(String uri, String name, String qName) {            Element e2 = null;            if (uri.equals("")) {                e2 = doc.createElement(name);            } else {                e2 = doc.createElementNS(uri, qName);            }            e.appendChild(e2);            return new Child(e2);        }    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the DotNetExecTask task, based off Ant's DotnetTest. * */public class DotNetExecTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public DotNetExecTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "dotnetexec.xml");    }    /**     * The teardown method for JUnit     */    public void tearDown() {        executeTarget("teardown");    }    /**     * A unit test for JUnit     */    public void testCSC() throws Exception {        executeTarget("testCSC");    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the MSBuildTask task. */public class MSBuildTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public MSBuildTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "msbuild.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }    public void testNestedTask() throws Exception {        if (getProject().getProperty("msbuild.found") != null) {            expectLogContaining("nested-task", "foo is bar");        }    }}
Apache .NET Ant Library/* * Copyright  2003-2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the NAntTask task. */public class NAntTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public NAntTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "nant.xml");    }    public void testEcho() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("echo", "foo is bar");        }    }    public void testNestedFile() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-file", "foo is bar");        }    }    public void testNestedTask() throws Exception {        if (getProject().getProperty("nant.found") != null) {            expectLogContaining("nested-task", "foo is bar");        }    }}
Apache .NET Ant Library/* * Copyright  2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.tools.ant.taskdefs.optional.dotnet;import org.apache.tools.ant.BuildFileTest;/** * Tests the NUnitTask task. */public class NUnitTaskTest extends BuildFileTest {    /**     * Description of the Field     */    private final static String TASKDEFS_DIR = "src/etc/testcases/";    /**     * Constructor      *     * @param name testname     */    public NUnitTaskTest(String name) {        super(name);    }    /**     * The JUnit setup method     */    public void setUp() {        configureProject(TASKDEFS_DIR + "nunit.xml");    }    /**     * The teardown method for JUnit     */    public void tearDown() {        executeTarget("teardown");    }    public void testNoAssembly() {        expectSpecificBuildException("no-assembly", "no assembly",                                      "You must specify at least one test assembly.");    }    public void testPass() {        if (getProject().getProperty("nunit.found") != null) {            expectLogContaining("passing-test",                                 "Tests run: 1, Failures: 0, Not run: 0");        }    }    public void testFail() {        if (getProject().getProperty("nunit.found") != null) {            expectLogContaining("failing-test",                                 "Tests run: 1, Failures: 1, Not run: 0");        }    }    public void testFailOnFail() {        if (getProject().getProperty("nunit.found") != null) {            expectBuildException("failing-test-with-fail", "test should fail");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.taskdefs.Execute;import org.apache.tools.ant.taskdefs.ExecTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.Environment;/** * Specialized <exec> that knows how to deal with Mono vs. Microsoft's * VM - and maybe Rotor at some point. */public class DotNetExecTask extends ExecTask {    /**     * "Magic" VM argument for Microsoft's VM.     */    private static final String MS_VM = "microsoft";    /**     * The user supplied executable attribute.     */    private String executable;    /**     * The .NET VM to use.     *     * <p>Defaults to Microsoft's on Windows and mono on any other     * platform.</p>     */    private String vm = Os.isFamily("windows") ? MS_VM : "mono";    /**     * Name of property to set if execution fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Empty Constructor.     */    public DotNetExecTask() {        super();    }    /**     * Set the name of the executable program.     * @param value the name of the executable program     */    public void setExecutable(String value) {        this.executable = value;    }    /**     * Set the name of the executable for the virtual machine or the     * magic name "microsoft" which implies that we can invoke the     * executable directly.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the property to set if execution fails.     *     * <p>Not exposed as an attribute of the task, it just supports     * tasks like &lt;nunit&gt; which delegate to instances of this     * class.</p>     *     * @since 1.0 Beta 2     */    public void internalSetErrorProperty(String name) {        errorProperty = name;    }    /**     * Do the work.     *     * @throws BuildException if executable is empty or &lt;exec&gt;     * throws an exception.     */    public void execute() throws BuildException {        if (executable == null) {            throw new BuildException("The executable attribute is required");        }        setupCommandline();        super.execute();    }    /**     * Overridden to support the error-property handling required by     * NUnit, NAnt and friends.     *     * @since 1.0 Beta 2     */    protected void maybeSetResultPropertyValue(int result) {        if (errorProperty != null && Execute.isFailure(result)) {            getProject().setNewProperty(errorProperty, String.valueOf(true));        }        super.maybeSetResultPropertyValue(result);    }    /**     * If the inherited Commandline doesn't know about the executable     * yet, set it and deal with the vm attribute.     *     * <p>The inherited Commandline may know the executable already if     * this task instance is getting reused.</p>     */    protected void setupCommandline() {        if (cmdl.getExecutable() == null) {            if (vm.equals(MS_VM)) {                // can invoke executable directly                super.setExecutable(executable);            } else {                boolean b = getResolveExecutable();                // Mono wants the absolte path of the assembly                setResolveExecutable(b || isMono(vm));                super.setExecutable(vm);                cmdl.createArgument(true)                    .setValue(resolveExecutable(executable, isMono(vm)));                setResolveExecutable(b);            }        }    }    /**     * Whether the given vm looks like the Mono executable.     */    protected final static boolean isMono(String vm) {        return "mono".equals(vm) || "mint".equals(vm);    }    /**     * Creates an instance of this task based on a different tasks settings.     */    public static DotNetExecTask getTask(Task t, String vm,                                          String executable,                                         Environment env) {        DotNetExecTask exec = new DotNetExecTask();        if (vm != null) {            exec.setVm(vm);        }        exec.setProject(t.getProject());        exec.setExecutable(executable);        exec.setTaskName(t.getTaskName());        if (env != null) {            String[] environment = env.getVariables();            if (environment != null) {                for (int i = 0; i < environment.length; i++) {                    int idx = environment[i].indexOf("=");                    Environment.Variable v = new Environment.Variable();                    v.setKey(environment[i].substring(0, idx));                    v.setValue(environment[i].substring(idx + 1));                    exec.addEnv(v);                }            }        }                return exec;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Task to take a .NET or Mono -generated managed executable and turn it * into ILASM assembly code. Useful when converting imported typelibs into * assembler before patching and recompiling, as one has to do when doing * advanced typelib work. * <p> * As well as generating the named output file, the ildasm program * will also generate resource files <code>Icons.resources</code> * <code>Message.resources</code> and a .res file whose filename stub is derived * from the source in ways to obscure to determine. * There is no way to control whether or not these files are created, or where they are created * (they are created in the current directory; their names come from inside the * executable and may be those used by the original developer). This task * creates the resources in the directory specified by <code>resourceDir</code> if * set, else in the same directory as the <code>destFile</code>. * * <p> * This task requires the .NET SDK installed and ildasm on the path. * To disassemble using alternate CLR systems, set the executable attribute * to the name/path of the alternate implementation -one that must * support all the classic ildasm commands. * * <p> * Dependency logic: the task executes the command if the output file is missing * or older than the source file. It does not take into account changes * in the options of the task, or timestamp differences in resource files. * When the underlying ildasm executable fails for some reason, it leaves the * .il file in place with some error message. To prevent this from confusing * the dependency logic, the file specified by the <code>dest</code> * attribute is <i>always</i> deleted after an unsuccessful build. * @ant.task category="dotnet" */public class Ildasm extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();        /**     * source file (mandatory)     */    private File sourceFile;    /**     * dest file (mandatory)     */    private File destFile;    /**     * progress bar switch     */    private boolean progressBar = false;    /**     * what is our encoding     */    private String encoding;    /**     * /bytes flag for byte markup     */    private boolean bytes = false;    /**     * line numbers? /linenum     */    private boolean linenumbers = false;    /**     * /raweh flag for raw exception handling     */    private boolean rawExceptionHandling = false;    /**     * show the source; /source     */    private boolean showSource = false;    /**     * /quoteallnames to quote all names     */    private boolean quoteallnames = false;    /**     * /header for header information     */    private boolean header = false;    /**     * when false, sets the /noil attribute     * to suppress assembly info     */    private boolean assembler = true;    /**     * include metadata     * /tokens     */    private boolean metadata = false;    /**     * what visibility do we want.     *     */    private String visibility;    /**     * specific item to disassemble     */    private String item;    /**     * override for the executable     */    private String executable = "ildasm";    /**     *  name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    private File resourceDir;    /**     * Set the name of the directory for resources to be created. We cannot control     * their names, but we can say where they get created. If not set, the     * directory of the dest file is used     */    public void setResourceDir(File resourceDir) {        this.resourceDir = resourceDir;    }    /**     * override the name of the executable (normally ildasm) or set     * its full path. Do not set a relative path, as the ugly hacks     * needed to create resource files in the dest directory     * force us to change to this directory before running the application.     * i.e use &lt;property location&gt to create an absolute path from a     * relative one before setting this value.     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     * Select the output encoding: ascii, utf8 or unicode     * @param encoding     */    public void setEncoding(EncodingTypes encoding) {        this.encoding = encoding.getValue();    }    /**     * enable (default) or disable assembly language in the output     * @param assembler     */    public void setAssembler(boolean assembler) {        this.assembler = assembler;    }    /**     * enable or disable (default) the original bytes as comments     * @param bytes     */    public void setBytes(boolean bytes) {        this.bytes = bytes;    }    /**     * the output file (required)     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * include header information; default false.     * @param header     */    public void setHeader(boolean header) {        this.header = header;    }    /**     * name a single item to decode; a class or a method     * e.g item="Myclass::method" or item="namespace1::namespace2::Myclass:method(void(int32))     * @param item     */    public void setItem(String item) {        this.item = item;    }    /**     * include line number information; default=false     * @param linenumbers     */    public void setLinenumbers(boolean linenumbers) {        this.linenumbers = linenumbers;    }    /**     * include metadata information     * @param metadata     */    public void setMetadata(boolean metadata) {        this.metadata = metadata;    }    /**     * show a graphical progress bar in a window during the process; off by default     * @param progressBar     */    public void setProgressBar(boolean progressBar) {        this.progressBar = progressBar;    }    /**     * quote all names.     * @param quoteallnames     */    public void setQuoteallnames(boolean quoteallnames) {        this.quoteallnames = quoteallnames;    }    /**     * enable raw exception handling (default = false)     * @param rawExceptionHandling     */    public void setRawExceptionHandling(boolean rawExceptionHandling) {        this.rawExceptionHandling = rawExceptionHandling;    }    /**     * include the source as comments (default=false)     */    public void setShowSource(boolean showSource) {        this.showSource = showSource;    }    /**     * the file to disassemble -required     * @param sourceFile     */    public void setSourceFile(File sourceFile) {        this.sourceFile = sourceFile;    }    /**     * alternate name for sourceFile     * @param sourceFile     */    public void setSrcFile(File sourceFile) {        setSourceFile(sourceFile);    }    /**     * This method sets the visibility options. It chooses one or more of the following, with + signs to     * concatenate them:     * <pre>     * pub : Public     * pri : Private     * fam : Family     * asm : Assembly     * faa : Family and Assembly     * foa : Family or Assembly     * psc : Private Scope     *</pre>     * e.g. visibility="pub+pri".     * Family means <code>protected</code> in C#;     * @param visibility     */    public void setVisibility(String visibility) {        this.visibility = visibility;    }    /**     *  verify that source and dest are ok     */    private void validate() {        if (sourceFile == null || !sourceFile.exists() || !sourceFile.isFile()) {            throw new BuildException("invalid source");        }        if (destFile == null || destFile.isDirectory()) {            throw new BuildException("invalid dest");        }        if (resourceDir != null                && (!resourceDir.exists() || !resourceDir.isDirectory())) {            throw new BuildException("invalid resource directory");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isDisassemblyNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = sourceFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The .il file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * do the work     * @throws BuildException     */    public void execute() throws BuildException {        validate();        if (!isDisassemblyNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ildasm", executable);        command.setFailOnError(true);        //fill in args        command.addArgument("/text");        command.addArgument("/out=" + destFile.toString());        if (!progressBar) {            command.addArgument("/nobar");        }        if (linenumbers) {            command.addArgument("/linenum");        }        if (showSource) {            command.addArgument("/source");        }        if (quoteallnames) {            command.addArgument("/quoteallnames");        }        if (header) {            command.addArgument("/header");        }        if (!assembler) {            command.addArgument("/noil");        }        if (metadata) {            command.addArgument("/tokens");        }        command.addArgument("/item:", item);        if (rawExceptionHandling) {            command.addArgument("/raweh");        }        command.addArgument(EncodingTypes.getEncodingOption(encoding));        if (bytes) {            command.addArgument("/bytes");        }        command.addArgument("/vis:", visibility);        //add the source file        command.addArgument(sourceFile.getAbsolutePath());        //determine directory: resourceDir if set,        //the dir of the destFile if not        File execDir = resourceDir;        if (execDir == null) {            execDir = destFile.getParentFile();        }        command.setDirectory(execDir);        //now run        try {            command.runCommand();        } catch (BuildException e) {            //forcibly delete the output file in case of trouble            if (destFile.exists()) {                log("Deleting destination file as it may be corrupt");                destFile.delete();            }            //then rethrow the exception            throw e;        }    }    /**     * encoding options; the default is ascii     */    public static class EncodingTypes extends EnumeratedAttribute {        public final static String UNICODE = "unicode";        public final static String UTF8 = "utf8";        public final static String ASCII = "ascii";        public String[] getValues() {            return new String[]{                ASCII,                UTF8,                UNICODE,            };        }        /**         * This method maps from an encoding enum to an encoding option.         * @param enumValue         * @return The encoding option indicated by the enum value.         */        public static String getEncodingOption(String enumValue) {            if (UNICODE.equals(enumValue)) {                return "/unicode";            }            if (UTF8.equals(enumValue)) {                return "/utf8";            }            return null;        }    }    /**     * visibility options for decoding     */    public static class VisibilityOptions extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "pub", //Public                "pri", //Private                "fam", //Family                "asm", //Assembly                "faa", //Family and Assembly                "foa", //Family or Assembly                "psc", //Private Scope            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.tools.ant.Task;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.util.FileUtils;import java.io.File;/** * Import a COM type library into the .NET framework. * <p> * * This task is a wrapper to .NET's tlbimport; it imports a tlb file to a NET assembly * by generating a binary assembly (.dll) that contains all the binding * metadata. It uses date timestamps to minimise rebuilds. * <p> * Example * <pre> *     &lt;importtypelib *       srcfile="xerces.tlb" *       destfile="xerces.dll" *       namespace="Apache.Xerces"/&gt; * </pre> * @since Ant 1.6 * @ant.task category="dotnet" */public class ImportTypelib extends Task {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * input file; precedes options     */    private File srcFile;    /**     * /out:file     */    private File destFile;    /**     *  /namespace:[string]     */    private String namespace;    /**     * /sysarray     */    private boolean useSysArray = false;    /**     * /unsafe     */    private boolean unsafe = false;    /**     * extra commands?     */    private String extraOptions = null;    /**     * This method names the output file.     *     * This is an operation which is required to have been performed.     * @param destFile     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * This method sets what namespace the typelib is to be in.     * This is an operation which is required to have been performed.     * @param namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * This method sets which is the source .tlb file.     * This is an operation which is required to have been performed.     * @param srcFile     */    public void setSrcFile(File srcFile) {        this.srcFile = srcFile;    }    /**     * do you want unsafe code.     * @param unsafe     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     * set this to map a COM SafeArray to the System.Array class     * @param useSysArray     */    public void setUseSysArray(boolean useSysArray) {        this.useSysArray = useSysArray;    }    /**     * set any extra options that are not yet supported by this task.     * @param extraOptions     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException("destination file must be specified");        }        if (destFile.isDirectory()) {            throw new BuildException(                    "destination file is a directory");        }        if (srcFile == null || !srcFile.exists()) {            throw new BuildException(                    "source file does not exist");        }        if (srcFile.isDirectory()) {            throw new BuildException(                    "source file is a directory");        }        if (namespace == null) {            throw new BuildException("No namespace");        }    }    /**     * Test for disassembly being needed; use existence and granularity     * correct date stamps     * @return true iff a rebuild is required.     */    private boolean isExecuteNeeded() {        if (!destFile.exists()) {            log("Destination file does not exist: a build is required",                    Project.MSG_VERBOSE);            return true;        }        long sourceTime = srcFile.lastModified();        long destTime = destFile.lastModified();        if (sourceTime > (destTime + FILE_UTILS.getFileTimestampGranularity())) {            log("Source file is newer than the dest file: a rebuild is required",                    Project.MSG_VERBOSE);            return true;        } else {            log("The output file is up to date", Project.MSG_VERBOSE);            return false;        }    }    /**     * Create a typelib command     * @exception BuildException if something goes wrong with the build     */    public void execute() throws BuildException {        validate();        log("Importing typelib " + srcFile            + " to assembly " + destFile            + " in namespace " + namespace, Project.MSG_VERBOSE);        //rebuild unless the dest file is newer than the source file        if (!isExecuteNeeded()) {            return;        }        NetCommand command = new NetCommand(this, "ImportTypelib", "tlbimp");        command.setFailOnError(true);        command.addArgument(srcFile.toString());        //fill in args        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/namespace:", namespace);        if (useSysArray) {            command.addArgument("/sysarray");        }        if (unsafe) {            command.addArgument("/unsafe");        }        command.addArgument(extraOptions);        command.runCommand();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  The reference CD to listen to while editing this file is *  Underworld Everything, Everything *  variable naming policy from Fowler's refactoring book. */// place below the optional ant tasks packagepackage org.apache.ant.dotnet;// importsimport java.io.File;import java.io.IOException;import java.io.FileOutputStream;import java.io.PrintWriter;import java.io.BufferedOutputStream;import java.util.ArrayList;import java.util.Hashtable;import java.util.List;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.taskdefs.Execute;import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;import org.apache.tools.ant.taskdefs.LogStreamHandler;import org.apache.tools.ant.types.Commandline;/** *  This is a helper class to spawn net commands out. In its initial form it *  contains no .net specifics, just contains all the command line/exe *  construction stuff. However, it may be handy in future to have a means of *  setting the path to point to the dotnet bin directory; in which case the *  shared code should go in here. * */public class NetCommand {    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     *  owner project     */    protected Task owner;    /**     *  executable     */    protected Execute executable;    /**     *  what is the command line     */    protected Commandline commandLine;    /**     *  title of the command     */    protected String title;    /**     *  actual program to invoke     */    protected String program;    /**     *  trace flag     */    protected boolean traceCommandLine = false;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     * the directory to execute the command in. When null, the current     * directory is used.     */    private File directory;    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    /**     * name of a temp file; may be null     */    private File temporaryCommandFile;    /**     * internal threshold for auto-switch     */    private int automaticResponseFileThreshold = 64;    /**     * List of command line arguments that must appear on the command     * line and must not go into a response file.     * @since .NET Antlib 1.1     */    private List argsOnCommandLine = new ArrayList();    /**     *  constructor     *     *@param  title        (for logging/errors)     *@param  owner        owner task     *@param  program      app we are to run     */    public NetCommand(Task owner, String title, String program) {        this.owner = owner;        this.title = title;        this.program = program;        commandLine = new Commandline();        commandLine.setExecutable(program);    }    /**     *  turn tracing on or off     *     *@param  b  trace flag     */    public void setTraceCommandLine(boolean b) {        traceCommandLine = b;    }    /**     *  set fail on error flag     *     *@param  b  fail flag -set to true to cause an exception to be raised if     *      the return value != 0     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailFailOnError() {        return failOnError;    }    /**     * set the directory to run from, if the default is inadequate     * @param directory     */    public void setDirectory(File directory) {        this.directory = directory;    }    /**     *  verbose text log     *     *@param  msg  string to add to log if verbose is defined for the build     */    protected void logVerbose(String msg) {        owner.getProject().log(msg, Project.MSG_VERBOSE);    }    /**     *  error text log     *     *@param  msg  message to display as an error     */    protected void logError(String msg) {        owner.getProject().log(msg, Project.MSG_ERR);    }    /**     *  add an argument to a command line; do nothing if the arg is null or     *  empty string     *     * <p>The given argument may be added to a response file.</p>     *     * @param  argument  The feature to be added to the Argument attribute     */    public void addArgument(String argument) {        addArgument(argument, true);    }    /**     * add an argument to a command line; do nothing if the arg is     * null or empty string     *     * @param argument  The feature to be added to the Argument attribute     * @param mayBeInResponseFile whether the argument is allowed     * inside a response file.     *     * @since .NET Antlib 1.1     */    public void addArgument(String argument, boolean mayBeInResponseFile) {        if (argument != null && argument.length() != 0) {            commandLine.createArgument().setValue(argument);            if (!mayBeInResponseFile) {                argsOnCommandLine.add(argument);            }        }    }    /**     * Add multiple arguments to a command line; do nothing for args     * that are is null or empty strings     *     * <p>The given arguments may be added to a response file.</p>     *     * @param  arguments  The features to be added to the Argument attribute     */    public void addArguments(String[] arguments) {        if (arguments != null && arguments.length != 0) {            for (int i = 0; i < arguments.length; i++) {                addArgument(arguments[i], true);            }        }    }    /**     *  concatenate two strings together and add them as a single argument,     *  but only if argument2 is non-null and non-zero length     *     * <p>The resulting argument may be added to a response file.</p>     *     *@param  argument1  The first argument     *@param  argument2  The second argument     */    public void addArgument(String argument1, String argument2) {        if (argument2 != null && argument2.length() != 0) {            addArgument(argument1 + argument2, true);        }    }    /**     * getter     * @return response file state     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * set this to true to always use the response file     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     * getter for threshold     * @return 0 for disabled, or a threshold for enabling response files     */    public int getAutomaticResponseFileThreshold() {        return automaticResponseFileThreshold;    }    /**     * set threshold for automatically using response files -use 0 for off     * @param automaticResponseFileThreshold     */    public void setAutomaticResponseFileThreshold(int automaticResponseFileThreshold) {        this.automaticResponseFileThreshold = automaticResponseFileThreshold;    }    /**     *  set up the command sequence..     */    protected void prepareExecutor() {        // default directory to the project's base directory        if (owner == null) {            throw new RuntimeException("no owner");        }        if (owner.getProject() == null) {            throw new RuntimeException("Owner has no project");        }        File dir = owner.getProject().getBaseDir();        if (directory != null) {            dir = directory;        }        ExecuteStreamHandler handler = new LogStreamHandler(owner,                Project.MSG_INFO, Project.MSG_WARN);        executable = new Execute(handler, null);        executable.setAntRun(owner.getProject());        executable.setWorkingDirectory(dir);    }    /**     *  Run the command using the given Execute instance.     *     *@exception  BuildException  if something goes wrong and the     *      failOnError flag is true     */    public void runCommand()             throws BuildException {        prepareExecutor();        int err = -1;        // assume the worst        try {            if (traceCommandLine) {                owner.log("In directory " + executable.getWorkingDirectory());                owner.log(commandLine.describeCommand());            } else {                //in verbose mode we always log stuff                logVerbose("In directory " + executable.getWorkingDirectory());                logVerbose(commandLine.describeCommand());            }            setExecutableCommandLine();            err = executable.execute();            if (Execute.isFailure(err)) {                if (failOnError) {                    throw new BuildException(title + " returned: " + err, owner.getLocation());                } else {                    owner.log(title + "  Result: " + err, Project.MSG_ERR);                }            }        } catch (IOException e) {            throw new BuildException(title + " failed: " + e, e, owner.getLocation());        } finally {            if (temporaryCommandFile != null) {                temporaryCommandFile.delete();            }        }    }    /**     * set the executable command line     */    private void setExecutableCommandLine() {        String[] commands = commandLine.getCommandline();        //always trigger file mode if commands are big enough        if (automaticResponseFileThreshold > 0            && commands.length > automaticResponseFileThreshold) {            useResponseFile = true;        }        if (!useResponseFile || commands.length <= 1) {            //the simple action is to send the command line in as is            executable.setCommandline(commands);        } else {            //but for big operations, we save all the params to a temp file            //and set @tmpfile as the command -then we remember to delete the tempfile            //afterwards            FileOutputStream fos = null;            temporaryCommandFile = FILE_UTILS.createTempFile("cmd", ".txt", null);            owner.log("Using response file " + temporaryCommandFile, Project.MSG_VERBOSE);            try {                fos = new FileOutputStream(temporaryCommandFile);                PrintWriter out = new PrintWriter(new BufferedOutputStream(fos));                //start at 1 because element 0 is the executable name                for (int i = 1; i < commands.length; ++i) {                    if (argsOnCommandLine.contains(commands[i])) {                        continue;                    }                    if (commands[i].indexOf(" ") > -1) {                        String q = commands[i].indexOf("\"") > -1 ? "'" : "\"";                        out.print(q);                        out.print(commands[i]);                        out.println(q);                    } else {                        out.println(commands[i]);                    }                }                out.flush();                out.close();            } catch (IOException ex) {                throw new BuildException("saving command stream to " + temporaryCommandFile, ex);            }            String newCommandLine[] = new String[2 + argsOnCommandLine.size()];            newCommandLine[0] = commands[0];            if (argsOnCommandLine.size() > 0) {                System.arraycopy(argsOnCommandLine.toArray(), 0,                                 newCommandLine, 1, argsOnCommandLine.size());            }            newCommandLine[newCommandLine.length - 1] =                "@" + temporaryCommandFile.getAbsolutePath();            logVerbose(Commandline.describeCommand(newCommandLine));            executable.setCommandline(newCommandLine);        }    }    /**     * scan through one fileset for files to include     * @param scanner     * @param filesToBuild     * @param outputTimestamp timestamp to compare against     * @return #of files out of date     * @todo: should FAT granularity be included here?     */    public int scanOneFileset(DirectoryScanner scanner, Hashtable filesToBuild,                                        long outputTimestamp) {        int filesOutOfDate = 0;        String[] dependencies = scanner.getIncludedFiles();        File base = scanner.getBasedir();        //add to the list        for (int i = 0; i < dependencies.length; i++) {            File targetFile = new File(base, dependencies[i]);            if (filesToBuild.get(targetFile) == null) {                filesToBuild.put(targetFile, targetFile);                if (targetFile.lastModified() > outputTimestamp) {                    filesOutOfDate++;                    owner.log(targetFile.toString() + " is out of date",                              Project.MSG_VERBOSE);                } else {                    owner.log(targetFile.toString(),                              Project.MSG_VERBOSE);                }            }        }        return filesOutOfDate;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet;import org.apache.ant.dotnet.util.CollectionUtils;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Environment;import org.apache.tools.ant.types.RedirectorElement;import java.io.File;import java.util.ArrayList;import java.util.Iterator;/** * Task to run the NUnit Console test runner. * * @see http://www.nunit.org/ */public class NUnitTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * Test assemblies.     */    private ArrayList testAssemblies = new ArrayList();    /**     * The /config argument.     */    private File configFile;    /**     * The /output argument.     */    private File out;    /**     * The /err argument.     */    private File err;    /**     * The /xml argument.     */    private File xmlOut;    /**     * The /transform argument.     */    private File transform;    /**     * The /thread argument.     */    private boolean thread = false;    /**     * The /fixture argument.     */    private String fixture;    /**     * Categories to include.     */    private ArrayList includes = new ArrayList();    /**     * Categories to exclude.     */    private ArrayList excludes = new ArrayList();    /**     * The /noshadow argument.     */    private boolean noshadow = false;    /**     * The /labels argument.     */    private boolean labels = false;    /**     * Redirects everything that NUnit wants to send to the console.     */    private RedirectorElement redirectorElement;    /**     * Whether a failure should stop the build.     */    private boolean failOnError = false;    /**     * Name of property to set if a test fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Support for nested environment variables.     */    private Environment env = new Environment();    public NUnitTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * Sets the name of the config file.     */    public void setConfig(File c) {        configFile = c;    }    /**     * The /output argument.     */    public void setOut(File out) {        this.out = out;    }    /**     * The /err argument.     */    public void setError(File err) {        this.err = err;    }    /**     * The /xml argument.     */    public void setXmlOut(File out) {        this.xmlOut = out;    }    /**     * The /transform argument.     */    public void setTransform(File transform) {        this.transform = transform;    }    /**     * The /thread argument.     */    public void setThread(boolean thread) {        this.thread = thread;    }    /**     * The /fixture argument.     */    public void setFixture(String fixture) {        this.fixture = fixture;    }    /**     * The /noshadow argument.     */    public void setNoshadow(boolean noshadow) {        this.noshadow = noshadow;    }    /**     * The /labels argument.     */    public void setLabels(boolean labels) {        this.labels = labels;    }    /**     * Whether a failure should stop the build.     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Name of property to set if a test fails.     *     * @since 1.0 Beta 2     */    public void setErrorProperty(String name) {        errorProperty = name;    }    /**     * Adds a test assembly by name.     */    public void addTestAssembly(NamedElement a) {        testAssemblies.add(a);    }    /**     * Adds a category to the include list.     */    public void addInclude(NamedElement a) {        includes.add(a);    }    /**     * Adds a category to the exclude list.     */    public void addExclude(NamedElement a) {        excludes.add(a);    }    /**     * Add an environment variable to the launched process.     *     * @param var new environment variable     */    public void addEnv(Environment.Variable var) {        env.addVariable(var);    }    /**     * Add a <code>RedirectorElement</code> to this task.     *     * <p>This does not use the <code>out</code> and     * <code>error</code> attributes, it only captures NUnits output     * that has not been redirected by those attributes.</p>     */    public void addConfiguredRedirector(RedirectorElement redirectorElement) {        if (this.redirectorElement != null) {            throw new BuildException("cannot have > 1 nested <redirector>s");        } else {            this.redirectorElement = redirectorElement;        }    }    public void execute() {        if (testAssemblies.size() == 0) {            throw new BuildException("You must specify at least one test "                                     + "assembly.");        }                DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      "nunit-console.exe",                                                     env);        Iterator iter = testAssemblies.iterator();        while (iter.hasNext()) {            NamedElement a = (NamedElement) iter.next();            exec.createArg().setValue(a.getName());        }        if (configFile != null) {            exec.createArg().setValue("/config="                                       + configFile.getAbsolutePath());        }        exec.createArg().setValue("/nologo");        if (out != null) {            exec.createArg().setValue("/output=" + out.getAbsolutePath());        }        if (err != null) {            exec.createArg().setValue("/err=" + err.getAbsolutePath());        }        if (xmlOut != null) {            exec.createArg().setValue("/xml=" + xmlOut.getAbsolutePath());        }        if (transform != null) {            exec.createArg().setValue("/transform="                                       + transform.getAbsolutePath());        }        if (thread) {            exec.createArg().setValue("/thread");        }        if (noshadow) {            exec.createArg().setValue("/noshadow");        }        if (labels) {            exec.createArg().setValue("/labels");        }        if (fixture != null) {            exec.createArg().setValue("/fixture=" + fixture);        }                if (includes.size() > 0) {            StringBuffer sb = new StringBuffer("/include=");            sb.append(CollectionUtils.flattenToString(includes));            exec.createArg().setValue(sb.toString());        }        if (excludes.size() > 0) {            StringBuffer sb = new StringBuffer("/exclude=");            sb.append(CollectionUtils.flattenToString(excludes));            exec.createArg().setValue(sb.toString());        }        if (redirectorElement != null) {            exec.addConfiguredRedirector(redirectorElement);        }        exec.setFailonerror(failOnError);        exec.internalSetErrorProperty(errorProperty);        exec.execute();    }    public static class NamedElement {        private String name;        public String getName() {return name;}        public void setName(String s) {name = s;}        public String toString() {return getName();}    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.util.DOMElementWriter;import org.apache.tools.ant.util.FileUtils;import org.apache.tools.ant.util.XMLFragment;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Base class for NAntTask and MSBuildTask. */public abstract class AbstractBuildTask extends Task {    /**     * The buildfile to invoke the build tool for.     */    private File buildFile;    /**     * The targets to execute.     */    private List targets = new ArrayList();    /**     * Properties to set.     */    private List properties = new ArrayList(1);    /**     * Nested build file fragment.     */    private XMLFragment buildSnippet;    /**     * The vm attribute - if given.     */    private String vm;    /**     * Whether a failure should stop the build.     *     * @since 1.0 Beta 2     */    private boolean failOnError = true;    /**     * Name of property to set if a build fails.     *     * @since 1.0 Beta 2     */    private String errorProperty;    /**     * Empty constructor.     */    protected AbstractBuildTask() {    }    /**     * Sets the name of the build file.     */    public final void setBuildfile(File f) {        buildFile = f;    }    /**     * Adds a build file fragment.     */    public void addBuild(XMLFragment f) {        if (buildSnippet == null) {            buildSnippet = f;        } else {            throw new BuildException("You must not specify more than one "                                     + "build element");        }    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * A target.     */    public static class Target {        private String name;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public String toString() {            return getName();        }    }    /**     * A target to execute.     */    public final void addTarget(Target t) {        targets.add(t);    }    /**     * A property.     */    // XXX, could have reused Property or Environment.Variable     //      - not decided so far    public static class Property {        private String name;        private String value;        public void setName(String name) {            this.name = name;        }        public String getName() {            return name;        }        public void setValue(String value) {            this.value = value;        }        public String getValue() {            return value;        }        public String toString() {            return getName() + "=" + getValue();        }    }    /**     * A target to execute.     */    public final void addProperty(Property t) {        properties.add(t);    }    /**     * Whether a failure should stop the build.     *     * @since 1.0 Beta 2     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     * Name of property to set if a build fails.     *     * @since 1.0 Beta 2     */    public void setErrorProperty(String name) {        errorProperty = name;    }    /**     * Must return the executable.     *     * @return must not return null     */    protected abstract String getExecutable();    /**     * Must return buildfile argument(s).     *     * @param buildFile the absolute File for the buildfile or null if     * the user didn't specify a buildfile.     *     * @return must not return null     */    protected abstract String[] getBuildfileArguments(File buildFile);    /**     * Must return target argument(s).     *     * @return must not return null     */    protected abstract String[] getTargetArguments(List targets);    /**     * Must return property argument(s).     *     * @return must not return null     */    protected abstract String[] getPropertyArguments(List properties);    /**     * Turn the DoucmentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>Must throw a BuildException if the snippet can not be turned     * into a build file.</p>     */    protected abstract Element makeTree(DocumentFragment f);    /**     * Perform the build.     */    public void execute() {        if (buildFile != null && buildSnippet != null) {            throw new BuildException("You must not specify the build file"                                     + " attribute and a nested build at the"                                     + " same time");        }        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      getExecutable(), null);        String[] args = getPropertyArguments(properties);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        args = getTargetArguments(targets);        for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        File generatedFile = null;        if (buildSnippet != null) {            try {                generatedFile = getBuildFile();            } catch (IOException e) {                throw new BuildException(e);            }            args = getBuildfileArguments(generatedFile);        } else {            args = getBuildfileArguments(buildFile);        }                for (int i = 0; i < args.length; i++) {            exec.createArg().setValue(args[i]);        }        exec.setFailonerror(failOnError);        exec.internalSetErrorProperty(errorProperty);        try {            exec.execute();        } finally {            if (generatedFile != null) {                generatedFile.delete();            }        }    }    private File getBuildFile() throws IOException {        File f = null;        if (buildSnippet != null) {            Element e = makeTree(buildSnippet.getFragment());            f = FileUtils.getFileUtils().createTempFile("build", ".xml", null);            f.deleteOnExit();            FileOutputStream out = null;            try {                out = new FileOutputStream(f);                DOMElementWriter w =                    new DOMElementWriter(true,                                         DOMElementWriter.XmlNamespacePolicy                                         .ONLY_QUALIFY_ELEMENTS);                w.write(e, out);            } finally {                if (out != null) {                    out.close();                }            }        }        return f;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.List;import org.apache.ant.dotnet.util.CollectionUtils;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a MSBuild build process. */public class MSBuildTask extends AbstractBuildTask {    private static final String TARGET = "generated-by-ant";    private static final String ROOT = "Project";    private static final String MSBUILD_NS =	"http://schemas.microsoft.com/developer/msbuild/2003";    public MSBuildTask() {        super();    }    protected String getExecutable() {        return "MSBuild.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        if (targets.size() > 0) {            StringBuffer sb = new StringBuffer("/target:");            sb.append(CollectionUtils.flattenToString(targets, ";"));            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    protected String[] getPropertyArguments(List properties) {        if (properties.size() > 0) {            StringBuffer sb = new StringBuffer("/property:");            sb.append(CollectionUtils.flattenToString(properties, ";"));            return new String[]{sb.toString()};        } else {            return new String[0];        }    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <Project> child, return that.     * Otherwise if we have only <Task> children, wrap them into a     * <Target> which in turn gets wrapped into a <Project>.     * Otherwise, fail.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals(ROOT)) {            return (Element) nl.item(0);        } else {            Element p = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     ROOT);            p.setAttribute("DefaultTargets", TARGET);            Element t = f.getOwnerDocument().createElementNS(MSBUILD_NS,							     "Target");            t.setAttribute("Name", TARGET);            p.appendChild(t);            t.appendChild(f);            return p;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.build;import java.io.File;import java.util.Iterator;import java.util.ArrayList;import java.util.List;import org.w3c.dom.DocumentFragment;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * Runs a NAnt build process. */public class NAntTask extends AbstractBuildTask {    public NAntTask() {        super();    }    protected String getExecutable() {        return "NAnt.exe";    }    protected String[] getBuildfileArguments(File buildFile) {        if (buildFile != null) {            return new String[] {                "-buildfile:" + buildFile.getAbsolutePath()            };        } else {            return new String[0];        }    }    protected String[] getTargetArguments(List targets) {        ArrayList al = new ArrayList(targets.size());        Iterator iter = targets.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Target t = (AbstractBuildTask.Target) iter.next();            al.add(t.getName());        }        return (String[]) al.toArray(new String[al.size()]);    }    protected String[] getPropertyArguments(List properties) {        ArrayList al = new ArrayList(properties.size());        Iterator iter = properties.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                 (AbstractBuildTask.Property) iter.next();            al.add("-D:" + p.getName() + "=" + p.getValue());        }        return (String[]) al.toArray(new String[al.size()]);    }    /**     * Turn the DocumentFragment into a DOM tree suitable as a build     * file when serialized.     *     * <p>If we have exactly one <project> child, return that.     * Otherwise assume that this is a valid build file snippet that     * just needs an empty project wrapped around it.</p>     */    protected Element makeTree(DocumentFragment f) {        NodeList nl = f.getChildNodes();        if (nl.getLength() == 1             && nl.item(0).getNodeType() == Node.ELEMENT_NODE            && nl.item(0).getNodeName().equals("project")) {            return (Element) nl.item(0);        } else {            Element e = f.getOwnerDocument().createElement("project");            e.appendChild(f);            return e;        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */// ====================================================================// place in the optional ant tasks package// but in its own dotnet group// ====================================================================package org.apache.ant.dotnet.compile;// ====================================================================// imports// ====================================================================import org.apache.ant.dotnet.NetCommand;import java.io.File;// ====================================================================/** *  Compiles C# source into executables or modules. * * csc.exe on Windows or gmcs on other platforms must be on the execute * path, unless another executable or the full path to that executable * is specified in the <tt>executable</tt> parameter * <p> * All parameters are optional: &lt;csc/&gt; should suffice to produce a debug * build of all *.cs files. However, naming an <tt>destFile</tt>stops the * csc compiler from choosing an output name from random, and * allows the dependency checker to determine if the file is out of date. * <p> *  The task is a directory based task, so attributes like <b>includes="*.cs" *  </b> and <b>excludes="broken.cs"</b> can be used to control the files pulled *  in. By default, all *.cs files from the project folder down are included in *  the command. When this happens the output file -if not specified- is taken *  as the first file in the list, which may be somewhat hard to control. *  Specifying the output file with <tt>destFile</tt> seems prudent. <p> * * <p> * For more complex source trees, nested <tt>src</tt> elemements can be * supplied. When such an element is present, the implicit fileset is ignored. * This makes sense, when you think about it :) * * <p>For historical reasons the pattern * <code>**</code><code>/*.cs</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * <p> * References to external files can be made through the references attribute, * or (since Ant1.6), via nested &lt;reference&gt; filesets. With the latter, * the timestamps of the references are also used in the dependency * checking algorithm. * <p> * * Example * * <pre>&lt;csc *       optimize=&quot;true&quot; *       debug=&quot;false&quot; *       docFile=&quot;documentation.xml&quot; *       warnLevel=&quot;4&quot; *       unsafe=&quot;false&quot; *       targetType=&quot;exe&quot; *       incremental=&quot;false&quot; *       mainClass = &quot;MainApp&quot; *       destFile=&quot;NetApp.exe&quot; *       &gt; *           &lt;src dir="src" includes="*.cs" /&gt; *       &lt;reference file="${testCSC.dll}" /&gt; *       &lt;define name="RELEASE" /&gt; *       &lt;define name="DEBUG" if="debug.property"/&gt; *       &lt;define name="def3" unless="def3.property"/&gt; *    &lt;/csc&gt; * </pre> * * * @ant.task    name="csc" category="dotnet" * @since Ant 1.3 */public class CSharp extends DotnetCompile {    private static final String MONO_CS_COMPILER = "gmcs";    /**     *  defines list: RELEASE;WIN32;NO_SANITY_CHECKS;;SOMETHING_ELSE'     */    String definitions;    /**     *  output XML documentation flag     */    private File docFile;    /**     *  file alignment; 0 means let the compiler decide     */    private int fileAlign = 0;    /**     *  use full paths to things     */    private boolean fullpaths = false;    /**     *  incremental build flag     */    private boolean incremental;    /**     *  enable unsafe code flag. Clearly set to false by default     */    protected boolean unsafe;    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     */    private boolean noconfig = false;    /**     *  constructor inits everything and set up the search pattern     */    public CSharp() {        clear();    }    /**     * full cleanup     */    public void clear() {        super.clear();        docFile = null;        fileAlign = 0;        fullpaths = true;        incremental = false;        unsafe = false;        noconfig = false;        definitions = null;        setExecutable(isWindows ? "csc" : MONO_CS_COMPILER);    }    /**     *  file for generated XML documentation     *     *@param  f  output file     */    public void setDocFile(File f) {        docFile = f;    }    /**     *  get the argument or null for no argument needed     *     *@return    The DocFile Parameter to CSC     */    protected String getDocFileParameter() {        if (docFile != null) {            return "/doc:" + docFile.toString();        } else {            return null;        }    }    /**     * Set the file alignment.     * Valid values are 0,512, 1024, 2048, 4096, 8192,     * and 16384, 0 means 'leave to the compiler'     */    public void setFileAlign(int fileAlign) {        this.fileAlign = fileAlign;    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getFileAlignParameter() {        if (fileAlign != 0 && !MONO_CS_COMPILER.equals(getExecutable())) {            return "/filealign:" + fileAlign;        } else {            return null;        }    }    /**     * If true, print the full path of files on errors.     *     *@param  enabled  The new fullPaths value     */    public void setFullPaths(boolean enabled) {        fullpaths = enabled;    }    /**     *  Gets the fullPathsParameter attribute of the CSharp object     *     *@return    The fullPathsParameter value or null if unset     */    protected String getFullPathsParameter() {        return fullpaths ? "/fullpaths" : null;    }    /**     *  set the incremental compilation flag on or off.     *     *@param  incremental  on/off flag     */    public void setIncremental(boolean incremental) {        this.incremental = incremental;    }    /**     *  query the incrementalflag     *     *@return    true if incremental compilation is turned on     */    public boolean getIncremental() {        return incremental;    }    /**     *  get the incremental build argument     *     *@return    The Incremental Parameter to CSC     */    protected String getIncrementalParameter() {        return "/incremental" + (incremental ? "+" : "-");    }    /**     *  The output file. This is identical to the destFile attribute.     *     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        setDestFile(params);    }    /**     * If true, enables the unsafe keyword.     *     *@param  unsafe  The new Unsafe value     */    public void setUnsafe(boolean unsafe) {        this.unsafe = unsafe;    }    /**     *  query the Unsafe attribute     *     *@return    The Unsafe value     */    public boolean getUnsafe() {        return this.unsafe;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Unsafe Parameter to CSC     */    protected String getUnsafeParameter() {        return unsafe ? "/unsafe" : null;    }    /**     * A flag that tells the compiler not to read in the compiler     * settings files 'csc.rsp' in its bin directory and then the local directory     *     *@param  enabled  The new noConfig value     */    public void setNoConfig(boolean enabled) {        noconfig = enabled;    }    /**     *  Gets the noConfigParameter attribute of the CSharp object     *     *@return    The noConfigParameter value     */    protected String getNoConfigParameter() {        return noconfig ? "/noconfig" : null;    }    /**     *  Semicolon separated list of defined constants.     *     *@param  params  The new definitions value     */    public void setDefinitions(String params) {        definitions = params;    }    /**     * override the superclasses version of this method (which we call)     * with a check for a definitions attribute, the contents of which     * are appended to the list.     *@return    The Definitions Parameter to CSC     */    protected String getDefinitionsParameter() {        String predecessors = super.getDefinitionsParameter();        if (notEmpty(definitions)) {            if (predecessors == null) {                predecessors = "/define:";            }            return  predecessors + definitions;        } else {            return predecessors;        }    }    /**     * add Commands unique to C#.     * @param command ongoing command     */    public void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getIncludeDefaultReferencesParameter());        command.addArgument(getWarnLevelParameter());        command.addArgument(getDocFileParameter());        command.addArgument(getFullPathsParameter());        command.addArgument(getFileAlignParameter());        if (getIncremental()) {            command.addArgument(getIncrementalParameter());        }        command.addArgument(getNoConfigParameter(), false);        command.addArgument(getUnsafeParameter());    }    // end execute    /**     * Returns the delimiter which C# uses to separate references, i.e., a semi colon.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * This method indicates the filename extension for C# files.     * @return the file extension for C#, i.e., "cs" (without the dot).     */    public String getFileExtension() {        return "cs";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.taskdefs.MatchingTask;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.Project;import org.apache.tools.ant.DirectoryScanner;import java.io.File;import java.util.Vector;import java.util.Hashtable;import java.util.Enumeration;/** * refactoring of some stuff so that different things (like ILASM) * can use shared code. */public class DotnetBaseMatchingTask extends MatchingTask {    /**     *  output file. If not supplied this is derived from the source file     */    protected File outputFile;    /**     * filesets of file to compile     */    protected Vector filesets = new Vector();    /**     *  source directory upon which the search pattern is applied     */    protected File srcDir;    /**     * Are we running on Windows?     *     * @since Ant 1.6.3     */    protected static final boolean isWindows = Os.isFamily("windows");    /**    * Overridden because we need to be able to set the srcDir.    */    public File getSrcDir() {        return this.srcDir;    }    /**     *  Set the source directory of the files to be compiled.     *     *@param  srcDirName  The new SrcDir value     */    public void setSrcDir(File srcDirName) {        this.srcDir = srcDirName;    }    /**     *  Set the name of exe/library to create.     *     *@param  file  The new outputFile value     */    public void setDestFile(File file) {        outputFile = file;    }    /**     * add a new source directory to the compile     * @param src     */    public void addSrc(FileSet src) {        filesets.add(src);    }    /**     * get the destination file     * @return the dest file or null for not assigned     */    public File getDestFile() {        return outputFile;    }    /**     * create the list of files     * @param filesToBuild vector to add files to     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int buildFileList(NetCommand command, Hashtable filesToBuild, long outputTimestamp) {        int filesOutOfDate = 0;        boolean scanImplicitFileset            = getSrcDir() != null || filesets.size() == 0;        if (scanImplicitFileset) {            //scan for an implicit fileset if there was a srcdir set            //or there was no srcDir set but there was no contained classes            if (getSrcDir() == null) {                //if there is no src dir here, set it                setSrcDir(getProject().resolveFile("."));            }            log("working from source directory " + getSrcDir(),                    Project.MSG_VERBOSE);            //get dependencies list.            DirectoryScanner scanner = getDirectoryScanner(getSrcDir());            filesOutOfDate = command.scanOneFileset(scanner,                    filesToBuild, outputTimestamp);        }        //get any included source directories        for (int i = 0; i < filesets.size(); i++) {            FileSet fs = (FileSet) filesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        return filesOutOfDate;    }    /**     * add the list of files to a command     * @param filesToBuild vector of files     * @param command the command to append to     */    protected void addFilesToCommand(Hashtable filesToBuild, NetCommand command) {        int count = filesToBuild.size();        log("compiling " + count + " file" + ((count == 1) ? "" : "s"),                Project.MSG_VERBOSE);        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            command.addArgument(file.toString());        }    }    /**     * determine the timestamp of the output file     * @return a timestamp or 0 for no output file known/exists     */    protected long getOutputFileTimestamp() {        long outputTimestamp;        if (getDestFile() != null && getDestFile().exists()) {            outputTimestamp = getDestFile().lastModified();        } else {            outputTimestamp = 0;        }        return outputTimestamp;    }    /**     * finish off the command by adding all dependent files, execute     * @param command     */    protected void addFilesAndExecute(NetCommand command, boolean ignoreTimestamps) {        long outputTimestamp = getOutputFileTimestamp();        Hashtable filesToBuild = new Hashtable();        int filesOutOfDate = buildFileList(command, filesToBuild, outputTimestamp);        //now run the command of exe + settings + files        if (filesOutOfDate > 0) {            //add the files to the command            addFilesToCommand(filesToBuild, command);            command.runCommand();        } else {            log("output file is up to date", Project.MSG_VERBOSE);        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap:Cream+Live+2001+CD+2 */// place in the optional ant tasks package// but in its own dotnet grouppackage org.apache.ant.dotnet.compile;// importsimport java.io.File;import java.util.Vector;import java.util.Enumeration;import java.util.Hashtable;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.Path;import org.apache.tools.ant.types.FileSet;import org.apache.tools.ant.types.EnumeratedAttribute;/** *  Abstract superclass for dotnet compiler tasks. * *  History *  <table> *    <tr> *      <td> *        0.1 *      </td> *      <td> *        First creation *      </td> *      <td> *        Most of the code here was copied verbatim from v0.3 of *        Steve Loughran's CSharp optional task. Abstracted functionality *        to allow subclassing of other dotnet compiler types. *      </td> *    </tr> * *  </table> * * * @version     0.1 */public abstract class DotnetCompile         extends DotnetBaseMatchingTask {    /**     *  list of reference classes. (pretty much a classpath equivalent)     */    private String references;    /**     *  flag to enable automatic reference inclusion     */    private boolean includeDefaultReferences = true;    /**     *  icon for incorporation into apps     */    private File win32icon;    /**     *  icon for incorporation into apps     */    private File win32res;    /**     *  flag to control action on execution trouble     */    private boolean failOnError;    /**     *  using the path approach didn't work as it could not handle the implicit     *  execution path. Perhaps that could be extracted from the runtime and     *  then the path approach would be viable     */    private Path referenceFiles;    /**     *  optimise flag     */    private boolean optimize;    /**     * a list of definitions to support;     */    protected Vector definitionList = new Vector();    /**     * our resources     */    protected Vector resources = new Vector();    /**     *  executable     */    protected String executable;    protected static final String REFERENCE_OPTION = "/reference:";    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  warning level: 0-4, with 4 being most verbose     */    private int warnLevel;    /**     *  main class (or null for automatic choice)     */    protected String mainClass;    /**     *  any extra command options?     */    protected String extraOptions;    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  utf out flag     */    protected boolean utf8output = false;    /**     *  list of extra modules to refer to     */    protected String additionalModules;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * flag to set to to use @file based command cache     */    private boolean useResponseFile = false;    private static final int AUTOMATIC_RESPONSE_FILE_THRESHOLD = 64;    /**     *  constructor inits everything and set up the search pattern     */    public DotnetCompile() {        clear();        setIncludes(getFilePattern());    }    /**     *  reset all contents.     */    public void clear() {        targetType = null;        win32icon = null;        srcDir = null;        mainClass = null;        warnLevel = 3;        optimize = false;        debug = true;        references = null;        failOnError = true;        additionalModules = null;        includeDefaultReferences = true;        extraOptions = null;    }    /**     * Semicolon separated list of DLLs to refer to.     *     *@param  s  The new References value     */    public void setReferences(String s) {        references = s;    }    /**     *  get the reference string or null for no argument needed     *     *@return    The References Parameter to CSC     */    protected String getReferencesParameter() {        //bail on no references        if (notEmpty(references)) {            if (isWindows) {                return '\"' + REFERENCE_OPTION + references + '\"';            } else {                return REFERENCE_OPTION + references;            }        } else {            return null;        }    }    /**     * Path of references to include.     * Wildcards should work.     *     *@param  path  another path to append     */    public void setReferenceFiles(Path path) {        //demand create pathlist        if (referenceFiles == null) {            referenceFiles = new Path(this.getProject());        }        referenceFiles.append(path);    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     *  turn the path list into a list of files and a /references argument     *     *@return    null or a string of references.     */    protected String getReferenceFilesParameter() {        //bail on no references        if (references == null) {            return null;        }        //iterate through the ref list & generate an entry for each        //or just rely on the fact that the toString operator does this, but        //noting that the separator is ';' on windows, ':' on unix        //bail on no references listed        if (references.length() == 0) {            return null;        }        StringBuffer s = new StringBuffer(REFERENCE_OPTION);        if (isWindows) {            s.append('\"');        }        s.append(references);        if (isWindows) {            s.append('\"');        }        return s.toString();    }    /**     * If true, automatically includes the common assemblies     * in dotnet, and tells the compiler to link in mscore.dll.     *     *  set the automatic reference inclusion flag on or off this flag controls     *  the /nostdlib option in CSC     *     *@param  f  on/off flag     */    public void setIncludeDefaultReferences(boolean f) {        includeDefaultReferences = f;    }    /**     *  query automatic reference inclusion flag     *     *@return    true if flag is turned on     */    public boolean getIncludeDefaultReferences() {        return includeDefaultReferences;    }    /**     *  get the include default references flag or null for no argument needed     *     *@return    The Parameter to CSC     */    protected String getIncludeDefaultReferencesParameter() {        return "/nostdlib" + (includeDefaultReferences ? "-" : "+");    }    /**     * If true, enables optimization flag.     *     *@param  f  on/off flag     */    public void setOptimize(boolean f) {        optimize = f;    }    /**     *  query the optimise flag     *     *@return    true if optimise is turned on     */    public boolean getOptimize() {        return optimize;    }    /**     *  get the optimise flag or null for no argument needed     *     *@return    The Optimize Parameter to CSC     */    protected String getOptimizeParameter() {        return "/optimize" + (optimize ? "+" : "-");    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the debug switch argument     *     *@return    The Debug Parameter to CSC     */    protected String getDebugParameter() {        return "/debug" + (debug ? "+" : "-");    }    /**     * Level of warning currently between 1 and 4     * with 4 being the strictest.     *     *@param  warnLevel  warn level -see .net docs for valid range (probably     *      0-4)     */    public void setWarnLevel(int warnLevel) {        this.warnLevel = warnLevel;    }    /**     *  query warn level     *     *@return    current value     */    public int getWarnLevel() {        return warnLevel;    }    /**     *  get the warn level switch     *     *@return    The WarnLevel Parameter to CSC     */    protected String getWarnLevelParameter() {        return "/warn:" + warnLevel;    }    /**     *  Sets the name of main class for executables.     *     *@param  mainClass  The new MainClass value     */    public void setMainClass(String mainClass) {        this.mainClass = mainClass;    }    /**     *  Gets the MainClass attribute     *     *@return    The MainClass value     */    public String getMainClass() {        return this.mainClass;    }    /**     *  get the /main argument or null for no argument needed     *     *@return    The MainClass Parameter to CSC     */    protected String getMainClassParameter() {        if (mainClass != null && mainClass.length() != 0) {            return "/main:" + mainClass;        } else {            return null;        }    }    /**     * Any extra options which are not explicitly supported     * by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     *  get any extra options or null for no argument needed, split     *  them if they represent multiple options.     *     * @return    The ExtraOptions Parameter to CSC     */    protected String[] getExtraOptionsParameters() {        String extra = getExtraOptionsParameter();        return extra == null ? null : Commandline.translateCommandline(extra);    }    /**     * Set the destination directory of files to be compiled.     *     *@param  dirName  The new DestDir value     */    public void setDestDir(File dirName) {        log("DestDir currently unused", Project.MSG_WARN);    }    /**     * set the target type to one of exe|library|module|winexe     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Set the type of target.     *     *@param  ttype          The new TargetType value     *@exception  BuildException  if target is not one of     *      exe|library|module|winexe     */    public void setTargetType(String ttype)             throws BuildException {        ttype = ttype.toLowerCase();        if (ttype.equals("exe") || ttype.equals("library")            || ttype.equals("module") || ttype.equals("winexe")) {            targetType = ttype;        } else {            throw new BuildException("targetType " + ttype                    + " is not one of 'exe', 'module', 'winexe' or 'library'");        }    }    /**     *  Gets the TargetType attribute     *     *@return    The TargetType value     */    public String getTargetType() {        return targetType;    }    /**     *  get the argument or null for no argument needed     *     *@return    The TargetType Parameter to CSC     */    protected String getTargetTypeParameter() {        if (notEmpty(targetType)) {            return "/target:" + targetType;        } else {            return null;        }    }    /**     *  Set the filename of icon to include.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Icon(File fileName) {        win32icon = fileName;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Icon Parameter to CSC     */    protected String getWin32IconParameter() {        if (win32icon != null) {            return "/win32icon:" + win32icon.toString();        } else {            return null;        }    }    /**     * Sets the filename of a win32 resource (.RES) file to include.     * This is not a .NET resource, but what Windows is used to.     *     *@param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setWin32Res(File fileName) {        win32res = fileName;    }    /**     * Gets the file of the win32 .res file to include.     * @return path to the file.     */    public File getWin32Res() {        return win32res;    }    /**     *  get the argument or null for no argument needed     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (win32res != null) {            return "/win32res:" + win32res.toString();        } else {            return null;        }    }    /**     * If true, require all compiler output to be in UTF8 format.     *     *@param  enabled  The new utf8Output value     */    public void setUtf8Output(boolean enabled) {        utf8output = enabled;    }    /**     *  Gets the utf8OutpuParameter attribute of the CSharp object     *     *@return    The utf8OutpuParameter value     */    protected String getUtf8OutputParameter() {        return utf8output ? "/utf8output" : null;    }    /**     * add a define to the list of definitions     * @param define     */    public void addDefine(DotnetDefine define) {        definitionList.addElement(define);    }    /**     * get a list of definitions or null     * @return a string beginning /D: or null for no definitions     */    protected String getDefinitionsParameter() throws BuildException {        StringBuffer defines = new StringBuffer();        Enumeration defEnum = definitionList.elements();        boolean firstDefinition = true;        while (defEnum.hasMoreElements()) {            //loop through all definitions            DotnetDefine define = (DotnetDefine) defEnum.nextElement();            if (define.isSet(this)) {                //add those that are set, and a delimiter                if (!firstDefinition) {                    defines.append(getDefinitionsDelimiter());                }                defines.append(define.getValue(this));                firstDefinition = false;            }        }        if (defines.length() == 0) {            return null;        } else {            return "/d:" + defines;        }    }    /**     * Semicolon separated list of modules to refer to.     *     *@param  params  The new additionalModules value     */    public void setAdditionalModules(String params) {        additionalModules = params;    }    /**     *  get the argument or null for no argument needed     *     *@return    The AdditionalModules Parameter to CSC     */    protected String getAdditionalModulesParameter() {        if (notEmpty(additionalModules)) {            return "/addmodule:" + additionalModules;        } else {            return null;        }    }    /**     *  get the argument or null for no argument needed     *     *@return    The OutputFile Parameter to CSC     */    protected String getDestFileParameter() {        if (outputFile != null) {            return "/out:" + outputFile.toString();        } else {            return null;        }    }    /**     * If true, fail on compilation errors.     *     *@param  b  The new FailOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The FailFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     * link or embed a resource     * @param resource     */    public void addResource(DotnetResource resource) {        resources.add(resource);    }    /**     * This method gets the name of the executable.     * @return the name of the executable     */    protected String getExecutable() {        return executable;    }    /**     * set the name of the program, overriding the defaults.     * Can be used to set the full path to a program, or to switch     * to an alternate implementation of the command, such as the Mono or Rotor     * versions -provided they use the same command line arguments as the     * .NET framework edition     * @param executable     */    public void setExecutable(String executable) {        this.executable = executable;    }    /**     *  test for a string containing something useful     *     *@param  s  string in     *@return    true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (outputFile != null && outputFile.isDirectory()) {            throw new BuildException("destFile cannot be a directory");        }        if (getExecutable() == null) {            throw new BuildException("There is no executable defined for this task");        }    }    /**     * Get the pattern for files to compile.     * @return The compilation file pattern.     */    public String getFilePattern() {        return "**/*." + getFileExtension();    }    /**     * getter for flag     * @return The flag indicating whether the compilation is using a response file.     */    public boolean isUseResponseFile() {        return useResponseFile;    }    /**     * Flag to turn on response file use; default=false.     * When set the command params are saved to a file and     * this is passed in with @file. The task automatically switches     * to this mode with big commands; this option is here for     * testing and emergencies     * @param useResponseFile     */    public void setUseResponseFile(boolean useResponseFile) {        this.useResponseFile = useResponseFile;    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        validate();        NetCommand command = createNetCommand();        //set up response file options        command.setAutomaticResponseFileThreshold(AUTOMATIC_RESPONSE_FILE_THRESHOLD);        command.setUseResponseFile(useResponseFile);        //fill in args        fillInSharedParameters(command);        addResources(command);        addCompilerSpecificOptions(command);        int referencesOutOfDate            = addReferenceFilesets(command, getOutputFileTimestamp());        //if the refs are out of date, force a build.        boolean forceBuild = referencesOutOfDate > 0;        addFilesAndExecute(command, forceBuild);    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public abstract String getReferenceDelimiter();    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public abstract String getFileExtension();    /**     * fill in the common information     * @param command     */    protected void fillInSharedParameters(NetCommand command) {        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument("/nologo");        command.addArgument(getAdditionalModulesParameter());        command.addArgument(getDebugParameter());        command.addArgument(getDefinitionsParameter());        command.addArguments(getExtraOptionsParameters());        command.addArgument(getMainClassParameter());        command.addArgument(getOptimizeParameter());        command.addArgument(getDestFileParameter());        command.addArgument(getReferencesParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getUtf8OutputParameter());        command.addArgument(getWin32IconParameter());        command.addArgument(getWin32ResParameter());    }    /**     * for every resource declared, we get the (language specific)     * resource setting     */    protected void addResources(NetCommand command) {        Enumeration e = resources.elements();        while (e.hasMoreElements()) {            DotnetResource resource = (DotnetResource) e.nextElement();            createResourceParameter(command, resource);        }    }    /* XXX Javadoc makes little sense, rewrite     * from a resource, get the     * @param resource     * @return a string containing the resource param, or a null string     * to conditionally exclude a resource.     */    protected abstract void createResourceParameter(NetCommand command, DotnetResource resource);    /**     * run through the list of reference files and add them to the command     * @param outputTimestamp timestamp to compare against     * @return number of files out of date     */    protected int addReferenceFilesets(NetCommand command, long outputTimestamp) {        int filesOutOfDate = 0;        Hashtable filesToBuild = new Hashtable();        for (int i = 0; i < referenceFilesets.size(); i++) {            FileSet fs = (FileSet) referenceFilesets.elementAt(i);            filesOutOfDate += command.scanOneFileset(                    fs.getDirectoryScanner(getProject()),                    filesToBuild,                    outputTimestamp);        }        //bail out early if there were no files        if (filesToBuild.size() == 0) {            return 0;        }        //now scan the hashtable and add the files        Enumeration files = filesToBuild.elements();        while (files.hasMoreElements()) {            File file = (File) files.nextElement();            if (isFileManagedBinary(file)) {                if (isWindows) command.addArgument('"'+REFERENCE_OPTION+file.toString()+'"');                else command.addArgument(REFERENCE_OPTION+file.toString());            } else {                log("ignoring " + file + " as it is not a managed executable",                        Project.MSG_VERBOSE);            }        }        return filesOutOfDate;    }    /**     * create our helper command     * @return a command prefilled with the exe name and task name     */    protected NetCommand createNetCommand() {        NetCommand command = new NetCommand(this, getTaskName(), getExecutable());        return command;    }    /**     * add any compiler specifics     * @param command     */    protected abstract void addCompilerSpecificOptions(NetCommand command);    /**     * override point for delimiting definitions.     * @return The definitions limiter, i.e., ";"     */    public String getDefinitionsDelimiter() {        return ";";    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[] {                "exe",                "library",                "module",                "winexe"            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Task;import org.apache.tools.ant.Project;/** * definitions can be conditional. What .NET conditions can not be * is in any state other than defined and undefined; you cannot give * a definition a value. */public class DotnetDefine {    private String name;    private String ifCond;    private String unlessCond;    /**     * the name of a property which must be defined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setIf(String condition) {        this.ifCond = condition;    }    /**     * the name of a property which must be undefined for     * the definition to be set. Optional.     * @param condition the name of the property     */    public void setUnless(String condition) {        this.unlessCond = condition;    }    public String getName() {        return name;    }    /**     * the name of the definition. Required.     * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * This method gets the value of this definition. Will be null if a condition     * was declared and not met     * @param owner owning task     * @return The value of the definition.     * @throws BuildException     */    public String getValue(Task owner) throws BuildException {        if (name == null) {            throw new BuildException("No name provided for the define element",                owner.getLocation());        }        if (!isSet(owner)) {            return null;        }        return name;    }    /**     * logic taken from patternset     * @param owner     * @return true if the condition is valid     */    public boolean isSet(Task owner) {        Project p = owner.getProject();        if (ifCond != null && p.getProperty(ifCond) == null) {            return false;        } else if (unlessCond != null && p.getProperty(unlessCond) != null) {            return false;        }        return true;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import java.io.File;import java.util.ArrayList;import org.apache.tools.ant.types.FileSet;import java.util.Iterator;import org.apache.tools.ant.*;/** * Used by {@link DotnetCompile} to name resources. * Could be upgraded to a datatype in the distant future. * A resource maps to /res:file,name */public class DotnetResource {    /**     * name of resource     */    private File file;    /**     * embed (default) or link the resource     */    private boolean embed = true;    /**     * this is used in VBC and JSC     */    private Boolean isPublic = null;    /**     * name of the object     */    private String name = null;    /**     * A list of filesets with resources.     */    private ArrayList fileSets = new ArrayList();    /**     * a namespace to be used with <filesets>     */    private String namespace = null;    public boolean isEmbed() {        return embed;    }    /**     * embed the resource in the assembly (default, true) or just link to it.     *      * @param embed     */    public void setEmbed(boolean embed) {        this.embed = embed;    }    public File getFile() {        return file;    }    /**     * name the resource     *      * @param file     */    public void setFile(File file) {        this.file = file;    }    public Boolean getPublic() {        return isPublic;    }    /**     * VB and J# only: is a resource public or not?     *      * @param aPublic     */    public void setPublic(Boolean aPublic) {        isPublic = aPublic;    }    public String getName() {        return name;    }    /**     * should the resource have a name?     *      * @param name     */    public void setName(String name) {        this.name = name;    }    /**     * Filesets root namespace. The value always ends with '.' .     *      * @return String namespace name     */    public String getNamespace() {        return namespace;    }    /**     * Sets filesets root namespace.     *      * @param namespace     *            String root namespace     */    public void setNamespace(String namespace) {        if (namespace == null) {            this.namespace = null;        } else {            this.namespace = (namespace.length() == 0 || namespace.endsWith(".") ? namespace                    : namespace + '.');        }    }    private void checkParameters() {        if (hasFilesets()) {            if (getName() != null)                throw new BuildException(                        "Cannot use <resource name=\"...\"> attribute with filesets");            if (getFile() != null)                throw new BuildException(                        "Cannot use <resource file=\"...\"> attribute with filesets");        } else {            if (getNamespace() != null)                throw new BuildException(                        "Cannot use <resource namespace=\"...\"> attribute without filesets");        }    }    /**     * build the C# style parameter (which has no public/private option)     */    public void getParameters(Project p, NetCommand command, boolean csharpStyle) {        checkParameters();        if (hasFilesets()) {            for (Iterator listIter = fileSets.iterator(); listIter.hasNext();) {                FileSet fs = (FileSet) listIter.next();                String baseDirectory = fs.getDir(p).toString();                String namespace = getNamespace(); // ends with '.' or null                DirectoryScanner ds = fs.getDirectoryScanner(p);                String[] files = ds.getIncludedFiles();                for (int i = 0; i < files.length; i++) {                    String file = files[i];                    command.addArgument(getParameter(baseDirectory + File.separatorChar + file,                            (namespace == null ? null : namespace                                    + file.replace(File.separatorChar, '.')), csharpStyle));                }            }        } else {            command.addArgument(getParameter(getFile().toString(), getName(), csharpStyle));        }    }    private String getParameter(String fileName, String name, boolean csharpStyle) {        StringBuffer buffer = new StringBuffer();        buffer.append(isEmbed() ? "/resource" : "/linkresource");        buffer.append(':');        buffer.append(fileName);        if (name != null) {            buffer.append(',');            buffer.append(name);            if (csharpStyle) {                if (getPublic() != null) {                    throw new BuildException("This compiler does not support the "                            + "public/private option.");                } else {                    if (getPublic() != null) {                        buffer.append(',');                        buffer.append(getPublic().booleanValue() ? "public" : "private");                    }                }            } else if (getPublic() != null) {                throw new BuildException("You cannot have a public or private "                        + "option without naming the resource");            }        }        return buffer.toString();    }    /**     * Adds a resource file set.     *      * @param fileset     *            FileSet     */    public void addFileset(FileSet fileset) {        fileSets.add(fileset);    }    /**     * Checks that <resource> node has embedded <filesets>     *      * @return boolean     */    public boolean hasFilesets() {        return fileSets.size() > 0;    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * This task compiles F# source into executables or modules. * The task requires fsc.exe on the execute path, unless it or an equivalent * program is specified in the <tt>executable</tt> parameter * * <p> * All parameters are optional: &lt;fsc/&gt; should suffice to produce a debug * build of all *.fs files. * * <p> * The task is a directory based task, so attributes like * <tt>includes=&quot;**\/*.fs&quot;</tt> and * <tt>excludes=&quot;broken.fs&quot;</tt> can be used to control * the files pulled in. By default, * all *.fs files from the project folder down are included in the command. * When this happens the destFile -if not specified- * is taken as the first file in the list, which may be somewhat hard to control.   Specifying the output file with <tt>destfile</tt> is prudent. </p> <p> * Also, dependency checking only works if destfile is set. * * <p>For historical reasons the pattern * <code>**</code><code>/*.fs</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * As with &lt;csc&gt; nested <tt>src</tt> filesets of source, * reference filesets, definitions and resources can be provided. * * <p> * Example * </p> * <pre>&lt;fsc *   optimize=&quot;true&quot; *   debug=&quot;false&quot; *   warnLevel=&quot;4&quot; *   targetType=&quot;exe&quot; *   definitions=&quot;RELEASE&quot; *   excludes=&quot;src/unicode_class.fs&quot; *   destFile=&quot;NetApp.exe&quot; *   tailcalls=&quot;true&quot; *   references="System.Xml,System.Web.Xml" *   &gt; *          &lt;reference file="${testCSC.dll}" /&gt; *          &lt;define name="RELEASE" /&gt; *          &lt;define name="DEBUG" if="debug.property"/&gt; *          &lt;define name="def3" unless="def2.property"/&gt; *   &lt;/fsc&gt; </pre> * @ant.task    name="fsc" category="dotnet" */public class FSharp extends DotnetCompile {    /**     * Compiler option to enable tailcalls.     */    private boolean tailcalls = true;    /**     * Compiler option to enable cross-module optimizations.     */    private boolean crossoptimize = false;    /**     * Compiler option to statically link the F# library and all     * referenced DLLs into the assembly.     */    private boolean standalone = false;    public FSharp() {        clear();    }    /**     *  reset all contents.     */    public void clear() {        super.clear();        tailcalls = true;        crossoptimize = false;        standalone = false;        setExecutable("fsc");    }    /**     * Whether to enable tailcalls.     */    public void setTailcalls(boolean b) {        tailcalls = b;    }    /**     * Whether to enable tailcalls.     * @return    true if flag is turned on     */    public boolean getTailcalls() {        return tailcalls;    }    /**     * Form the option string for tailcalls.     * @return The parameter string.     */    public String getTailcallsParameter() {        return "/tailcalls" + (tailcalls ? "+" : "-");    }    /**     * Whether to enable cross-module optimizations.     */    public void setCrossoptimize(boolean b) {        crossoptimize = b;    }    /**     * Whether to enable cross-module optimizations.     * @return    true if flag is turned on     */    public boolean getCrossoptimize() {        return crossoptimize;    }    /**     * Form the option string for cross-module optimizations.     * @return The parameter string.     */    public String getCrossoptimizeParameter() {        return "/crossoptimize" + (crossoptimize ? "+" : "-");    }    /**     * Whether to create a standalone assembly.     */    public void setStandalone(boolean b) {        standalone = b;    }    /**     * Whether to create a standalone assembly.     * @return    true if flag is turned on     */    public boolean getStandalone() {        return standalone;    }    /**     * Form the option string for standalone.     * @return The parameter string.     */    public String getStandaloneParameter() {        return standalone ? "/standalone" : null;    }    /**     * implement FSC commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getTailcallsParameter());        command.addArgument(getCrossoptimizeParameter());        String s = getStandaloneParameter();        if (s != null) {            command.addArgument(s);        }    }    /**     * Get the delimiter that the compiler uses between references.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return "fs";    }    protected void createResourceParameter(NetCommand command,                                           DotnetResource resource) {        resource.getParameters(getProject(), command, false);    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * *//* *  build notes *  -The reference CD to listen to while editing this file is *  nap: Underworld  - Everything, Everything */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;/** * Assembles .NET Intermediate Language files. * ilasm.exe must be on the execute path, unless another executable * or the full path to that executable is specified in the <tt>executable</tt> * parameter *  <p> * *  <p> * *  All parameters are optional: &lt;il/&gt; should suffice to produce a debug *  build of all *.il files. The option set is roughly compatible with the *  CSharp class; even though the command line options are only vaguely *  equivalent. [The low level commands take things like /OUT=file, csc wants *  /out:file ... /verbose is used some places; /quiet here in ildasm... etc.] *  It would be nice if someone made all the command line tools consistent (and *  not as brittle as the java cmdline tools) <p> *  <p> *  The task is a directory based task, so attributes like <b>includes="*.il" *  </b> and <b>excludes="broken.il"</b> can be used to control the files pulled *  in. You can also use nested &lt;src&gt filesets to refer to source. * <p> * * @ant.task    name="ilasm" category="dotnet" */public class Ilasm         extends DotnetBaseMatchingTask {    /**     *  Name of the executable. The .exe suffix is deliberately not included in     *  anticipation of the unix version     */    protected static final String exe_name = "ilasm";    /**     *  what is the file extension we search on?     */    protected static final String file_ext = "il";    /**     *  and now derive the search pattern from the extension     */    protected static final String file_pattern = "**/*." + file_ext;    /**     *  title of task for external presentation     */    protected static final String exe_title = "ilasm";    /**     *  type of target. Should be one of exe|library|module|winexe|(null)     *  default is exe; the actual value (if not null) is fed to the command     *  line. <br>     *  See /target     */    protected String targetType;    /**     *  verbose flag     */    protected boolean verbose;    /**     *  listing flag     */    protected boolean listing;    /**     *  resource file (.res format) to include in the app.     */    protected File resourceFile;    /**     *  flag to control action on execution trouble     */    protected boolean failOnError;    /**     *  debug flag. Controls generation of debug information.     */    protected boolean debug;    /**     *  file containing private key     */    private File keyfile;    /**     *  any extra command options?     */    protected String extraOptions;    /**     * filesets of references     */    protected Vector referenceFilesets = new Vector();    /**     * @since Ant 1.7     */    private boolean isMono = !Os.isFamily("windows");    /**     *  constructor inits everything and set up the search pattern     */    public Ilasm() {        Clear();        setIncludes(file_pattern);    }    /**     *  reset all contents.     */    public void Clear() {        targetType = null;        srcDir = null;        listing = false;        verbose = false;        debug = true;        outputFile = null;        failOnError = true;        resourceFile = null;        extraOptions = null;    }    /**     * Sets the type of target, either "exe" or "library".     *     *@param  targetType          one of exe|library|     *@exception  BuildException  if target is not one of     *      exe|library     */    public void setTargetType(String targetType)             throws BuildException {        this.targetType = targetType.toLowerCase();        if (!targetType.equals("exe") && !targetType.equals("library")) {            throw new BuildException("targetType " + targetType + " is not a valid type");        }    }    /**     *  accessor method for target type     *     *@return    the current target option     */    public String getTargetType() {        return targetType;    }    /**     *  g get the target type or null for no argument needed     *     *@return    The TargetTypeParameter value     */    protected String getTargetTypeParameter() {        if (!notEmpty(targetType)) {            return null;        }        if (targetType.equals("exe")) {            return "/exe";        } else if (targetType.equals("library")) {            return "/dll";        } else {            return null;        }    }    /**     * Sets the Owner attribute.     *     * @param  s  The new Owner value     * @ant.attribute ignore="true"     */    public void setOwner(String s) {        log("This option is not supported by ILASM as of Beta-2, "            + "and will be ignored", Project.MSG_WARN);    }    /**     *  test for a string containing something useful     *     *@param  s       any string     *@return         true if the argument is not null or empty     */    protected boolean notEmpty(String s) {        return s != null && s.length() != 0;    }    /**     *  If true, enable verbose ILASM output.     *     *@param  b  flag set to true for verbose on     */    public void setVerbose(boolean b) {        verbose = b;    }    /**     *  turn the verbose flag into a parameter for ILASM     *     *@return    null or the appropriate command line string     */    protected String getVerboseParameter() {        return verbose ? null : "/quiet";    }    /**     * If true, produce a listing (off by default).     *     *@param  b  flag set to true for listing on     */    public void setListing(boolean b) {        listing = b;    }    /**     *  turn the listing flag into a parameter for ILASM     *     *@return    the appropriate string from the state of the listing flag     */    protected String getListingParameter() {        if (!isMono) {            return listing ? "/listing" : "/nolisting";        }        return null;    }    /**     * Set the output file; identical to setDestFile     * @see DotnetBaseMatchingTask#setDestFile     *@param  params  The new outputFile value     */    public void setOutputFile(File params) {        outputFile = params;    }    /**     *  get the output file     *     *@return    the argument string or null for no argument     */    protected String getOutputFileParameter() {        if (outputFile == null) {            return null;        }        return "/output=" + outputFile.toString();    }    /**     * name of resource file to include.     *     * @param  fileName  path to the file. Can be relative, absolute, whatever.     */    public void setResourceFile(File fileName) {        resourceFile = fileName;    }    /**     *  Gets the resourceFileParameter attribute of the Ilasm task     *     *@return    The resourceFileParameter value     */    protected String getResourceFileParameter() {        if (resourceFile != null) {            return "/resource=" + resourceFile.toString();        } else {            return null;        }    }    /**     * If true, fails if ilasm tool fails.     *     *@param  b  The new failOnError value     */    public void setFailOnError(boolean b) {        failOnError = b;    }    /**     *  query fail on error flag     *     *@return    The failFailOnError value     */    public boolean getFailOnError() {        return failOnError;    }    /**     *  set the debug flag on or off.     *     *@param  f  on/off flag     */    public void setDebug(boolean f) {        debug = f;    }    /**     *  query the debug flag     *     *@return    true if debug is turned on     */    public boolean getDebug() {        return debug;    }    /**     *  get the argument or null for no argument needed     *     *@return    The debugParameter value     */    protected String getDebugParameter() {        return debug ? "/debug" : null;    }    /**     * the name of a file containing a private key.     *     *@param  keyfile  The new keyfile value     */    public void setKeyfile(File keyfile) {        this.keyfile = keyfile;    }    /**     *  get the argument or null for no argument needed     *     *@return    The keyfileParameter value     */    protected String getKeyfileParameter() {        if (keyfile != null) {            return "/keyfile:" + keyfile.toString();        } else {            return null;        }    }    /**     * Any extra options which are not explicitly     * supported by this task.     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     *  Gets the ExtraOptions attribute     *     *@return    The ExtraOptions value     */    public String getExtraOptions() {        return this.extraOptions;    }    /**     *  get any extra options or null for no argument needed     *     *@return    The ExtraOptions Parameter to CSC     */    protected String getExtraOptionsParameter() {        if (extraOptions != null && extraOptions.length() != 0) {            return extraOptions;        } else {            return null;        }    }    /**     * set the target type to one of exe|library     * @param targetType     */    public void setTargetType(TargetTypes targetType) {        this.targetType = targetType.getValue();    }    /**     * Explicitly override the Mono auto-detection.     *     * <p>Defaults to false on Windows and true on any other platform.</p>     *     * @since Ant 1.7     */    public void setMono(boolean b) {        isMono = b;    }    /**     *  This is the execution entry point. Build a list of files and call ilasm     *  on each of them.     *     *@throws  BuildException  if the assembly failed and FailOnError is true     */    public void execute()             throws BuildException {        NetCommand command = buildIlasmCommand();        addFilesAndExecute(command, false);    }    // end execute    /**     * build up our ilasm command     * @return     */    private NetCommand buildIlasmCommand() {        NetCommand command = new NetCommand(this, exe_title, exe_name);        command.setFailOnError(getFailOnError());        //fill in args        command.addArgument(getDebugParameter());        command.addArgument(getTargetTypeParameter());        command.addArgument(getListingParameter());        command.addArgument(getOutputFileParameter());        command.addArgument(getResourceFileParameter());        command.addArgument(getVerboseParameter());        command.addArgument(getKeyfileParameter());        command.addArgument(getExtraOptionsParameter());        /*         *  space for more argumentativeness         *  command.addArgument();         *  command.addArgument();         */        return command;    }    /**     * add a new reference fileset to the compilation     * @param reference     */    public void addReference(FileSet reference) {        referenceFilesets.add(reference);    }    /**     * test for a file being managed or not     * @return true if we think this is a managed executable, and thus OK     * for linking     * @todo look at the PE header of the exe and see if it is managed or not.     */    protected static boolean isFileManagedBinary(File file) {        String filename = file.toString().toLowerCase();        return filename.endsWith(".exe") || filename.endsWith(".dll")                || filename.endsWith(".netmodule");    }    /**     * Target types to build.     * valid build types are exe|library|module|winexe     */    public static class TargetTypes extends EnumeratedAttribute {        public String[] getValues() {            return new String[]{                "exe",                "library",            };        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * Compile J# source down to a managed .NET application. * <p> * J# is not Java. But it is the language closest to Java in the .NET framework. * This task compiles jsharp source (.java files), and * generates a .NET managed exe or dll. * <p> * * <p>For historical reasons the pattern * <code>**</code><code>/*.java</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * @see <A=ref="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_vjsharp/html/vjoriMicrosoftVisualJ.asp"> * Visual J++ online documentation</a> * * @since ant1.6 * @ant.task category="dotnet" name="jsharpc" */public class JSharp extends DotnetCompile {    /**     * hex base address     */    String baseAddress;    /** /x option to disable J++ and J# lang extensions     *     */    boolean pureJava = true;    /**     * whether to make package scoped stuff public or assembly scoped     */    boolean secureScoping = false;    public JSharp() {        setExecutable("vjc");    }    public void setBaseAddress(String baseAddress) {        this.baseAddress = baseAddress;    }    /**     * do we want pure java (default, true) or corrupted J#?     * @param pureJava     */    public void setPureJava(boolean pureJava) {        this.pureJava = pureJava;    }    /**     * Make package scoped code visible to the current assembly only (default: false)     * .NET does not have package scoping. Instead it has assembly, private and public.     * By default, package content is public to all.     * @param secureScoping     */    public void setSecureScoping(boolean secureScoping) {        this.secureScoping = secureScoping;    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ";";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return ".java";    }    /**     * add jvc specific commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        if (pureJava) {            command.addArgument("/x:all");        }        if (secureScoping) {            command.addArgument("/securescoping");        }    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, true);    }    /**     * validation code     * @throws  org.apache.tools.ant.BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;/** * This task compiles Visual Basic.NET source into executables or modules. * The task requires vbc.exe on the execute path, unless it or an equivalent * program is specified in the <tt>executable</tt> parameter * * <p> * All parameters are optional: &lt;vbc/&gt; should suffice to produce a debug * build of all *.vb files. * * <p> * The task is a directory based task, so attributes like * <tt>includes=&quot;**\/*.vb&quot;</tt> and * <tt>excludes=&quot;broken.vb&quot;</tt> can be used to control * the files pulled in. By default, * all *.vb files from the project folder down are included in the command. * When this happens the destFile -if not specified- * is taken as the first file in the list, which may be somewhat hard to control.   Specifying the output file with <tt>destfile</tt> is prudent. </p> <p> * Also, dependency checking only works if destfile is set. * * <p>For historical reasons the pattern * <code>**</code><code>/*.vb</code> is preset as includes list and * you can not override it with an explicit includes attribute.  Use * nested <code>&lt;src&gt;</code> elements instead of the basedir * attribute if you need more control.</p> * * As with &lt;csc&gt; nested <tt>src</tt> filesets of source, * reference filesets, definitions and resources can be provided. * * <p> * Example * </p> * <pre>&lt;vbc *   optimize=&quot;true&quot; *   debug=&quot;false&quot; *   warnLevel=&quot;4&quot; *   targetType=&quot;exe&quot; *   definitions=&quot;RELEASE&quot; *   excludes=&quot;src/unicode_class.vb&quot; *   mainClass = &quot;MainApp&quot; *   destFile=&quot;NetApp.exe&quot; *   optionExplicit=&quot;true&quot; *   optionCompare=&quot;text&quot; *   references="System.Xml,System.Web.Xml" *   &gt; *          &lt;reference file="${testCSC.dll}" /&gt; *          &lt;define name="RELEASE" /&gt; *          &lt;define name="DEBUG" if="debug.property"/&gt; *          &lt;define name="def3" unless="def2.property"/&gt; *   &lt;/vbc&gt; </pre> * @ant.task    name="vbc" category="dotnet" */public class VisualBasicCompile extends DotnetCompile {    /**     * Compiler option to remove integer checks. Default: false.     */    private boolean removeIntChecks = false;    /**     * Require explicit declaration of variables? Default: false.     */    private boolean optionExplicit = false;    /**     * Enforce strict language semantics? Default: false.     */    private boolean optionStrict = false;    /**     * Whether to compare strings as "text" or "binary". Default: "binary".     */    private String optionCompare;    /**     * Root namespace for all type declarations.     */    private String rootNamespace;    /**     * Declare global imports fornamespaces in referenced metadata files.     */    private String imports;    /**     * Constructor for VisualBasicCompile.     */    public VisualBasicCompile() {        clear();    }    /**     *  reset all contents.     */    public void clear() {        super.clear();        imports = null;        rootNamespace = null;        optionCompare = null;        optionExplicit = false;        optionStrict = false;        removeIntChecks = false;        setExecutable("vbc");    }    /**     *  get the argument or null for no argument needed     *  This is overridden from DotnetCompile.java because VBC uses     *  "/win32resource:" rather than "/win32res:"     *     *@return    The Win32Res Parameter to CSC     */    protected String getWin32ResParameter() {        if (getWin32Res() != null) {            return "/win32resource:" + getWin32Res().toString();        } else {            return null;        }    }    /**     * Whether to remove integer checks. Default false.     * @param  flag  on/off flag     */    public void setRemoveIntChecks(boolean flag) {        removeIntChecks = flag;    }    /**     * Get the flag for removing integer checks.     * @return    true if flag is turned on     */    public boolean getRemoveIntChecks() {        return removeIntChecks;    }    /**     * Form the option string for removeIntChecks.     * @return The parameter string.     */    public String getRemoveIntChecksParameter() {        return "/removeintchecks" + (removeIntChecks ? "+" : "-");    }    /**     * Whether to require explicit declaration of variables.     * @param  flag  on/off flag     */    public void setOptionExplicit(boolean flag) {        optionExplicit = flag;    }    /**     * Get the flag for whether to require explicit declaration of variables.     *@return    true if flag is turned on     */    public boolean getOptionExplicit() {        return optionExplicit;    }    /**     * Form the option string for optionExplicit..     * @return The parameter string.     */    public String getOptionExplicitParameter() {        return "/optionexplicit" + (optionExplicit ? "+" : "-");    }    /**     * Enforce strict language semantics.     * @param  flag  on/off flag     */    public void setOptionStrict(boolean flag) {        optionStrict = flag;    }    /**     * Get the flag for whether to enforce strict language semantics.     * @return    true if flag is turned on     */    public boolean getOptionStrict() {        return optionStrict;    }    /**     * For the option string for optionStrict.     * @return The parameter string.     */    public String getOptionStrictParameter() {        return "/optionstrict" + (optionStrict ? "+" : "-");    }    /**     * Specifies the root namespace for all type declarations.     * @param rootNamespace a root namespace.     */    public void setRootNamespace(String rootNamespace) {        this.rootNamespace = rootNamespace;    }    /**     * Get the root namespace.     * @return  the root namespace.     */    public String getRootNamespace() {        return this.rootNamespace;    }    /**     * Form the option string for rootNamespace.     * @return  the root namespace option string.     */    protected String getRootNamespaceParameter() {        if (rootNamespace != null && rootNamespace.length() != 0) {            return "/rootnamespace:" + rootNamespace;        } else {            return null;        }    }    /**     * Declare global imports for namespaces in referenced metadata files.     * @param imports the imports string     */    public void setImports(String imports) {        this.imports = imports;    }    /**     * Get global imports for namespaces in referenced metadata files.     * @return  the imports string.     */    public String getImports() {        return this.imports;    }    /**     * Format the option for imports.     * @return  the formatted import option.     */    protected String getImportsParameter() {        if (imports != null && imports.length() != 0) {            return "/imports:" + imports;        } else {            return null;        }    }    /**     * Specify binary- or text-style string comparisons. Defaults     * to "binary"     * @param optionCompare the option compare style. "text" | "binary".     */    public void setOptionCompare(String optionCompare) {        if ("text".equalsIgnoreCase(optionCompare)) {            this.optionCompare = "text";        } else {            this.optionCompare = "binary";        }    }    /**     * "binary" or "text" for the string-comparison style.     * @return  the option compare style.     */    public String getOptionCompare() {        return this.optionCompare;    }    /**     * Format the option for string comparison style.     * @return  The formatted option.     */    protected String getOptionCompareParameter() {        if (optionCompare != null && "text".equalsIgnoreCase(optionCompare)) {            return "/optioncompare:text";        } else {            return "/optioncompare:binary";        }    }    /**     * implement VBC commands     * @param command     */    protected void addCompilerSpecificOptions(NetCommand command) {        command.addArgument(getRemoveIntChecksParameter());        command.addArgument(getImportsParameter());        command.addArgument(getOptionExplicitParameter());        command.addArgument(getOptionStrictParameter());        command.addArgument(getRootNamespaceParameter());        command.addArgument(getOptionCompareParameter());    }    /**     * Get the delimiter that the compiler uses between references.     * For example, c# will return ";"; VB.NET will return ","     * @return The string delimiter for the reference string.     */    public String getReferenceDelimiter() {        return ",";    }    /**     * Get the extension of filenames to compile.     * @return The string extension of files to compile.     */    public String getFileExtension() {        return "vb";    }    protected void createResourceParameter(NetCommand command, DotnetResource resource) {        resource.getParameters(getProject(), command, false);    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        super.validate();        if (getDestFile() == null) {            throw new BuildException("DestFile was not specified");        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.compile;import java.io.File;import java.util.Vector;import java.util.Iterator;import java.net.MalformedURLException;import org.apache.ant.dotnet.NetCommand;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.Project;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.taskdefs.condition.Os;import org.apache.tools.ant.util.FileUtils;/** * Converts a WSDL file or URL resource into a .NET language. * * Why add a wrapper to the MS WSDL tool? * So that you can verify that your web services, be they written with Axis or *anyone else's SOAP toolkit, work with .NET clients. * *This task is dependency aware when using a file as a source and destination; *so if you &lt;get&gt; the file (with <code>usetimestamp="true"</code>) then *you only rebuild stuff when the WSDL file is changed. Of course, *if the server generates a new timestamp every time you ask for the WSDL, *this is not enough...use the &lt;filesmatch&gt; &lt;condition&gt; to *to byte for byte comparison against a cached WSDL file then make *the target conditional on that test failing. * See "Creating an XML Web Service Proxy", "wsdl.exe" docs in * the framework SDK documentation * @version     0.5 * @ant.task    category="dotnet" * @since       Ant 1.5 */public class WsdlToDotnet extends Task  {    /**     * used for timestamp checking     */    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();    /**     * name of output file (required)     */    private File destFile = null;    /**     * language; defaults to C#     */    private String language = "CS";    /**     * flag set to true to generate server side skeleton     */    private boolean server = false;    /**     * namespace     */    private String namespace = null;    /**     *  flag to control action on execution trouble     */    private boolean failOnError = true;    /**     *  any extra command options?     */    protected String extraOptions = null;    /**     * protocol string. Exact value set depends on SOAP stack version.     * @since Ant 1.7     */    private String protocol = null;    /**     * should errors come in an IDE format. This     * is WSE only.     * @since Ant 1.7     */    private boolean ideErrors = false;    /**     * filesets of file to compile     * @since Ant 1.7     */    private Vector schemas = new Vector();    /**     * our WSDL file.     * @since ant1.7     */    private Schema wsdl = new Schema();    /**     * compiler     * @since ant1.7     */    private Compiler compiler = null;    /**     * error message: dest file is a directory     */    public static final String ERROR_DEST_FILE_IS_DIR = "destination file is a directory";    /**     * error message: no dest file     */    public static final String ERROR_NO_DEST_FILE = "destination file must be specified";    /**     * Name of the file to generate. Required     * @param destFile filename     */    public void setDestFile(File destFile) {        this.destFile = destFile;    }    /**     * Sets the URL to fetch. Fetching is by wsdl.exe; Ant proxy settings     * are ignored; either url or srcFile is required.     * @param url url to save     */    public void setUrl(String url) {        wsdl.setUrl(url);    }    /**     * The local WSDL file to parse; either url or srcFile is required.     * @param srcFile WSDL file     */    public void setSrcFile(File srcFile) {        wsdl.setFile(srcFile);    }    /**     * set the language; one of "CS", "JS", or "VB"     * optional, default is CS for C# source     * @param language language to generate     */    public void setLanguage(String language) {        this.language = language;    }    /**     * flag to enable server side code generation;     * optional, default=false     * @param server server-side flag     */    public void setServer(boolean server) {        this.server = server;    }    /**     * namespace to place  the source in.     * optional; default ""     * @param namespace new namespace     */    public void setNamespace(String namespace) {        this.namespace = namespace;    }    /**     * Whether or not a failure should halt the build.     * Optional - default is <code>true</code>.     * @param failOnError new failure option     */    public void setFailOnError(boolean failOnError) {        this.failOnError = failOnError;    }    /**     *  Any extra WSDL.EXE options which aren't explicitly     *  supported by the ant wrapper task; optional     *     *@param  extraOptions  The new ExtraOptions value     */    public void setExtraOptions(String extraOptions) {        this.extraOptions = extraOptions;    }    /**     * Defines wether errors are machine parseable.     * Optional, default=true     *     * @since Ant 1.7     * @param ideErrors     */    public void setIdeErrors(boolean ideErrors) {        this.ideErrors = ideErrors;    }    /**     * what protocol to use. SOAP, SOAP1.2, HttpPost and HttpGet     * are the base options. Different version and implementations may.     * offer different options.     * @since Ant 1.7     *     * @param protocol     */    public void setProtocol(String protocol) {        this.protocol = protocol;    }    /**     * add a new source schema to the compilation     * @since Ant 1.7     *     * @param source     */    public void addSchema(Schema source) {        schemas.add(source);    }    /**     * flag to trigger turning a filename into a file:url     * ignored for the mono compiler.     * @param b     */    public void setMakeURL(boolean b) {        wsdl.setMakeURL(b);    }    /**     * identify the compiler     * @since Ant 1.7     * @param compiler     */    public void setCompiler(Compiler compiler) {        this.compiler = compiler;    }    /**     * validation code     * @throws  BuildException  if validation failed     */    protected void validate()            throws BuildException {        if (destFile == null) {            throw new BuildException(ERROR_NO_DEST_FILE);        }        if (destFile.isDirectory()) {            throw new BuildException(                    ERROR_DEST_FILE_IS_DIR);        }        wsdl.validate();    }    /**     *  do the work by building the command line and then calling it     *     *@throws  BuildException  if validation or execution failed     */    public void execute()             throws BuildException {        if ("WsdlToDotnet".equals(getTaskType())) {            log("Warning: the task name <WsdlToDotnet> is deprecated. Use <wsdltodotnet> (all lowercase) instead.", Project.MSG_WARN);        }        if (compiler == null) {            compiler = Compiler.createDefaultCompiler();        }        validate();        NetCommand command = new NetCommand(this,                "WSDL",                compiler.getCommand());        command.setFailOnError(failOnError);        //fill in args        compiler.applyExtraArgs(command);        command.addArgument("/nologo");        command.addArgument("/out:" + destFile);        command.addArgument("/language:", language);        if (server) {            command.addArgument("/server");        }        command.addArgument("/namespace:", namespace);        if (protocol != null) {            command.addArgument("/protocol:" + protocol);        }        if (ideErrors) {            command.addArgument("/parsableErrors");        }        command.addArgument(extraOptions);        //set source and rebuild options        boolean rebuild = true;        long destLastModified = -1;        //rebuild unless the dest file is newer than the source file        if (destFile.exists()) {            destLastModified = destFile.lastModified();            rebuild = isRebuildNeeded(wsdl, destLastModified);        }        String path;        //mark for a rebuild if the dest file is newer        path = wsdl.evaluate();        if (!compiler.supportsAbsoluteFiles() && wsdl.getFile() != null) {            // Mono 1.0's wsdl doesn't deal with absolute paths            File f = wsdl.getFile();            command.setDirectory(f.getParentFile());            path = f.getName();        }        command.addArgument(path);        //add in any extra files.        //this is an error in mono, but we do not warn on it as they may fix that outside        //the ant build cycle.        Iterator it = schemas.iterator();        while (it.hasNext()) {            Schema schema = (Schema) it.next();            //mark for a rebuild if we are newer            rebuild |= isRebuildNeeded(schema, destLastModified);            command.addArgument(schema.evaluate());        }        //conditionally compile        if (rebuild) {            command.runCommand();        }    }    /**     * checks for a schema being out of data     * @param schema url/file     * @param destLastModified timestamp, -1 for no dest     * @return true if a rebuild is needed.     */    private boolean isRebuildNeeded(Schema schema, long destLastModified) {        if (destLastModified == -1) {            return true;        }        return !FILE_UTILS.isUpToDate(schema.getTimestamp(), destLastModified);    }    /**     * nested schema class     * Only supported on NET until mono add multi-URL handling on the command line     */    public static class Schema {        private File file;        private String url;        private boolean makeURL = false;        public static final String ERROR_NONE_DECLARED = "One of file and url must be set";        public static final String ERROR_BOTH_DECLARED = "Only one of file or url can be set";        public static final String ERROR_FILE_NOT_FOUND = "Not found: ";        public static final String ERROR_FILE_IS_DIR = "File is a directory: ";        public static final String ERROR_NO_URL_CONVERT = "Could not URL convert ";        /**         * validate the schema         */        public  void validate() {            if (file != null) {                if (!file.exists()) {                    throw new BuildException(ERROR_FILE_NOT_FOUND + file.toString());                }                if (file.isDirectory()) {                    throw new BuildException(ERROR_FILE_IS_DIR + file.toString());                }            }            if (file != null && url != null) {                throw new BuildException(ERROR_BOTH_DECLARED);            }            if (file == null && url == null) {                throw new BuildException(ERROR_NONE_DECLARED);            }        }        /**         * Validate our settings.         * @return either the URL or the full file path         */        public String evaluate() {            validate();            if (url != null) {                return getUrl();            }            if (makeURL) {                try {                    return FILE_UTILS.getFileURL(file).toExternalForm();                } catch (MalformedURLException e) {                    throw new BuildException(ERROR_NO_URL_CONVERT + file);                }            }            return file.toString();        }        public File getFile() {            return file;        }        /**         * name of a file to use as a source of WSDL or XSD data         * @param file         */        public void setFile(File file) {            this.file = file;        }        public String getUrl() {            return url;        }        /**         * url of a resource.         * URLs have no timestamp checking, and are not validated         * @param url         */        public void setUrl(String url) {            this.url = url;        }        public boolean isMakeURL() {            return makeURL;        }        /**         * flag to request that a file is turned into an absolute file: URL         * before being passed to the WSDL compiler         * @param makeURL         */        public void setMakeURL(boolean makeURL) {            this.makeURL = makeURL;        }        /**         * Gets the file timestamp.         * @return the timestamp of a file, or -1 for a URL (meaning we do not know its age)         */        public long getTimestamp() {            if (file != null) {                return file.lastModified();            } else {                return -1;            }        }    }    /**     * The enumerated values for our compiler     */    public static class Compiler extends EnumeratedAttribute {        public static final String COMPILER_MS = "microsoft";        public static final String COMPILER_MONO = "mono";        public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono";        String[] compilers = {            COMPILER_MS,            COMPILER_MONO,            COMPILER_MS_ON_MONO        };        public static final String EXE_WSDL = "wsdl";        public static final String EXE_MONO = "mono";        /**         * programs to run         */        String[] compilerExecutables = {            EXE_WSDL,            EXE_WSDL,            EXE_MONO        };        /**         * extra things         */        String[][] extraCompilerArgs = {            {},            {},            {EXE_WSDL + ".exe"}        };        boolean[] absoluteFiles = {            true,            false,            true        };        /**         * This is the only method a subclass needs to implement.         *         * @return an array holding all possible values of the enumeration.         *         The order of elements must be fixed so that <tt>indexOfValue(String)</tt>         *         always return the same index for the same value.         */        public String[] getValues() {            return compilers;        }        /**         * Create the default compiler for this platform.         * @return the default compiler         */        public static Compiler createDefaultCompiler() {            Compiler c = new Compiler();            String compilerName;            compilerName = Os.isFamily("windows") ? COMPILER_MS : COMPILER_MONO;            c.setValue(compilerName);            return c;        }        /**         * return the command to run         * @return the command         */        public String getCommand() {            return compilerExecutables[getIndex()];        }        /**         * return any extra arguments for the compiler         * @return extra compiler arguments         */        public String[] getExtraArgs() {            return extraCompilerArgs[getIndex()];        }        public boolean supportsAbsoluteFiles() {            return absoluteFiles[getIndex()];        }        /**         * apply any extra arguments of this class         * @param command         */        public void applyExtraArgs(NetCommand command) {            String[] args = getExtraArgs();            for (int i = 0; i < args.length; i++) {               command.addArgument(args[i]);            }        }    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.util;import java.util.Collection;import java.util.Iterator;/** * Helper methods related to collection manipulation. * * <p>This is a stripped down copy of Ant 1.8.2's version so the .NET * Antlib can still be used with Ant 1.7.0.</p> * * @since .NET Antlib 1.1 */public class CollectionUtils {    /**     * Creates a comma separated list of all values held in the given     * collection.     *     * @since .NET Antlib 1.1     */    public static String flattenToString(Collection c) {        return flattenToString(c, ",");    }    /**     * Creates a list of all values held in the given collection     * separated by the given separator.     *     * @since .NET Antlib 1.1     */    public static String flattenToString(Collection c, String sep) {        Iterator iter = c.iterator();        boolean first = true;        StringBuffer sb = new StringBuffer();        while (iter.hasNext()) {            if (!first) {                sb.append(sep);            }            sb.append(String.valueOf(iter.next()));            first = false;        }        return sb.toString();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.wix;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.ant.dotnet.build.AbstractBuildTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.DirSet;import java.io.File;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.Set;/** * Task to run the tallow on packaging content to create a wxs file * * @see http://sf.net/projects/wix */public class TallowTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source dirs.     */    private ArrayList sources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * Where is WiX installed?     */    private File wixHome = null;    /**     * addtional command line arguments for tallow.     */    private Commandline cmdl = new Commandline();    public TallowTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>tallow</code> may include more directories than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * The main target file.     *     * @param File object of the main target file.     */    public void setTarget(File f) {        target = f;    }    /**     * A set of source files.     */    public void addSources(DirSet ds) {        sources.add(ds);    }    /**     * Sets the installation directory of WiX.     *     * <p>If omitted, Ant will assume that WiX's executables can be     * found on the PATH.</p>     */    public void setWixHome(File f) {        wixHome = f;    }    /**     * Adds a command-line argument for tallow.exe.     *     * @return new command line argument created.     */    public Commandline.Argument createArg() {        return cmdl.createArgument();    }    public void execute() {        Collection grabbedDirs = grabSources();        if (target == null) {            throw new BuildException("You must specify the target if you want"                                     + " to run tallow.");        }        runTallow(grabbedDirs);    }    private Collection grabSources() {        Set r = new HashSet();        if (source != null) {            if (!source.exists()) {                throw new BuildException("Source " + source                                         + " doesn't exist.");            } else if (!source.isDirectory()) {                throw new BuildException("Source " + source                                         + " is not directory.");            }            r.add(source);        } else if (sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        } else {            Iterator iter = sources.iterator();            while (iter.hasNext()) {                DirSet ds = (DirSet) iter.next();                DirectoryScanner scanner = ds.getDirectoryScanner(getProject());                String[] f = scanner.getIncludedDirectories();                File base = ds.getDir(getProject());                for (int i = 0; i < f.length; i++) {                    r.add(new File(base, f[i]));                }            }            if (r.isEmpty()) {                throw new BuildException("No sources found");            }        }        return r;    }    /**     * Run tallow passing all files of the collection on the command line.     */    private void runTallow(Collection s) {        run(wixExecutable("tallow.exe"), s, target, cmdl);    }    /**     * returns an absolute path for the given executable if wixHome     * has been specified, the given name otherwise.     */    private String wixExecutable(String name) {        return wixHome == null ? name            : new File(wixHome, name).getAbsolutePath();    }    /**     * Runs the specified command passing all files of the collection     * on the command line - potentially adding an /out parameter.     */    private void run(String executable, Collection s, File target,                     Commandline cmdl) {        DotNetExecTask exec =             DotNetExecTask.getTask(this, vm, executable, null);        exec.setFailonerror(true);        exec.setTaskType("wix");        exec.createArg().setValue("/nologo");        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue("-d");            exec.createArg().setValue(f.getAbsolutePath());        }        String[] extraArgs = cmdl.getArguments();        for (int i = 0; i < extraArgs.length; i++) {            exec.createArg().setValue(extraArgs[i]);        }        exec.setOutput (target);        exec.execute();    }}
Apache .NET Ant Library/* *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * */package org.apache.ant.dotnet.wix;import org.apache.ant.dotnet.DotNetExecTask;import org.apache.ant.dotnet.build.AbstractBuildTask;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.DirectoryScanner;import org.apache.tools.ant.Task;import org.apache.tools.ant.types.Commandline;import org.apache.tools.ant.types.EnumeratedAttribute;import org.apache.tools.ant.types.FileSet;import java.io.File;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;/** * Task to run the WiX utility to create MSI files from an XML description. * * @see http://sf.net/projects/wix */public class WixTask extends Task {    /**     * The vm attribute - if given.     */    private String vm;    /**     * The source files.     */    private ArrayList sources = new ArrayList();    /**     * Additional source files (include files in the case of candle,     * or media/files/whatever in the case of light).     */    private ArrayList moreSources = new ArrayList();    /**     * A single source file.     */    private File source;    /**     * The target file.     */    private File target;    /**     * What to do.     */    private Mode mode;    /**     * Where is WiX installed?     */    private File wixHome = null;    /**     * Where to place the generated .wixobj files.     */    private File wixobjDestDir = null;    /**     * addtional command line arguments for candle.     */    private Commandline candleCmdl = new Commandline();    /**     * list of parameters for the preprocessor.     */    private ArrayList candleParameters = new ArrayList();    /**     * addtional command line arguments for light.     */    private Commandline lightCmdl = new Commandline();    /**     * list of parameters for the "compiler".     */    private ArrayList lightParameters = new ArrayList();    /**     * Whether to use lit.exe rather than light.exe.     */    private boolean useLit = false;    public WixTask() {        super();    }    /**     * Set the name of the executable for the virtual machine.     *     * @param value the name of the executable for the virtual machine     */    public void setVm(String value) {        this.vm = value;    }    /**     * The main source file.     *     * <p><code>candle</code> may include more files than this one,     * the main source is the one passed on the command line.</p>     *     * @param File object of the main source file.     */    public void setSource(File f) {        source = f;    }    /**     * The main target file.     *     * @param File object of the main target file.     */    public void setTarget(File f) {        target = f;    }    /**     * A set of source files.     */    public void addSources(FileSet fs) {        sources.add(fs);    }    /**     * A set of additional source files (include files in the case of     * candle, or media/files/whatever in the case of light).     *     * <p>Unlike the files specified as sources, these will not be     * passed on the command line, they only help Ant to determine     * whether the target is out-of-date.</p>     */    public void addMoreSources(FileSet fs) {        moreSources.add(fs);    }    /**     * Sets the installation directory of WiX.     *     * <p>If omitted, Ant will assume that WiX's executables can be     * found on the PATH.</p>     */    public void setWixHome(File f) {        wixHome = f;    }    /**     * Whether to run candle, light or both.     */    public void setMode(Mode m) {        mode = m;    }    /**     * Sets the destination directory for wixobj files generated by candle.     *     * <p>Let's candle decide and assumes they'll be created in the     * current working directory.</p>     */    public void setWixobjDestDir(File f) {        wixobjDestDir = f;    }    /**     * A parameter to pass to candle.exe.     */    public final void addCandleParameter(AbstractBuildTask.Property t) {        candleParameters.add(t);    }    /**     * A parameter to pass to light.exe.     */    public final void addLightParameter(AbstractBuildTask.Property t) {        lightParameters.add(t);    }    /**     * Adds a command-line argument for light.exe.     *     * @return new command line argument created.     */    public Commandline.Argument createLightArg() {        return lightCmdl.createArgument();    }    /**     * Adds a command-line argument for candle.exe.     *     * @return new command line argument created.     */    public Commandline.Argument createCandleArg() {        return candleCmdl.createArgument();    }    /**     * Instructs the task to use lit.exe rather than light.exe as "compiler".     *     * @since .NET Antlib 1.1     */    public void setUseLit(boolean b) {        useLit = b;    }    public void execute() {        if (source == null && sources.size() == 0) {            throw new BuildException("You must specify at least one source"                                     + " file.");        }        if (source != null && !source.exists()) {            throw new BuildException("Source file " + source                                     + " doesn't exist.");        }        String m = Mode.BOTH;        if (mode != null) {            m = mode.getValue();        }        if (target == null && !m.equals(Mode.CANDLE)) {            throw new BuildException("You must specify the target if you want"                                     + " to run light.");        }        Collection lightSources = null;        if (!m.equals(Mode.LIGHT)) {            lightSources = doCandle();        } else {            lightSources = new HashSet();            if (source != null) {                lightSources.add(source);            }            if (sources.size() > 0) {                lightSources.addAll(grabFiles(sources));            }        }        if (!m.equals(Mode.CANDLE)) {            Collection moreLightSources = Collections.EMPTY_SET;            if (moreSources.size() > 0) {                moreLightSources = grabFiles(moreSources);            }            doLight(lightSources, moreLightSources);        }    }    /**     * Invoke candle on all sources that are newer than their targets.     *     * @return a set of File objects pointing to the generated files.     */    private Collection doCandle() {        Set s = new HashSet();        if (source != null) {            s.add(source);        }        if (sources != null) {            s.addAll(grabFiles(sources));        }        Set ms = new HashSet();        if (moreSources != null) {            ms.addAll(grabFiles(moreSources));        }        Set toProcess = new HashSet();        Set generatedTargets = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            File thisSource = (File) iter.next();            File t = getTarget(thisSource);            generatedTargets.add(t);            if (isOutOfDate(t, thisSource, ms)) {                toProcess.add(thisSource);            }        }        if (toProcess.size() != 0) {            runCandle(toProcess);            return generatedTargets;        }        return Collections.EMPTY_SET;    }    /**     * Invoke light on all sources that are newer than their targets.     */    private void doLight(Collection lightSources,                         Collection moreLightSources) {        Set tmp = new HashSet(lightSources);        tmp.addAll(moreLightSources);        if (isOutOfDate(target, tmp)) {            runLight(lightSources);        }    }    /**     * Run candle passing all files of the collection on the command line.     */    private void runCandle(Collection s) {        run(wixExecutable("candle.exe"), s, null, wixobjDestDir,            candleParameters, candleCmdl);    }    /**     * Run light passing all files of the collection on the command line.     */    private void runLight(Collection s) {        run(wixExecutable(useLit ? "lit.exe" : "light.exe"), s, target, null,            lightParameters, lightCmdl);    }    /**     * returns an absolute path for the given executable if wixHome     * has been specified, the given name otherwise.     */    private String wixExecutable(String name) {        return wixHome == null ? name            : new File(wixHome, name).getAbsolutePath();    }    /**     * Runs the specified command passing all files of the collection     * on the command line - potentially adding an /out parameter.     */    private void run(String executable, Collection s, File target,                     File runInDir, Collection params, Commandline cmdl) {        DotNetExecTask exec = DotNetExecTask.getTask(this, vm,                                                      executable, null);        if (runInDir != null) {            exec.setDir(runInDir);        }        exec.setFailonerror(true);        exec.setTaskType("wix");        exec.createArg().setValue("/nologo");        Iterator iter = s.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            exec.createArg().setValue(f.getAbsolutePath());        }        if (target != null) {            exec.createArg().setValue("/out");            exec.createArg().setValue(target.getAbsolutePath());        }        iter = params.iterator();        while (iter.hasNext()) {            AbstractBuildTask.Property p =                (AbstractBuildTask.Property) iter.next();            exec.createArg().setValue("-d" + p.getName() + "=" + p.getValue());        }        String[] extraArgs = cmdl.getArguments();        for (int i = 0; i < extraArgs.length; i++) {            exec.createArg().setValue(extraArgs[i]);        }        exec.execute();    }    /**     * Is t older than s or any of the files in list?     */    private boolean isOutOfDate(File t, File s, Collection l) {        return t.lastModified() < s.lastModified() || isOutOfDate(t, l);    }    /**     * Is t older than any of the files in list?     */    private boolean isOutOfDate(File t, Collection l) {        Iterator iter = l.iterator();        while (iter.hasNext()) {            File f = (File) iter.next();            if (t.lastModified() < f.lastModified()) {                return true;            }        }        return false;    }    /**     * Turn the fileset collection into a list of Files.     */    private Collection grabFiles(Collection s) {        Set r = new HashSet();        Iterator iter = s.iterator();        while (iter.hasNext()) {            FileSet fs = (FileSet) iter.next();            DirectoryScanner ds = fs.getDirectoryScanner(getProject());            String[] f = ds.getIncludedFiles();            File base = fs.getDir(getProject());            for (int i = 0; i < f.length; i++) {                r.add(new File(base, f[i]));            }        }        return r;    }    /**     * Generates the name of a candle target from the source file.     *     * <p>Simply chops of the extension, adds .wixobj and calculates     * the absolute path based on wixobjDestDir.</p>     */    private File getTarget(File s) {        String name = s.getName();        int dot = name.lastIndexOf(".");        if (dot > -1) {            name = name.substring(0, dot) + ".wixobj";        } else {            name = name + ".wixobj";        }        return wixobjDestDir == null            ? new File(name) : new File(wixobjDestDir, name);    }    public static class Mode extends EnumeratedAttribute {        private final static String CANDLE = "candle";        private final static String LIGHT = "light";        private final static String BOTH = "both";        public Mode() {            super();        }        public String[] getValues() {            return new String[] {CANDLE, LIGHT, BOTH,};        }    }}
Apache .NET Ant Library/*  *  Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. *  */ /** * this is a j# class, not a java one. */public class jsharp {        public static void main(String args[]) {		System.out.println("hello, I look like Java, but I'm really J#");    }    }
